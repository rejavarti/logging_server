/**
 * Enhanced Universal Logging Server - Stable Version
 * Based on working simple-server.js with enterprise features added
 * 
 * Tom Nelson - 2025
 * Features: Multi-user authentication, enterprise dashboard, all integrations
 */

const express = require('express');
const session = require('express-session');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const sqlite3 = require('sqlite3').verbose();
const moment = require('moment-timezone');
const winston = require('winston');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const basicAuth = require('basic-auth');
const crypto = require('crypto');
const axios = require('axios');
const mqtt = require('mqtt');
const WebSocket = require('ws');
const cron = require('node-cron');
const rateLimit = require('express-rate-limit');
const geoip = require('geoip-lite');
const useragent = require('useragent-parser');
const nodemailer = require('nodemailer');
const twilio = require('twilio');
const Pushover = require('pushover-notifications');
const Fuse = require('fuse.js');

// Multi-Protocol Log Ingestion Dependencies
const dgram = require('dgram');
const net = require('net');
const { pipeline } = require('stream');
const zlib = require('zlib');

// Distributed Tracing Dependencies
const { NodeSDK } = require('@opentelemetry/sdk-node');
const { Resource } = require('@opentelemetry/resources');
const { SemanticResourceAttributes } = require('@opentelemetry/semantic-conventions');
const { JaegerExporter } = require('@opentelemetry/exporter-jaeger');
const { BatchSpanProcessor } = require('@opentelemetry/sdk-trace-base');
const opentelemetry = require('@opentelemetry/api');
const _ = require('lodash');

const app = express();
global.app = app; // Make app global for tracing middleware
const PORT = process.env.PORT || 10180;
const TIMEZONE = process.env.TIMEZONE || 'America/Edmonton'; // Mountain Time (Canada)

// Import the centralized Database Access Layer
const DatabaseAccessLayer = require('./database-access-layer');

// Global DAL instance - replaces all scattered db.run/get/all calls
let dal = null;

// Configuration
const config = {
    system: {
        name: "Universal Enterprise Logging Platform",
        version: "2.1.0-stable-enhanced",
        owner: "Tom Nelson",
        timezone: TIMEZONE
    },
    auth: {
        jwtSecret: process.env.JWT_SECRET || crypto.randomBytes(64).toString('hex'),
        saltRounds: 12,
        sessionSecret: process.env.SESSION_SECRET || crypto.randomBytes(64).toString('hex')
    },
    integrations: {
        unifi: {
            enabled: process.env.UNIFI_ENABLED === 'true' || false,
            host: process.env.UNIFI_HOST || "https://unifi.local:8443",
            username: process.env.UNIFI_USER || "",
            password: process.env.UNIFI_PASS || "",
            pollInterval: parseInt(process.env.UNIFI_POLL_INTERVAL) || 300 // 5 minutes
        },
        homeAssistant: {
            enabled: process.env.HA_ENABLED === 'true' || false,
            host: process.env.HA_HOST || "http://homeassistant.local:8123",
            token: process.env.HA_TOKEN || "",
            websocketEnabled: process.env.HA_WEBSOCKET === 'true' || true
        },
        mqtt: {
            enabled: process.env.MQTT_ENABLED === 'true' || false,
            broker: process.env.MQTT_BROKER || "mqtt://localhost:1883",
            username: process.env.MQTT_USER || "",
            password: process.env.MQTT_PASS || "",
            topic: process.env.MQTT_TOPIC || "enterprise/logs",
            topics: ['dsc/+/+', 'homeassistant/+/+', 'iot/+/+', 'security/+/+'],
            nodeRedLogging: {
                enabled: process.env.NODE_RED_LOGGING_ENABLED === 'true' || true,
                errorTopic: process.env.NODE_RED_ERROR_TOPIC || 'homeassistant/logging/+/error',
                criticalTopic: process.env.NODE_RED_CRITICAL_TOPIC || 'homeassistant/logging/+/critical'
            }
        },
        websocket: {
            enabled: process.env.WS_ENABLED === 'true' || true,
            port: parseInt(process.env.WS_PORT) || (PORT + 1)
        }
    },
    ingestion: {
        syslog: {
            enabled: process.env.SYSLOG_ENABLED === 'true' || true,
            udpPort: parseInt(process.env.SYSLOG_UDP_PORT) || 514,
            tcpPort: parseInt(process.env.SYSLOG_TCP_PORT) || 601
        },
        gelf: {
            enabled: process.env.GELF_ENABLED === 'true' || true,
            udpPort: parseInt(process.env.GELF_UDP_PORT) || 12201,
            tcpPort: parseInt(process.env.GELF_TCP_PORT) || 12202
        },
        beats: {
            enabled: process.env.BEATS_ENABLED === 'true' || true,
            tcpPort: parseInt(process.env.BEATS_TCP_PORT) || 5044
        },
        fluent: {
            enabled: process.env.FLUENT_ENABLED === 'true' || true,
            httpPort: parseInt(process.env.FLUENT_HTTP_PORT) || 9880
        }
    },
    tracing: {
        enabled: process.env.TRACING_ENABLED === 'true' || true,
        serviceName: process.env.TRACING_SERVICE_NAME || 'enterprise-logging-platform',
        jaegerEndpoint: process.env.JAEGER_ENDPOINT || 'http://localhost:14268/api/traces',
        samplingRate: parseFloat(process.env.TRACING_SAMPLING_RATE) || 1.0,
        enableConsoleExporter: process.env.TRACING_CONSOLE === 'true' || false
    },
    maintenance: {
        logRetentionDays: parseInt(process.env.LOG_RETENTION_DAYS) || 30,
        backupSchedule: process.env.BACKUP_SCHEDULE || '0 2 * * *', // Daily at 2 AM
        cleanupSchedule: process.env.CLEANUP_SCHEDULE || '0 3 * * 0' // Weekly on Sunday at 3 AM
    }
};

// Ensure directories exist
const dataDir = path.join(__dirname, 'data');
const dbDir = path.join(dataDir, 'databases');
const logDir = path.join(dataDir, 'logs');

[dataDir, dbDir, logDir].forEach(dir => {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
});

// Custom timestamp format using configured timezone
const timezoneTimestamp = winston.format((info) => {
    info.timestamp = moment().tz(TIMEZONE).format('YYYY-MM-DD HH:mm:ss z');
    return info;
});

// Enhanced Winston logging
const loggers = {
    system: winston.createLogger({
        level: 'info',
        format: winston.format.combine(
            timezoneTimestamp(),
            winston.format.json()
        ),
        transports: [
            new winston.transports.Console({
                format: winston.format.combine(
                    winston.format.colorize(),
                    winston.format.printf(({ level, message, timestamp }) => {
                        return `${timestamp} [${level}]: ${message}`;
                    })
                )
            }),
            new winston.transports.File({ 
                filename: path.join(logDir, 'system.log'),
                maxsize: 10485760, // 10MB
                maxFiles: 5
            })
        ]
    }),
    security: winston.createLogger({
        level: 'info',
        format: winston.format.combine(
            timezoneTimestamp(),
            winston.format.json()
        ),
        transports: [
            new winston.transports.File({ 
                filename: path.join(logDir, 'security.log'),
                maxsize: 10485760,
                maxFiles: 10
            })
        ]
    }),
    audit: winston.createLogger({
        level: 'info',
        format: winston.format.combine(
            timezoneTimestamp(),
            winston.format.json()
        ),
        transports: [
            new winston.transports.File({ 
                filename: path.join(logDir, 'audit.log'),
                maxsize: 10485760,
                maxFiles: 10
            })
        ]
    }),
    access: winston.createLogger({
        level: 'info',
        format: winston.format.combine(
            timezoneTimestamp(),
            winston.format.json()
        ),
        transports: [
            new winston.transports.Console({
                format: winston.format.combine(
                    winston.format.colorize(),
                    winston.format.printf(info => {
                        return `üåê ${info.timestamp} - ${info.message}`;
                    })
                )
            }),
            new winston.transports.File({ 
                filename: path.join(logDir, 'access.log'),
                maxsize: 10485760,
                maxFiles: 10
            })
        ]
    })
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Format SQLite timestamp to local timezone
// SQLite CURRENT_TIMESTAMP returns UTC in format 'YYYY-MM-DD HH:MM:SS'
function formatSQLiteTimestamp(sqliteTimestamp, format) {
    if (!sqliteTimestamp) return null;
    try {
        // Use format from settings if not provided
        const displayFormat = format || SYSTEM_SETTINGS.date_format || 'MM/DD/YYYY, hh:mm:ss A';
        // Use timezone from settings
        const timezone = SYSTEM_SETTINGS.timezone || TIMEZONE;
        // Parse as UTC (SQLite CURRENT_TIMESTAMP is always UTC)
        // Then convert to configured timezone
        const m = moment.utc(sqliteTimestamp, 'YYYY-MM-DD HH:mm:ss').tz(timezone);
        return m.isValid() ? m.format(displayFormat) : null;
    } catch (error) {
        console.error('‚ùå Error formatting timestamp:', sqliteTimestamp, error);
        return null;
    }
}

// ============================================================================
// PAGE TEMPLATE SYSTEM
// ============================================================================

/**
 * Centralized Page Template Generator
 * This function creates a consistent layout for all pages with:
 * - Common styles (CSS variables, colors, themes)
 * - Sidebar navigation
 * - Header with timezone display
 * - Shared JavaScript utilities
 * 
 * Usage: getPageTemplate({ pageTitle, pageIcon, activeNav, contentBody, additionalCSS, additionalJS })
 */
function getPageTemplate(options) {
    const {
        pageTitle = 'Dashboard',
        pageIcon = 'fa-tachometer-alt',
        activeNav = 'dashboard',
        contentBody = '',
        additionalCSS = '',
        additionalJS = '',
        req
    } = options;

    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${pageTitle} | Enterprise Logging Platform</title>
        <link rel="icon" type="image/svg+xml" href="/favicon.svg">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@2.0.1/dist/chartjs-chart-matrix.min.js"></script>
        <style>
            :root {
                /* Light Theme Colors */
                --bg-primary: #ffffff;
                --bg-secondary: #f8fafc;
                --bg-tertiary: #f1f5f9;
                --text-primary: #1e293b;
                --text-secondary: #475569;
                --text-muted: #64748b;
                --border-color: #e2e8f0;
                
                /* Ocean Gradients */
                --gradient-ocean: linear-gradient(135deg, #0ea5e9 0%, #3b82f6 50%, #6366f1 100%);
                --gradient-deep-blue: linear-gradient(135deg, #1e40af 0%, #1e3a8a 50%, #312e81 100%);
                --gradient-sky: linear-gradient(135deg, #7dd3fc 0%, #38bdf8 50%, #0ea5e9 100%);
                
                /* Standard Colors - Using Ocean Gradient as Primary */
                --accent-primary: var(--gradient-ocean);
                --btn-primary: var(--gradient-ocean);
                --accent-secondary: #1d4ed8;
                --success-color: #10b981;
                --warning-color: #f59e0b;
                --error-color: #ef4444;
                --info-color: #3b82f6;
                --shadow-light: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
                --shadow-medium: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
                --shadow-glow: 0 0 20px rgba(59, 130, 246, 0.3);
                
                --sidebar-bg: var(--gradient-ocean);
            }

            /* Dark Theme */
            [data-theme="dark"] {
                --bg-primary: #1e293b;
                --bg-secondary: #334155;
                --bg-tertiary: #475569;
                --text-primary: #f1f5f9;
                --text-secondary: #cbd5e1;
                --text-muted: #94a3b8;
                --border-color: #475569;
                
                /* Ocean Gradients for Dark Theme */
                --gradient-ocean: linear-gradient(135deg, #1e40af 0%, #1e3a8a 50%, #312e81 100%);
                --gradient-deep-blue: linear-gradient(135deg, #0c1e3f 0%, #1e293b 50%, #334155 100%);
                --gradient-sky: linear-gradient(135deg, #1e40af 0%, #3730a3 50%, #4338ca 100%);
                
                /* Standard Colors - Using Ocean Gradient as Primary */
                --accent-primary: var(--gradient-ocean);
                --btn-primary: var(--gradient-ocean);
                --accent-secondary: #3b82f6;
                --shadow-light: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
                --shadow-medium: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
                --shadow-glow: 0 0 20px rgba(96, 165, 250, 0.4);
                --sidebar-bg: var(--gradient-deep-blue);
            }

            /* Auto Theme - follows system preference */
            @media (prefers-color-scheme: dark) {
                [data-theme="auto"] {
                    --bg-primary: #1e293b;
                    --bg-secondary: #334155;
                    --bg-tertiary: #475569;
                    --text-primary: #f1f5f9;
                    --text-secondary: #cbd5e1;
                    --text-muted: #94a3b8;
                    --border-color: #475569;
                    
                    /* Ocean Gradients for Auto Dark Mode */
                    --gradient-ocean: linear-gradient(135deg, #1e40af 0%, #1e3a8a 50%, #312e81 100%);
                    --gradient-deep-blue: linear-gradient(135deg, #0c1e3f 0%, #1e293b 50%, #334155 100%);
                    --gradient-sky: linear-gradient(135deg, #1e40af 0%, #3730a3 50%, #4338ca 100%);
                    
                    /* Standard Colors - Using Ocean Gradient as Primary */
                    --accent-primary: var(--gradient-ocean);
                    --btn-primary: var(--gradient-ocean);
                    --accent-secondary: #3b82f6;
                    --shadow-light: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
                    --shadow-medium: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
                    --shadow-glow: 0 0 20px rgba(96, 165, 250, 0.4);
                    --sidebar-bg: var(--gradient-deep-blue);
                }
            }

            /* Ocean Theme */
            [data-theme="ocean"] {
                --bg-primary: #1e293b;
                --bg-secondary: #334155;
                --bg-tertiary: #475569;
                --text-primary: #f1f5f9;
                --text-secondary: #cbd5e1;
                --text-muted: #94a3b8;
                --border-color: #475569;
                
                /* Ocean Gradients */
                --gradient-ocean: linear-gradient(135deg, #1e40af 0%, #1e3a8a 50%, #312e81 100%);
                --gradient-deep-blue: linear-gradient(135deg, #0c1e3f 0%, #1e293b 50%, #334155 100%);
                --gradient-sky: linear-gradient(135deg, #1e40af 0%, #3730a3 50%, #4338ca 100%);
                
                /* Standard Colors - Using Ocean Gradient as Primary */
                --accent-primary: var(--gradient-ocean);
                --btn-primary: var(--gradient-ocean);
                --accent-secondary: #3b82f6;
                --shadow-light: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
                --shadow-medium: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
                --shadow-glow: 0 0 20px rgba(96, 165, 250, 0.4);
                --sidebar-bg: var(--gradient-deep-blue);
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
                transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                background: var(--bg-secondary);
                color: var(--text-primary);
                line-height: 1.6;
            }

            .dashboard-container {
                display: flex;
                min-height: 100vh;
            }

            .sidebar {
                width: 280px;
                background: var(--sidebar-bg);
                padding: 2rem 0;
                display: flex;
                flex-direction: column;
                color: white;
                position: relative;
                overflow: hidden;
            }

            .sidebar::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
                pointer-events: none;
            }

            .sidebar-header {
                border-bottom: 1px solid rgba(255,255,255,0.2);
                margin-bottom: 2rem;
                position: relative;
                z-index: 1;
                overflow: hidden;
                background: var(--gradient-ocean);
                margin: -2rem -2rem 2rem -2rem;
                padding: 0 2rem;
                text-align: center;
                height: 94px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .sidebar-header::before {
                content: '';
                position: absolute;
                top: -50%;
                left: -50%;
                width: 200%;
                height: 200%;
                background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.15) 50%, transparent 70%);
                animation: headerShimmer 4s ease-in-out infinite;
                pointer-events: none;
            }

            .sidebar-header h2 {
                margin: 0;
                font-size: 1.1rem;
                font-weight: 700;
                position: relative;
                z-index: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 0.5rem;
                line-height: 1.2;
            }

            .sidebar-header p {
                margin: 0;
                opacity: 0.8;
                font-size: 0.875rem;
                position: relative;
                z-index: 1;
            }

            .sidebar-nav {
                list-style: none;
                padding: 0;
                margin: 0;
                flex: 1;
                position: relative;
                z-index: 1;
            }

            .sidebar-nav li {
                margin: 0;
            }

            .sidebar-nav a {
                display: flex;
                align-items: center;
                gap: 1rem;
                padding: 1rem 2rem;
                color: rgba(255,255,255,0.9);
                text-decoration: none;
                transition: all 0.3s ease;
                border-left: 3px solid transparent;
                position: relative;
            }

            .sidebar-nav a:hover {
                background: rgba(255,255,255,0.1);
                color: white;
                border-left-color: rgba(255,255,255,0.5);
            }

            .sidebar-nav a.active {
                background: rgba(255,255,255,0.15);
                color: white;
                border-left-color: white;
                font-weight: 600;
            }

            .sidebar-nav i {
                width: 20px;
                font-size: 1.1rem;
            }

            .sidebar-footer {
                padding: 2rem;
                border-top: 1px solid rgba(255,255,255,0.2);
                margin-top: auto;
                position: relative;
                z-index: 1;
            }

            .user-info {
                margin-bottom: 1rem;
                padding: 1rem;
                background: rgba(255,255,255,0.1);
                border-radius: 12px;
                text-align: center;
            }

            .user-info strong {
                display: block;
                margin-bottom: 0.25rem;
                color: white;
                font-size: 1.1rem;
            }

            .user-role {
                font-size: 0.85rem;
                color: #3b82f6;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                font-weight: 600;
            }

            .btn-logout {
                width: 100%;
                background: rgba(239, 68, 68, 0.2);
                border: 1px solid rgba(239, 68, 68, 0.4);
                color: white;
                padding: 0.75rem;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 0.9rem;
            }

            .btn-logout:hover {
                background: rgba(239, 68, 68, 0.3);
                border-color: rgba(239, 68, 68, 0.6);
            }

            .main-content {
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .content-header {
                background: var(--gradient-ocean);
                padding: 1.5rem 2rem;
                border-bottom: 1px solid var(--border-color);
                display: flex;
                justify-content: space-between;
                align-items: center;
                box-shadow: var(--shadow-light);
                position: relative;
                overflow: hidden;
            }

            .content-header::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
                animation: headerShimmer 4s ease-in-out infinite;
            }

            .content-header h1 {
                margin: 0;
                color: white;
                font-size: 1.75rem;
                font-weight: 700;
                position: relative;
                z-index: 1;
            }

            .header-actions {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                position: relative;
                z-index: 1;
            }

            .theme-toggle {
                background: var(--bg-primary);
                border: 2px solid var(--border-color);
                color: var(--text-primary);
                padding: 0.75rem;
                border-radius: 50%;
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 1.2rem;
                box-shadow: var(--shadow-light);
                display: flex;
                align-items: center;
                justify-content: center;
                width: 45px;
                height: 45px;
            }

            .theme-toggle:hover {
                transform: scale(1.1) rotate(15deg);
                box-shadow: var(--shadow-medium);
                border-color: var(--accent-primary);
            }

            .content-body {
                flex: 1;
                padding: 2rem;
                overflow-y: auto;
                background: var(--bg-secondary);
            }

            .timestamp {
                font-size: 0.875rem;
                color: var(--text-muted);
                font-weight: 500;
            }

            .status-indicator {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                font-size: 0.875rem;
                font-weight: 600;
            }

            .status-indicator.online {
                color: var(--success-color);
            }

            /* Universal Button Styles */
            .btn, button.btn, a.btn {
                display: inline-flex;
                align-items: center;
                gap: 0.25rem;
                padding: 0.375rem 0.75rem;
                background: var(--gradient-ocean);
                color: white;
                border: none;
                border-radius: 6px;
                font-size: 0.8rem;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
                text-decoration: none;
                box-shadow: var(--shadow-light);
            }

            .btn:hover, button.btn:hover, a.btn:hover {
                transform: translateY(-2px);
                box-shadow: var(--shadow-medium);
                filter: brightness(1.1);
            }

            .btn:active, button.btn:active, a.btn:active {
                transform: translateY(0);
            }

            .btn-secondary, button.btn-secondary, a.btn-secondary {
                background: var(--bg-tertiary);
                color: var(--text-primary);
                border: 1px solid var(--border-color);
            }

            .btn-secondary:hover, button.btn-secondary:hover, a.btn-secondary:hover {
                background: var(--bg-secondary);
                border-color: var(--accent-primary);
            }

            .btn-danger, button.btn-danger, a.btn-danger {
                background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
                color: white;
                border: none;
            }

            .btn-success, button.btn-success, a.btn-success {
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                color: white;
                border: none;
            }

            .btn-warning, button.btn-warning, a.btn-warning {
                background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
                color: white;
                border: none;
            }

            .btn:disabled, button.btn:disabled, a.btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                transform: none;
                pointer-events: none;
            }

            /* Card Component */
            .card {
                background: var(--bg-primary);
                border-radius: 12px;
                box-shadow: var(--shadow-light);
                border: 1px solid var(--border-color);
                margin-bottom: 1.5rem;
                overflow: hidden;
                transition: all 0.3s ease;
            }

            .card:hover {
                box-shadow: var(--shadow-medium);
                transform: translateY(-2px);
            }

            .card-header {
                padding: 1.5rem;
                border-bottom: 1px solid var(--border-color);
                display: flex;
                justify-content: space-between;
                align-items: center;
                background: var(--bg-secondary);
            }

            .card-header h3 {
                margin: 0;
                font-size: 1.25rem;
                color: var(--text-primary);
                font-weight: 600;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .card-header h3 i {
                color: var(--accent-primary);
            }

            .card-body {
                padding: 1.5rem;
            }

            .card-footer {
                padding: 1rem 1.5rem;
                border-top: 1px solid var(--border-color);
                background: var(--bg-secondary);
                display: flex;
                justify-content: flex-end;
                gap: 1rem;
            }

            /* Data Table Component */
            .data-table {
                width: 100%;
                border-collapse: collapse;
                background: var(--bg-primary);
                border-radius: 8px;
                overflow: hidden;
            }

            .data-table thead {
                background: var(--bg-secondary);
            }

            .data-table thead th {
                padding: 1rem;
                text-align: left;
                font-weight: 600;
                color: var(--text-primary);
                font-size: 0.875rem;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 2px solid var(--border-color);
            }

            .data-table tbody tr {
                border-bottom: 1px solid var(--border-color);
                transition: all 0.2s ease;
            }

            .data-table tbody tr:hover {
                background: var(--bg-secondary);
                transform: scale(1.01);
            }

            .data-table tbody tr:last-child {
                border-bottom: none;
            }

            .data-table tbody td {
                padding: 1rem;
                color: var(--text-secondary);
                font-size: 0.925rem;
                vertical-align: middle;
            }

            .data-table tbody td:first-child {
                font-weight: 500;
                color: var(--text-primary);
            }

            /* Status Badges */
            .status-badge {
                display: inline-flex;
                align-items: center;
                gap: 0.375rem;
                padding: 0.375rem 0.75rem;
                border-radius: 20px;
                font-size: 0.8rem;
                font-weight: 600;
                letter-spacing: 0.3px;
                text-transform: uppercase;
                transition: all 0.2s ease;
            }

            .status-badge.online {
                background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
                color: #065f46;
                border: 1px solid #6ee7b7;
            }

            [data-theme="dark"] .status-badge.online, [data-theme="ocean"] .status-badge.online {
                background: linear-gradient(135deg, #064e3b 0%, #065f46 100%);
                color: #6ee7b7;
                border: 1px solid #059669;
            }

            .status-badge.offline {
                background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
                color: #991b1b;
                border: 1px solid #fca5a5;
            }

            [data-theme="dark"] .status-badge.offline, [data-theme="ocean"] .status-badge.offline {
                background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
                color: #fca5a5;
                border: 1px solid #dc2626;
            }

            .status-badge.pending {
                background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
                color: #78350f;
                border: 1px solid #fbbf24;
            }

            [data-theme="dark"] .status-badge.pending, [data-theme="ocean"] .status-badge.pending {
                background: linear-gradient(135deg, #78350f 0%, #92400e 100%);
                color: #fbbf24;
                border: 1px solid #f59e0b;
            }

            /* Form Components */
            .form-group {
                margin-bottom: 1.5rem;
            }

            .form-group label {
                display: block;
                font-weight: 600;
                color: var(--text-primary);
                margin-bottom: 0.5rem;
                font-size: 0.95rem;
            }

            .form-group label i {
                margin-right: 0.5rem;
                color: var(--accent-primary);
            }

            .form-control {
                width: 100%;
                padding: 0.75rem;
                border: 2px solid var(--border-color);
                border-radius: 8px;
                background: var(--bg-primary);
                color: var(--text-primary);
                font-size: 1rem;
                transition: all 0.2s ease;
                font-family: inherit;
            }

            .form-control:focus {
                outline: none;
                border-color: var(--accent-primary);
                box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
                background: var(--bg-primary);
            }

            .form-control::placeholder {
                color: var(--text-muted);
                opacity: 0.7;
            }

            textarea.form-control {
                resize: vertical;
                min-height: 100px;
                font-family: inherit;
            }

            select.form-control {
                cursor: pointer;
                appearance: none;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2364748b' d='M10.293 3.293L6 7.586 1.707 3.293A1 1 0 00.293 4.707l5 5a1 1 0 001.414 0l5-5a1 1 0 10-1.414-1.414z'/%3E%3C/svg%3E");
                background-repeat: no-repeat;
                background-position: right 0.75rem center;
                padding-right: 2.5rem;
            }

            input[type="checkbox"] {
                width: 20px;
                height: 20px;
                cursor: pointer;
                accent-color: var(--accent-primary);
            }

            .form-group small {
                display: block;
                margin-top: 0.5rem;
                font-size: 0.875rem;
                color: var(--text-muted);
            }

            /* Stats Cards */
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 1.5rem;
                margin-bottom: 2rem;
            }

            .stat-card {
                background: var(--bg-primary);
                padding: 1.5rem;
                border-radius: 12px;
                border: 1px solid var(--border-color);
                box-shadow: var(--shadow-light);
                transition: all 0.3s ease;
            }

            .stat-card:hover {
                transform: translateY(-4px);
                box-shadow: var(--shadow-medium);
            }

            .stat-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1rem;
            }

            .stat-title {
                font-size: 0.875rem;
                color: var(--text-muted);
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .stat-icon {
                width: 40px;
                height: 40px;
                border-radius: 10px;
                background: var(--gradient-ocean);
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.2rem;
            }

            .stat-value {
                font-size: 2rem;
                font-weight: 700;
                color: var(--text-primary);
                margin-bottom: 0.5rem;
            }

            .stat-label {
                font-size: 0.875rem;
                color: var(--text-muted);
            }

            /* Utility Classes */
            .text-center {
                text-align: center;
            }

            .text-right {
                text-align: right;
            }

            .text-muted {
                color: var(--text-muted);
            }

            .text-primary {
                color: var(--text-primary);
            }

            .text-success {
                color: var(--success-color);
            }

            .text-warning {
                color: var(--warning-color);
            }

            .text-error {
                color: var(--error-color);
            }

            .mb-0 { margin-bottom: 0; }
            .mb-1 { margin-bottom: 0.5rem; }
            .mb-2 { margin-bottom: 1rem; }
            .mb-3 { margin-bottom: 1.5rem; }
            .mb-4 { margin-bottom: 2rem; }

            .mt-0 { margin-top: 0; }
            .mt-1 { margin-top: 0.5rem; }
            .mt-2 { margin-top: 1rem; }
            .mt-3 { margin-top: 1.5rem; }
            .mt-4 { margin-top: 2rem; }

            .flex {
                display: flex;
            }

            .flex-between {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .flex-center {
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .gap-1 { gap: 0.5rem; }
            .gap-2 { gap: 1rem; }
            .gap-3 { gap: 1.5rem; }
            .gap-4 { gap: 2rem; }

            ${additionalCSS}
        </style>
    </head>
    <body data-theme="auto">
        <div class="dashboard-container">
            <!-- Sidebar -->
            <nav class="sidebar">
                <div class="sidebar-header">
                    <h2><i class="fas fa-chart-network"></i> Enterprise Logging Platform</h2>
                </div>
                <ul class="sidebar-nav">
                    <li><a href="/dashboard" ${activeNav === 'dashboard' ? 'class="active"' : ''}><i class="fas fa-tachometer-alt"></i> Dashboard</a></li>
                    <li><a href="/logs" ${activeNav === 'logs' ? 'class="active"' : ''}><i class="fas fa-file-alt"></i> Logs</a></li>
                    <li><a href="/integrations" ${activeNav === 'integrations' ? 'class="active"' : ''}><i class="fas fa-plug"></i> Integrations</a></li>
                    <li><a href="/webhooks" ${activeNav === 'webhooks' ? 'class="active"' : ''}><i class="fas fa-link"></i> Webhooks</a></li>
                    <li><a href="/activity" ${activeNav === 'activity' ? 'class="active"' : ''}><i class="fas fa-history"></i> Activity</a></li>
                    <li><a href="/analytics-advanced" ${activeNav === 'analytics-advanced' ? 'class="active"' : ''}><i class="fas fa-chart-line"></i> Advanced Analytics</a></li>
                    <li><a href="/admin/ingestion" ${activeNav === 'ingestion' ? 'class="active"' : ''}><i class="fas fa-network-wired"></i> Multi-Protocol Ingestion</a></li>
                    <li><a href="/admin/tracing" ${activeNav === 'tracing' ? 'class="active"' : ''}><i class="fas fa-project-diagram"></i> Distributed Tracing</a></li>
                    <li><a href="/admin/dashboards" ${activeNav === 'dashboards' ? 'class="active"' : ''}><i class="fas fa-tachometer-alt"></i> Dashboard Builder</a></li>
                    <li><a href="/admin/security" ${activeNav === 'security' ? 'class="active"' : ''}><i class="fas fa-shield-alt"></i> Security & Audit</a></li>
                    <li><a href="/admin/users" ${activeNav === 'users' ? 'class="active"' : ''}><i class="fas fa-users"></i> Users</a></li>
                    <li><a href="/admin/settings" ${activeNav === 'settings' ? 'class="active"' : ''}><i class="fas fa-cog"></i> Settings</a></li>
                </ul>
                <div class="sidebar-footer">
                    <div class="user-info">
                        <strong><i class="fas fa-user-circle"></i> ${req.user.username}</strong>
                        <span class="user-role">${req.user.role}</span>
                    </div>
                    <button onclick="logout()" class="btn-logout">
                        <i class="fas fa-sign-out-alt"></i> Logout
                    </button>
                </div>
            </nav>

            <!-- Main Content -->
            <main class="main-content">
                <header class="content-header">
                    <h1><i class="${pageIcon}"></i> ${pageTitle}</h1>
                    <div class="header-actions">
                        <a href="/search" class="search-toggle" title="Advanced Search" style="display: inline-flex; align-items: center; justify-content: center; width: 40px; height: 40px; border-radius: 50%; background: var(--bg-secondary); color: var(--text-primary); text-decoration: none; margin-right: 8px; transition: all 0.3s ease; border: 1px solid var(--border-color);">
                            <i class="fas fa-search"></i>
                        </a>
                        <button onclick="toggleTheme()" class="theme-toggle" title="Auto Mode (Click for Light)">
                            <i id="theme-icon" class="fas fa-adjust"></i>
                        </button>
                        <span class="timestamp" id="current-time"></span>
                        <span class="status-indicator online">
                            <i class="fas fa-circle"></i> System Online
                        </span>
                    </div>
                </header>

                <div class="content-body">
                    ${contentBody}
                </div>
            </main>
        </div>

        <script>
            // ===== SHARED JAVASCRIPT UTILITIES - SINGLE SOURCE OF TRUTH =====
            
            // TIMEZONE CONFIGURATION (from server settings)
            const TIMEZONE = '${SYSTEM_SETTINGS.timezone || TIMEZONE}';
            const TIMEZONE_ABBR = '${moment().tz(SYSTEM_SETTINGS.timezone || TIMEZONE).format('z')}';
            const DEFAULT_THEME = '${SYSTEM_SETTINGS.default_theme || 'auto'}';
            
            // Format time in configured timezone
            function formatTime(date) {
                if (!date) return 'N/A';
                const d = new Date(date);
                return d.toLocaleString('en-US', {
                    timeZone: TIMEZONE,
                    weekday: 'short',
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true
                });
            }

            // Update current time display
            function updateTime() {
                const now = new Date();
                document.getElementById('current-time').textContent = formatTime(now);
            }

            // Theme Management
            let currentTheme = localStorage.getItem('theme') || DEFAULT_THEME;
            
            function toggleTheme() {
                const themes = ['auto', 'light', 'dark', 'ocean'];
                const currentIndex = themes.indexOf(currentTheme);
                currentTheme = themes[(currentIndex + 1) % themes.length];
                localStorage.setItem('theme', currentTheme);
                applyTheme();
            }

            function applyTheme() {
                const icon = document.getElementById('theme-icon');
                const body = document.body;
                
                if (currentTheme === 'light') {
                    body.setAttribute('data-theme', 'light');
                    icon.className = 'fas fa-sun';
                    document.querySelector('.theme-toggle').title = 'Light Mode (Click for Dark)';
                } else if (currentTheme === 'dark') {
                    body.setAttribute('data-theme', 'dark');
                    icon.className = 'fas fa-moon';
                    document.querySelector('.theme-toggle').title = 'Dark Mode (Click for Ocean)';
                } else if (currentTheme === 'ocean') {
                    body.setAttribute('data-theme', 'ocean');
                    icon.className = 'fas fa-water';
                    document.querySelector('.theme-toggle').title = 'Ocean Blue Mode (Click for Auto)';
                } else {
                    // Auto mode
                    const hour = new Date().getHours();
                    if (hour >= 6 && hour < 18) {
                        body.setAttribute('data-theme', 'light');
                    } else {
                        body.setAttribute('data-theme', 'ocean');
                    }
                    icon.className = 'fas fa-adjust';
                    document.querySelector('.theme-toggle').title = 'Auto Mode (Click for Light)';
                }
            }

            // Notification System
            function showNotification(message, type = 'info') {
                // You can enhance this with a toast library
                console.log(\`[\${type.toUpperCase()}] \${message}\`);
                alert(message);
            }

            // Logout Function
            async function logout() {
                try {
                    await fetch('/api/auth/logout', { method: 'POST' });
                    window.location.href = '/';
                } catch (error) {
                    console.error('Logout failed:', error);
                }
            }

            // Safe fetch utility to handle HTML responses gracefully
            async function safeFetch(url, options = {}) {
                try {
                    const response = await fetch(url, options);
                    
                    // Check if response is OK
                    if (!response.ok) {
                        throw new Error(\`HTTP \${response.status}: \${response.statusText}\`);
                    }
                    
                    // Check content type to ensure we're getting JSON
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        const text = await response.text();
                        console.warn(\`Expected JSON but got \${contentType}: \${text.substring(0, 200)}\`);
                        throw new Error('Server returned non-JSON response (likely HTML error page)');
                    }
                    
                    return await response.json();
                } catch (error) {
                    console.error(\`Fetch error for \${url}:\`, error);
                    throw error;
                }
            }

            // Initialize on page load
            document.addEventListener('DOMContentLoaded', function() {
                applyTheme();
                updateTime();
                setInterval(updateTime, 1000);
            });

            // ===== COMMON UTILITY FUNCTIONS =====
            // Toast Notifications
            function showToast(message, type = 'info') {
                const toast = document.createElement('div');
                const colors = {
                    success: 'var(--success-color)',
                    error: 'var(--error-color)',
                    warning: 'var(--warning-color)',
                    info: 'var(--accent-primary)'
                };
                const icons = {
                    success: 'check-circle',
                    error: 'exclamation-circle',
                    warning: 'exclamation-triangle',
                    info: 'info-circle'
                };
                
                toast.style.cssText = \`
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: \${colors[type] || colors.info};
                    color: white;
                    padding: 1rem 1.5rem;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                    z-index: 10001;
                    animation: slideInRight 0.3s ease;
                    display: flex;
                    align-items: center;
                    gap: 0.75rem;
                    min-width: 250px;
                    max-width: 400px;
                \`;
                
                toast.innerHTML = \`
                    <i class="fas fa-\${icons[type] || icons.info}"></i>
                    <span>\${message}</span>
                \`;
                
                document.body.appendChild(toast);
                
                setTimeout(() => {
                    toast.style.animation = 'slideOutRight 0.3s ease';
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            }

            // Format timestamp for display
            function formatTimestamp(timestamp, options = {}) {
                if (!timestamp) return 'N/A';
                try {
                    // Ensure UTC timestamp is treated as UTC
                    let dateStr = timestamp;
                    // If the timestamp doesn't have timezone info, append 'Z' for UTC
                    if (typeof dateStr === 'string' && !dateStr.includes('Z') && !dateStr.includes('+') && !dateStr.includes('T')) {
                        // Convert space-separated format to ISO format and add Z
                        dateStr = dateStr.replace(' ', 'T') + 'Z';
                    }
                    
                    const date = new Date(dateStr);
                    if (isNaN(date.getTime())) return timestamp; // Return original if invalid
                    
                    const opts = {
                        timeZone: TIMEZONE,
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: true,
                        ...options
                    };
                    
                    return date.toLocaleString('en-US', opts);
                } catch (error) {
                    console.error('Error formatting timestamp:', error);
                    return timestamp;
                }
            }

            // Format Bytes
            function formatBytes(bytes, decimals = 2) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }

            // Format Number with commas
            function formatNumber(num) {
                return num.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');
            }

            // Get Status Color
            function getStatusColor(status) {
                const statusMap = {
                    'online': '#10b981',
                    'success': '#10b981',
                    'active': '#10b981',
                    'offline': '#ef4444',
                    'error': '#ef4444',
                    'failed': '#ef4444',
                    'degraded': '#f59e0b',
                    'warning': '#f59e0b',
                    'pending': '#f59e0b',
                    'disabled': '#6b7280',
                    'inactive': '#6b7280',
                    'unknown': '#9ca3af'
                };
                return statusMap[status?.toLowerCase()] || '#9ca3af';
            }

            // Get Status Icon
            function getStatusIcon(status) {
                const iconMap = {
                    'online': 'check-circle',
                    'success': 'check-circle',
                    'active': 'check-circle',
                    'offline': 'times-circle',
                    'error': 'times-circle',
                    'failed': 'times-circle',
                    'degraded': 'exclamation-circle',
                    'warning': 'exclamation-triangle',
                    'pending': 'clock',
                    'disabled': 'ban',
                    'inactive': 'ban',
                    'unknown': 'question-circle'
                };
                return iconMap[status?.toLowerCase()] || 'question-circle';
            }

            // Time Ago Helper
            function timeAgo(timestamp) {
                const now = new Date();
                const time = new Date(timestamp);
                const diffMs = now - time;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);
                
                if (diffMins < 1) return 'Just now';
                if (diffMins < 60) return \`\${diffMins} minute\${diffMins !== 1 ? 's' : ''} ago\`;
                if (diffHours < 24) return \`\${diffHours} hour\${diffHours !== 1 ? 's' : ''} ago\`;
                if (diffDays < 7) return \`\${diffDays} day\${diffDays !== 1 ? 's' : ''} ago\`;
                return time.toLocaleDateString();
            }

            // Debounce Helper
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Copy to Clipboard
            async function copyToClipboard(text) {
                try {
                    await navigator.clipboard.writeText(text);
                    showToast('Copied to clipboard', 'success');
                } catch (err) {
                    console.error('Failed to copy:', err);
                    showToast('Failed to copy to clipboard', 'error');
                }
            }

            // Confirm Dialog
            function confirmDialog(message, callback) {
                if (confirm(message)) {
                    callback();
                }
            }

            // Loading Spinner
            function showLoading(elementId) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = \`
                        <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                            <i class="fas fa-spinner fa-spin" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                            <p>Loading...</p>
                        </div>
                    \`;
                }
            }

            // Error Display
            function showError(elementId, message) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = \`
                        <div style="text-align: center; padding: 3rem; color: var(--error-color);">
                            <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                            <p>\${message}</p>
                        </div>
                    \`;
                }
            }

            // Empty State
            function showEmptyState(elementId, message, icon = 'inbox') {
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerHTML = \`
                        <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                            <i class="fas fa-\${icon}" style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;"></i>
                            <p>\${message}</p>
                        </div>
                    \`;
                }
            }

            // Modal Helpers
            function openModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.add('active');
                    document.body.style.overflow = 'hidden';
                }
            }

            function closeModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.remove('active');
                    document.body.style.overflow = '';
                }
            }

            // Close modal on escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    document.querySelectorAll('.modal.active').forEach(modal => {
                        modal.classList.remove('active');
                        document.body.style.overflow = '';
                    });
                }
            });

            // Close modal on backdrop click
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('modal')) {
                    e.target.classList.remove('active');
                    document.body.style.overflow = '';
                }
            });

            // Animations
            const style = document.createElement('style');
            style.textContent = \`
                @keyframes slideInRight {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                @keyframes slideOutRight {
                    from {
                        transform: translateX(0);
                        opacity: 1;
                    }
                    to {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                }
            \`;
            document.head.appendChild(style);

            // ===== PAGE-SPECIFIC JAVASCRIPT =====
            ${additionalJS}
        </script>
    </body>
    </html>
    `;
}

// ============================================================================
// EXPRESS MIDDLEWARE
// ============================================================================

// Express middleware
app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// ============================================================================
// RATE LIMITING CONFIGURATION
// ============================================================================

// General API rate limiting - 300 requests per 15 minutes per IP (increased for normal dashboard usage)
const generalLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 300, // Limit each IP to 300 requests per windowMs (20 requests per minute)
    message: {
        error: 'Too many requests from this IP, please try again later.',
        limit: 300,
        window: '15 minutes'
    },
    standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
    legacyHeaders: false, // Disable the `X-RateLimit-*` headers
    handler: (req, res) => {
        loggers.security.warn('Rate limit exceeded', {
            ip: req.ip || req.connection.remoteAddress,
            url: req.url,
            userAgent: req.headers['user-agent']
        });
        res.status(429).json({
            error: 'Too many requests from this IP, please try again later.',
            limit: 300,
            window: '15 minutes'
        });
    }
});

// Log ingestion rate limiting - 1000 logs per 5 minutes per IP (more generous for ESP32/devices)
const logIngestionLimiter = rateLimit({
    windowMs: 5 * 60 * 1000, // 5 minutes
    max: 1000, // Limit each IP to 1000 log requests per windowMs
    message: {
        error: 'Log ingestion rate limit exceeded. Please reduce logging frequency.',
        limit: 1000,
        window: '5 minutes'
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
        loggers.security.warn('Log ingestion rate limit exceeded', {
            ip: req.ip || req.connection.remoteAddress,
            url: req.url,
            userAgent: req.headers['user-agent'],
            bodySize: req.headers['content-length']
        });
        res.status(429).json({
            error: 'Log ingestion rate limit exceeded. Please reduce logging frequency.',
            limit: 1000,
            window: '5 minutes'
        });
    }
});

// Authentication rate limiting - 5 attempts per 15 minutes per IP
const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // Limit each IP to 5 auth requests per windowMs
    message: {
        error: 'Too many authentication attempts, please try again later.',
        limit: 5,
        window: '15 minutes'
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
        loggers.security.warn('Authentication rate limit exceeded', {
            ip: req.ip || req.connection.remoteAddress,
            url: req.url,
            userAgent: req.headers['user-agent']
        });
        res.status(429).json({
            error: 'Too many authentication attempts, please try again later.',
            limit: 5,
            window: '15 minutes'
        });
    }
});

// Apply general rate limiting to all routes
app.use(generalLimiter);

// Session configuration
app.use(session({
    secret: config.auth.sessionSecret,
    resave: false,
    saveUninitialized: false,
    cookie: { 
        secure: false, // Set to true in production with HTTPS
        maxAge: 24 * 60 * 60 * 1000 // 24 hours
    }
}));

// Request logging middleware - logs to file and database
app.use((req, res, next) => {
    const startTime = Date.now();
    const logMessage = `${req.method} ${req.url} from ${req.ip || req.connection.remoteAddress}`;
    loggers.access.info(logMessage);
    
    // Track incoming request size with URL and user agent for connection type detection
    const requestSize = parseInt(req.headers['content-length']) || 0;
    const userAgent = req.headers['user-agent'] || '';
    if (metricsManager) {
        metricsManager.incrementRequests();
        metricsManager.incrementBytes(requestSize);
    }
    
    // Log HTTP requests to database
    logToDatabase(logMessage, 'info', 'http', 'logging-server');
    
    // Track response time and size for performance monitoring
    const originalSend = res.send;
    res.send = function(data) {
        // Track outgoing response size
        const responseSize = typeof data === 'string' ? Buffer.byteLength(data) : (data?.length || 0);
        if (metricsManager) {
            metricsManager.incrementBytes(responseSize);
        }
        originalSend.call(this, data);
    };
    
    res.on('finish', () => {
        const duration = Date.now() - startTime;
        if (req.path.startsWith('/api/') && duration > 1000) { // Track API requests over 1s
            trackResponseTime(req.path, duration);
        }
    });
    
    next();
});

// ============================================================================
// REAL-TIME ALERTING ENGINE - Phase 1 Feature #1
// ============================================================================

class AlertingEngine {
    constructor(database) {
        this.db = database;
        this.rules = [];
        this.alertHistory = [];
        this.isRunning = false;
        this.thresholds = new Map(); // For rate-based alerts
        this.notificationChannels = new Map(); // Configured notification channels
        this.escalationManager = new Map(); // Active escalations
        
        // Initialize notification services
        this.emailTransporter = null;
        this.twilioClient = null;
        this.pushoverClient = null;
        
        this.initializeNotificationServices();
    }

    async initialize() {
        loggers.system.info('üö® Initializing Enhanced Real-time Alerting Engine...');
        await this.loadAlertRulesFromDB();
        await this.loadNotificationChannelsFromDB();
        await this.initializeDefaultChannels();
        this.isRunning = true;
        loggers.system.info('‚úÖ Enhanced Alerting Engine initialized with database persistence');
    }

    initializeNotificationServices() {
        // Initialize Email (nodemailer)
        const emailConfig = process.env.EMAIL_SMTP_HOST ? {
            host: process.env.EMAIL_SMTP_HOST,
            port: parseInt(process.env.EMAIL_SMTP_PORT) || 587,
            secure: process.env.EMAIL_SMTP_SECURE === 'true',
            auth: {
                user: process.env.EMAIL_SMTP_USER,
                pass: process.env.EMAIL_SMTP_PASS
            }
        } : null;

        if (emailConfig) {
            this.emailTransporter = nodemailer.createTransporter(emailConfig);
        }

        // Initialize Twilio (SMS)
        if (process.env.TWILIO_ACCOUNT_SID && process.env.TWILIO_AUTH_TOKEN) {
            this.twilioClient = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);
        }

        // Initialize Pushover
        if (process.env.PUSHOVER_TOKEN && process.env.PUSHOVER_USER) {
            this.pushoverClient = new Pushover({
                token: process.env.PUSHOVER_TOKEN,
                user: process.env.PUSHOVER_USER
            });
        }
    }

    async loadAlertRulesFromDB() {
        return new Promise((resolve, reject) => {
            this.db.all('SELECT * FROM alert_rules WHERE enabled = 1', (err, rows) => {
                if (err) {
                    loggers.system.error('Failed to load alert rules from database:', err);
                    this.loadDefaultRules(); // Fallback to default rules
                    return resolve();
                }

                this.rules = rows.map(row => ({
                    id: row.id,
                    name: row.name,
                    description: row.description,
                    type: row.type,
                    condition: JSON.parse(row.condition),
                    channels: JSON.parse(row.channels),
                    severity: row.severity,
                    enabled: Boolean(row.enabled),
                    cooldown: row.cooldown,
                    escalationRules: row.escalation_rules ? JSON.parse(row.escalation_rules) : null,
                    lastTriggered: row.last_triggered,
                    triggerCount: row.trigger_count || 0
                }));

                if (this.rules.length === 0) {
                    loggers.system.info('No alert rules in database, creating default rules...');
                    this.createDefaultRules();
                } else {
                    loggers.system.info(`üìã Loaded ${this.rules.length} alert rules from database`);
                }
                resolve();
            });
        });
    }

    loadDefaultRules() {
        // Fallback default rules - same as before but enhanced with escalation
        this.rules = [
            {
                id: null, // Will be set by database
                name: 'Error Rate Spike',
                description: 'Detects when error rate exceeds threshold',
                type: 'rate',
                condition: {
                    severity: 'error',
                    count: 10,
                    timeWindow: 300
                },
                channels: ['default_email', 'slack'],
                severity: 'high',
                enabled: true,
                cooldown: 900,
                escalationRules: {
                    levels: [
                        { delay: 900, channels: ['email', 'sms'] },
                        { delay: 1800, channels: ['email', 'sms', 'pushover'] }
                    ]
                }
            },
            {
                id: null, // Will be set by database
                name: 'Security Event Detection',
                description: 'Detects security-related events and authentication failures',
                type: 'pattern',
                condition: {
                    categories: ['security', 'authentication'],
                    severity: ['error', 'critical'],
                    pattern: '(failed|unauthorized|denied|breach|attack|intrusion|suspicious)'
                },
                channels: ['default_email', 'slack'],
                severity: 'critical',
                enabled: true,
                cooldown: 300,
                escalationRules: {
                    levels: [
                        { delay: 300, channels: ['sms', 'pushover'] },
                        { delay: 600, channels: ['email', 'sms', 'pushover', 'slack'] }
                    ]
                }
            },
            {
                id: null, // Will be set by database
                name: 'Critical System Alert',
                description: 'Immediate notification for critical system events',
                type: 'pattern',
                condition: {
                    severity: 'critical',
                    pattern: '(down|offline|failure|crash|panic|emergency|outage)'
                },
                channels: ['default_email', 'sms', 'pushover'],
                severity: 'critical',
                enabled: true,
                cooldown: 0,
                escalationRules: {
                    levels: [
                        { delay: 0, channels: ['sms', 'pushover', 'email'] }
                    ]
                }
            },
            {
                id: null, // Will be set by database
                name: 'Device Connectivity Alert',
                description: 'Monitors device connectivity status',
                type: 'pattern',
                condition: {
                    event_type: 'device_status',
                    pattern: '(offline|disconnected|unreachable|timeout)'
                },
                channels: ['default_email'],
                severity: 'medium',
                enabled: true,
                cooldown: 1800
            }
        ];

        loggers.system.info(`üìã Loaded ${this.rules.length} default alert rules`);
    }

    async createDefaultRules() {
        this.loadDefaultRules();
        
        // Insert default rules into database (let SQLite auto-generate IDs)
        const insertRule = this.db.prepare(`
            INSERT INTO alert_rules (
                name, description, type, condition, channels, severity, 
                enabled, cooldown, escalation_rules, created_by, trigger_count
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);

        for (let i = 0; i < this.rules.length; i++) {
            const rule = this.rules[i];
            try {
                const info = insertRule.run([
                    rule.name,
                    rule.description || '',
                    rule.type,
                    JSON.stringify(rule.condition),
                    JSON.stringify(rule.channels),
                    rule.severity,
                    rule.enabled ? 1 : 0,
                    rule.cooldown,
                    rule.escalationRules ? JSON.stringify(rule.escalationRules) : null,
                    1, // created by admin user (id: 1)
                    0
                ]);
                
                // Update rule with database-assigned ID
                this.rules[i].id = info.lastID;
            } catch (err) {
                loggers.system.error(`Failed to insert default rule ${rule.name}:`, err);
            }
        }

        insertRule.finalize();
        loggers.system.info('‚úÖ Default alert rules created in database');
    }

    async loadNotificationChannelsFromDB() {
        return new Promise((resolve) => {
            this.db.all('SELECT * FROM notification_channels WHERE enabled = 1', (err, rows) => {
                if (err) {
                    loggers.system.error('Failed to load notification channels:', err);
                    return resolve();
                }

                rows.forEach(row => {
                    this.notificationChannels.set(row.id, {
                        id: row.id,
                        name: row.name,
                        type: row.type,
                        config: JSON.parse(row.config),
                        enabled: Boolean(row.enabled),
                        rateLimit: row.rate_limit,
                        lastUsed: row.last_used,
                        usageCount: row.usage_count || 0,
                        failureCount: row.failure_count || 0
                    });
                });

                loggers.system.info(`ÔøΩ Loaded ${this.notificationChannels.size} notification channels`);
                resolve();
            });
        });
    }

    async initializeDefaultChannels() {
        // Create default email channel if configured
        if (this.emailTransporter && !this.notificationChannels.has('default_email')) {
            await this.createNotificationChannel({
                id: 'default_email',
                name: 'Default Email',
                type: 'email',
                config: {
                    from: process.env.EMAIL_FROM || 'alerts@enterprise-logging.local',
                    to: process.env.EMAIL_ALERTS_TO || 'admin@enterprise-logging.local',
                    subject_prefix: '[ALERT]'
                }
            });
        }

        // Create default SMS channel if configured
        if (this.twilioClient && process.env.SMS_ALERTS_TO && !this.notificationChannels.has('default_sms')) {
            await this.createNotificationChannel({
                id: 'default_sms',
                name: 'Default SMS',
                type: 'sms',
                config: {
                    from: process.env.TWILIO_PHONE_NUMBER,
                    to: process.env.SMS_ALERTS_TO
                }
            });
        }
    }

    async createNotificationChannel(channelData) {
        const channel = {
            id: channelData.id || crypto.randomUUID(),
            name: channelData.name,
            type: channelData.type,
            config: channelData.config,
            enabled: channelData.enabled !== false,
            rateLimit: channelData.rateLimit || 0,
            lastUsed: null,
            usageCount: 0,
            failureCount: 0
        };

        this.notificationChannels.set(channel.id, channel);

        // Save to database
        this.db.run(`
            INSERT OR REPLACE INTO notification_channels 
            (id, name, type, config, enabled, rate_limit) 
            VALUES (?, ?, ?, ?, ?, ?)
        `, [
            channel.id,
            channel.name,
            channel.type,
            JSON.stringify(channel.config),
            channel.enabled ? 1 : 0,
            channel.rateLimit
        ]);

        return channel;
    }

    async processLogEvent(logEvent) {
        if (!this.isRunning) return;

        for (const rule of this.rules) {
            if (!rule.enabled) continue;

            try {
                const shouldTrigger = await this.evaluateRule(rule, logEvent);
                if (shouldTrigger) {
                    await this.triggerAlert(rule, logEvent);
                    
                    // Update rule statistics
                    await this.updateRuleStats(rule.id);
                }
            } catch (error) {
                loggers.system.error(`Alert rule evaluation error for ${rule.id}:`, error);
            }
        }
    }

    async updateRuleStats(ruleId) {
        this.db.run(`
            UPDATE alert_rules 
            SET last_triggered = CURRENT_TIMESTAMP, trigger_count = trigger_count + 1 
            WHERE id = ?
        `, [ruleId]);
    }

    async evaluateRule(rule, logEvent) {
        const { condition } = rule;

        // Check cooldown
        if (this.isInCooldown(rule.id, rule.cooldown)) {
            return false;
        }

        switch (rule.type) {
            case 'pattern':
                return this.evaluatePatternRule(condition, logEvent);
            case 'rate':
                return this.evaluateRateRule(condition, logEvent, rule.id);
            default:
                return false;
        }
    }

    evaluatePatternRule(condition, logEvent) {
        // Check severity
        if (condition.severity) {
            const severities = Array.isArray(condition.severity) ? condition.severity : [condition.severity];
            if (!severities.includes(logEvent.severity)) {
                return false;
            }
        }

        // Check categories
        if (condition.categories) {
            if (!condition.categories.includes(logEvent.category)) {
                return false;
            }
        }

        // Check event type
        if (condition.event_type && logEvent.event_type !== condition.event_type) {
            return false;
        }

        // Check pattern in message
        if (condition.pattern) {
            const regex = new RegExp(condition.pattern, 'i');
            return regex.test(logEvent.message || '');
        }

        return true;
    }

    evaluateRateRule(condition, logEvent, ruleId) {
        // Check if this log matches the condition
        if (condition.severity && logEvent.severity !== condition.severity) {
            return false;
        }

        if (condition.category && logEvent.category !== condition.category) {
            return false;
        }

        // Track rate
        const now = Date.now();
        const windowStart = now - (condition.timeWindow * 1000);
        
        if (!this.thresholds.has(ruleId)) {
            this.thresholds.set(ruleId, []);
        }

        const events = this.thresholds.get(ruleId);
        
        // Add current event
        events.push(now);
        
        // Remove old events outside window
        const filteredEvents = events.filter(timestamp => timestamp > windowStart);
        this.thresholds.set(ruleId, filteredEvents);

        // Check if threshold is exceeded
        return filteredEvents.length >= condition.count;
    }

    isInCooldown(ruleId, cooldownSeconds) {
        if (cooldownSeconds === 0) return false;

        const lastAlert = this.alertHistory.find(alert => 
            alert.ruleId === ruleId && 
            (Date.now() - alert.timestamp) < (cooldownSeconds * 1000)
        );
        
        return !!lastAlert;
    }

    async triggerAlert(rule, logEvent) {
        const alertId = crypto.randomUUID();
        const alert = {
            id: alertId,
            ruleId: rule.id,
            ruleName: rule.name,
            severity: rule.severity,
            timestamp: Date.now(),
            logEvent,
            channels: rule.channels,
            status: 'triggered'
        };

        // Record alert in memory (for compatibility)
        this.alertHistory.push(alert);
        if (this.alertHistory.length > 1000) {
            this.alertHistory = this.alertHistory.slice(-1000);
        }

        // Save alert to database
        await this.saveAlertToDatabase(alert);

        loggers.security.info(`üö® Alert triggered: ${rule.name} [${rule.severity.toUpperCase()}]`, {
            alertId: alertId,
            ruleId: rule.id,
            logEvent: {
                message: logEvent.message,
                severity: logEvent.severity,
                source: logEvent.source
            }
        });

        // Send notifications to all configured channels
        const notificationResults = {};
        for (const channelId of rule.channels) {
            try {
                const result = await this.sendNotification(channelId, alert);
                notificationResults[channelId] = result;
            } catch (error) {
                loggers.system.error(`Failed to send alert to channel ${channelId}:`, error);
                notificationResults[channelId] = { success: false, error: error.message };
            }
        }

        // Update alert with notification results
        await this.updateAlertNotificationResults(alertId, notificationResults);

        // Setup escalation if configured
        if (rule.escalationRules && rule.escalationRules.levels) {
            await this.scheduleEscalation(alertId, rule.escalationRules);
        }

        // Broadcast to WebSocket clients
        if (integrationManager && integrationManager.broadcastToWebSockets) {
            integrationManager.broadcastToWebSockets({
                type: 'alert_triggered',
                alert: {
                    id: alert.id,
                    ruleName: alert.ruleName,
                    severity: alert.severity,
                    timestamp: alert.timestamp,
                    message: logEvent.message,
                    logSeverity: logEvent.severity,
                    source: logEvent.source,
                    status: alert.status
                }
            });
        }

        return alert;
    }

    async saveAlertToDatabase(alert) {
        const { logEvent } = alert;
        
        this.db.run(`
            INSERT INTO alert_history (
                id, rule_id, rule_name, severity, status, message, 
                log_event_data, channels_notified, triggered_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `, [
            alert.id,
            alert.ruleId,
            alert.ruleName,
            alert.severity,
            alert.status,
            logEvent.message || 'No message',
            JSON.stringify(logEvent),
            JSON.stringify(alert.channels)
        ]);
    }

    async updateAlertNotificationResults(alertId, results) {
        this.db.run(`
            UPDATE alert_history 
            SET notification_results = ? 
            WHERE id = ?
        `, [JSON.stringify(results), alertId]);
    }

    async sendNotification(channelId, alert) {
        const channel = this.notificationChannels.get(channelId);
        if (!channel) {
            loggers.system.warn(`Unknown notification channel: ${channelId}`);
            return { success: false, error: 'Channel not found' };
        }

        if (!channel.enabled) {
            return { success: false, error: 'Channel disabled' };
        }

        // Check rate limiting
        if (channel.rateLimit > 0 && channel.lastUsed) {
            const timeSinceLastUse = Date.now() - new Date(channel.lastUsed).getTime();
            if (timeSinceLastUse < (channel.rateLimit * 1000)) {
                return { success: false, error: 'Rate limited' };
            }
        }

        const { logEvent, ruleName, severity } = alert;
        
        const message = {
            alertId: alert.id,
            title: `üö® ${ruleName}`,
            description: logEvent.message || 'No message',
            severity: severity,
            logSeverity: logEvent.severity || 'unknown',
            source: logEvent.source || 'unknown',
            device: logEvent.device_id || 'unknown',
            timestamp: formatTimestamp(logEvent.timestamp || Date.now()),
            alertTime: formatTimestamp(alert.timestamp)
        };

        try {
            let result;
            switch (channel.type) {
                case 'email':
                    result = await this.sendEmailNotification(channel, message);
                    break;
                case 'sms':
                    result = await this.sendSMSNotification(channel, message);
                    break;
                case 'slack':
                    result = await this.sendSlackNotification(channel, message);
                    break;
                case 'discord':
                    result = await this.sendDiscordNotification(channel, message);
                    break;
                case 'webhook':
                    result = await this.sendWebhookNotification(channel, message);
                    break;
                case 'pushover':
                    result = await this.sendPushoverNotification(channel, message);
                    break;
                case 'telegram':
                    result = await this.sendTelegramNotification(channel, message);
                    break;
                default:
                    throw new Error(`Unsupported channel type: ${channel.type}`);
            }

            // Update channel usage statistics
            await this.updateChannelUsage(channelId, true);
            
            return { success: true, ...result };
        } catch (error) {
            loggers.system.error(`Failed to send ${channel.type} notification:`, error);
            await this.updateChannelUsage(channelId, false);
            return { success: false, error: error.message };
        }
    }

    async updateChannelUsage(channelId, success) {
        const updateQuery = success 
            ? 'UPDATE notification_channels SET last_used = CURRENT_TIMESTAMP, usage_count = usage_count + 1 WHERE id = ?'
            : 'UPDATE notification_channels SET failure_count = failure_count + 1 WHERE id = ?';
        
        this.db.run(updateQuery, [channelId]);
        
        // Update in-memory channel
        const channel = this.notificationChannels.get(channelId);
        if (channel) {
            if (success) {
                channel.lastUsed = new Date().toISOString();
                channel.usageCount++;
            } else {
                channel.failureCount++;
            }
        }
    }

    async sendEmailNotification(channel, message) {
        if (!this.emailTransporter) {
            throw new Error('Email transporter not configured');
        }

        const { config } = channel;
        const subject = `${config.subject_prefix || '[ALERT]'} ${message.title} - ${message.severity.toUpperCase()}`;
        
        const htmlBody = `
            <h2>${message.title}</h2>
            <p><strong>Severity:</strong> <span style="color: ${this.getSeverityColor(message.severity)}">${message.severity.toUpperCase()}</span></p>
            <p><strong>Description:</strong> ${message.description}</p>
            <hr>
            <table style="border-collapse: collapse; width: 100%;">
                <tr><td style="border: 1px solid #ddd; padding: 8px;"><strong>Log Severity:</strong></td><td style="border: 1px solid #ddd; padding: 8px;">${message.logSeverity}</td></tr>
                <tr><td style="border: 1px solid #ddd; padding: 8px;"><strong>Source:</strong></td><td style="border: 1px solid #ddd; padding: 8px;">${message.source}</td></tr>
                <tr><td style="border: 1px solid #ddd; padding: 8px;"><strong>Device:</strong></td><td style="border: 1px solid #ddd; padding: 8px;">${message.device}</td></tr>
                <tr><td style="border: 1px solid #ddd; padding: 8px;"><strong>Timestamp:</strong></td><td style="border: 1px solid #ddd; padding: 8px;">${message.timestamp}</td></tr>
                <tr><td style="border: 1px solid #ddd; padding: 8px;"><strong>Alert ID:</strong></td><td style="border: 1px solid #ddd; padding: 8px;">${message.alertId}</td></tr>
            </table>
        `;

        const textBody = `
${message.title}

Severity: ${message.severity.toUpperCase()}
Description: ${message.description}

Details:
- Log Severity: ${message.logSeverity}
- Source: ${message.source}
- Device: ${message.device}
- Timestamp: ${message.timestamp}
- Alert ID: ${message.alertId}
        `.trim();

        const mailOptions = {
            from: config.from,
            to: config.to,
            subject: subject,
            text: textBody,
            html: htmlBody
        };

        const info = await this.emailTransporter.sendMail(mailOptions);
        return { messageId: info.messageId };
    }

    async sendSMSNotification(channel, message) {
        if (!this.twilioClient) {
            throw new Error('Twilio client not configured');
        }

        const { config } = channel;
        const smsBody = `üö® ${message.title}\n\nSeverity: ${message.severity.toUpperCase()}\n${message.description}\n\nSource: ${message.source}\nTime: ${message.timestamp}`;

        const result = await this.twilioClient.messages.create({
            body: smsBody,
            from: config.from,
            to: config.to
        });

        return { messageId: result.sid };
    }

    async sendPushoverNotification(channel, message) {
        if (!this.pushoverClient) {
            throw new Error('Pushover client not configured');
        }

        const { config } = channel;
        const priority = this.getPushoverPriority(message.severity);
        
        const pushMessage = {
            message: `${message.description}\n\nSource: ${message.source}\nTime: ${message.timestamp}`,
            title: message.title,
            priority: priority,
            sound: config.sound || 'pushover'
        };

        if (priority === 2) { // Emergency priority
            pushMessage.retry = 300; // Retry every 5 minutes
            pushMessage.expire = 3600; // Expire after 1 hour
        }

        const result = await new Promise((resolve, reject) => {
            this.pushoverClient.send(pushMessage, (err, result) => {
                if (err) reject(err);
                else resolve(result);
            });
        });

        return { messageId: result };
    }

    getPushoverPriority(severity) {
        const priorities = {
            low: -1,
            medium: 0,
            high: 1,
            critical: 2
        };
        return priorities[severity] || 0;
    }

    async sendSlackNotification(channel, message) {
        const { config } = channel;
        if (!config.webhook_url) {
            throw new Error('Slack webhook URL not configured');
        }

        const payload = {
            text: message.title,
            attachments: [{
                color: this.getSeverityColor(message.severity),
                title: message.title,
                text: message.description,
                fields: [
                    { title: 'Alert Severity', value: message.severity.toUpperCase(), short: true },
                    { title: 'Log Severity', value: message.logSeverity, short: true },
                    { title: 'Source', value: message.source, short: true },
                    { title: 'Device', value: message.device, short: true },
                    { title: 'Timestamp', value: message.timestamp, short: false },
                    { title: 'Alert ID', value: message.alertId, short: false }
                ],
                ts: Math.floor(Date.now() / 1000)
            }]
        };

        const response = await axios.post(config.webhook_url, payload, {
            headers: { 'Content-Type': 'application/json' }
        });

        return { status: response.status };
    }

    async sendDiscordNotification(channel, message) {
        const { config } = channel;
        if (!config.webhook_url) {
            throw new Error('Discord webhook URL not configured');
        }

        const embed = {
            title: message.title,
            description: message.description,
            color: parseInt(this.getSeverityColor(message.severity).replace('#', ''), 16),
            fields: [
                { name: 'Alert Severity', value: message.severity.toUpperCase(), inline: true },
                { name: 'Log Severity', value: message.logSeverity, inline: true },
                { name: 'Source', value: message.source, inline: true },
                { name: 'Device', value: message.device, inline: true },
                { name: 'Timestamp', value: message.timestamp, inline: false },
                { name: 'Alert ID', value: message.alertId, inline: false }
            ],
            timestamp: new Date().toISOString(),
            footer: {
                text: 'Enterprise Logging Platform'
            }
        };

        const response = await axios.post(config.webhook_url, {
            embeds: [embed]
        }, {
            headers: { 'Content-Type': 'application/json' }
        });

        return { status: response.status };
    }

    async sendWebhookNotification(channel, message) {
        const { config } = channel;
        if (!config.url) {
            throw new Error('Webhook URL not configured');
        }

        const payload = {
            type: 'alert',
            alert_id: message.alertId,
            timestamp: new Date().toISOString(),
            data: {
                title: message.title,
                description: message.description,
                severity: message.severity,
                log_severity: message.logSeverity,
                source: message.source,
                device: message.device,
                log_timestamp: message.timestamp
            }
        };

        const headers = {
            'Content-Type': 'application/json',
            'User-Agent': 'Enterprise-Logging-Platform/2.3.0',
            'X-Alert-Severity': message.severity,
            'X-Alert-ID': message.alertId
        };

        // Add custom headers if configured
        if (config.headers) {
            Object.assign(headers, config.headers);
        }

        const response = await axios.post(config.url, payload, {
            headers,
            timeout: config.timeout || 10000
        });

        return { status: response.status, responseData: response.data };
    }

    async sendTelegramNotification(channel, message) {
        const { config } = channel;
        if (!config.bot_token || !config.chat_id) {
            throw new Error('Telegram bot token and chat ID not configured');
        }

        const telegramMessage = `
üö® *${message.title.replace(/[_*[\]()~`>#+=|{}.!-]/g, '\\$&')}*

*Severity:* ${message.severity.toUpperCase()}
*Description:* ${message.description.replace(/[_*[\]()~`>#+=|{}.!-]/g, '\\$&')}

*Details:*
‚Ä¢ Log Severity: ${message.logSeverity}
‚Ä¢ Source: ${message.source}
‚Ä¢ Device: ${message.device}
‚Ä¢ Timestamp: ${message.timestamp}
‚Ä¢ Alert ID: \`${message.alertId}\`
        `.trim();

        const url = `https://api.telegram.org/bot${config.bot_token}/sendMessage`;
        
        const response = await axios.post(url, {
            chat_id: config.chat_id,
            text: telegramMessage,
            parse_mode: 'MarkdownV2'
        });

        return { messageId: response.data.result.message_id };
    }

    async scheduleEscalation(alertId, escalationRules) {
        const { levels } = escalationRules;
        
        for (let i = 0; i < levels.length; i++) {
            const level = levels[i];
            const escalationId = crypto.randomUUID();
            const escalationTime = new Date(Date.now() + (level.delay * 1000));
            
            // Save escalation to database
            this.db.run(`
                INSERT INTO alert_escalations 
                (id, alert_id, level, channels, next_escalation_at) 
                VALUES (?, ?, ?, ?, ?)
            `, [
                escalationId,
                alertId,
                i + 1,
                JSON.stringify(level.channels),
                escalationTime.toISOString()
            ]);

            // Schedule escalation
            setTimeout(async () => {
                await this.executeEscalation(escalationId, alertId, i + 1, level.channels);
            }, level.delay * 1000);
        }
    }

    async executeEscalation(escalationId, alertId, level, channels) {
        // Check if alert is still active (not resolved)
        const alert = await this.getAlertById(alertId);
        if (!alert || alert.status === 'resolved') {
            loggers.system.info(`Skipping escalation for resolved alert ${alertId}`);
            return;
        }

        loggers.system.info(`üî• Executing escalation level ${level} for alert ${alertId}`);

        // Send escalation notifications
        const notificationResults = {};
        for (const channelId of channels) {
            try {
                const escalationMessage = {
                    ...alert,
                    title: `üî• ESCALATION Level ${level}: ${alert.ruleName}`,
                    description: `Alert has not been resolved and is being escalated.\n\nOriginal: ${alert.logEvent.message}`
                };
                
                const result = await this.sendNotification(channelId, escalationMessage);
                notificationResults[channelId] = result;
            } catch (error) {
                loggers.system.error(`Failed escalation notification to ${channelId}:`, error);
                notificationResults[channelId] = { success: false, error: error.message };
            }
        }

        // Update escalation status
        this.db.run(`
            UPDATE alert_escalations 
            SET notification_sent = 1, triggered_at = CURRENT_TIMESTAMP 
            WHERE id = ?
        `, [escalationId]);

        // Update alert escalation level
        this.db.run(`
            UPDATE alert_history 
            SET escalated_at = CURRENT_TIMESTAMP, escalation_level = ? 
            WHERE id = ?
        `, [level, alertId]);
    }

    async getAlertById(alertId) {
        return new Promise((resolve, reject) => {
            this.db.get('SELECT * FROM alert_history WHERE id = ?', [alertId], (err, row) => {
                if (err) return reject(err);
                
                if (row) {
                    resolve({
                        id: row.id,
                        ruleId: row.rule_id,
                        ruleName: row.rule_name,
                        severity: row.severity,
                        status: row.status,
                        message: row.message,
                        logEvent: JSON.parse(row.log_event_data),
                        timestamp: new Date(row.triggered_at).getTime()
                    });
                } else {
                    resolve(null);
                }
            });
        });
    }

    async resolveAlert(alertId, resolvedBy = 'system') {
        this.db.run(`
            UPDATE alert_history 
            SET status = 'resolved', resolved_at = CURRENT_TIMESTAMP 
            WHERE id = ? AND status != 'resolved'
        `, [alertId]);

        loggers.system.info(`‚úÖ Alert ${alertId} resolved by ${resolvedBy}`);
    }

    getSeverityColor(severity) {
        const colors = {
            critical: '#dc2626', // red-600
            high: '#ef4444',     // red-500
            error: '#ef4444',    // red-500 (compatibility)
            medium: '#f59e0b',   // amber-500
            warning: '#f59e0b',  // amber-500 (compatibility)
            low: '#3b82f6',      // blue-500
            info: '#3b82f6',     // blue-500 (compatibility)
            debug: '#6b7280'     // gray-500
        };
        return colors[severity?.toLowerCase()] || colors.info;
    }

    async getAlertHistory(limit = 50, filters = {}) {
        return new Promise((resolve, reject) => {
            let query = 'SELECT * FROM alert_history';
            const params = [];
            const conditions = [];

            if (filters.severity) {
                conditions.push('severity = ?');
                params.push(filters.severity);
            }

            if (filters.status) {
                conditions.push('status = ?');
                params.push(filters.status);
            }

            if (filters.ruleId) {
                conditions.push('rule_id = ?');
                params.push(filters.ruleId);
            }

            if (conditions.length > 0) {
                query += ' WHERE ' + conditions.join(' AND ');
            }

            query += ' ORDER BY triggered_at DESC LIMIT ?';
            params.push(limit);

            this.db.all(query, params, (err, rows) => {
                if (err) return reject(err);

                const alerts = rows.map(row => ({
                    id: row.id,
                    ruleId: row.rule_id,
                    ruleName: row.rule_name,
                    severity: row.severity,
                    status: row.status,
                    message: row.message,
                    timestamp: new Date(row.triggered_at).getTime(),
                    logEvent: JSON.parse(row.log_event_data),
                    channelsNotified: JSON.parse(row.channels_notified || '[]'),
                    notificationResults: row.notification_results ? JSON.parse(row.notification_results) : {},
                    escalationLevel: row.escalation_level || 0,
                    resolvedAt: row.resolved_at ? new Date(row.resolved_at).getTime() : null
                }));

                resolve(alerts);
            });
        });
    }

    async getAlertStats() {
        return new Promise((resolve, reject) => {
            const queries = [
                { name: 'total', sql: 'SELECT COUNT(*) as count FROM alert_history' },
                { name: 'today', sql: "SELECT COUNT(*) as count FROM alert_history WHERE DATE(triggered_at) = DATE('now')" },
                { name: 'active', sql: "SELECT COUNT(*) as count FROM alert_history WHERE status = 'triggered'" },
                { name: 'resolved', sql: "SELECT COUNT(*) as count FROM alert_history WHERE status = 'resolved'" },
                { name: 'by_severity', sql: 'SELECT severity, COUNT(*) as count FROM alert_history GROUP BY severity' }
            ];

            const stats = {};
            let completed = 0;

            queries.forEach(({ name, sql }) => {
                this.db.all(sql, (err, rows) => {
                    if (err) return reject(err);

                    if (name === 'by_severity') {
                        stats[name] = rows.reduce((acc, row) => {
                            acc[row.severity] = row.count;
                            return acc;
                        }, {});
                    } else {
                        stats[name] = rows[0].count;
                    }

                    completed++;
                    if (completed === queries.length) {
                        resolve(stats);
                    }
                });
            });
        });
    }
    
    getRules() {
        return this.rules || [];
    }
    
    getRule(ruleId) {
        return this.rules.find(rule => rule.id === ruleId);
    }
    
    async updateRule(ruleId, updates) {
        const rule = this.getRule(ruleId);
        if (!rule) return null;

        // Update in memory
        Object.assign(rule, updates);
        rule.updated_at = new Date().toISOString();

        // Update in database
        this.db.run(`
            UPDATE alert_rules 
            SET name = ?, description = ?, type = ?, condition = ?, channels = ?, 
                severity = ?, enabled = ?, cooldown = ?, escalation_rules = ?, updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        `, [
            rule.name,
            rule.description || '',
            rule.type,
            JSON.stringify(rule.condition),
            JSON.stringify(rule.channels),
            rule.severity,
            rule.enabled ? 1 : 0,
            rule.cooldown,
            rule.escalationRules ? JSON.stringify(rule.escalationRules) : null,
            ruleId
        ]);

        return rule;
    }
    
    async addRule(ruleData, createdBy = 1) {
        const newRule = {
            id: null, // Will be set by database
            name: ruleData.name,
            description: ruleData.description || '',
            type: ruleData.type,
            condition: ruleData.condition,
            channels: ruleData.channels || [],
            severity: ruleData.severity || 'medium',
            enabled: ruleData.enabled !== false,
            cooldown: ruleData.cooldown || 300,
            escalationRules: ruleData.escalationRules || null,
            triggerCount: 0
        };

        // Add to memory
        this.rules.push(newRule);

        // Save to database (let SQLite auto-generate the ID)
        this.db.run(`
            INSERT INTO alert_rules (
                name, description, type, condition, channels, severity, 
                enabled, cooldown, escalation_rules, created_by, trigger_count
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
            newRule.name,
            newRule.description,
            newRule.type,
            JSON.stringify(newRule.condition),
            JSON.stringify(newRule.channels),
            newRule.severity,
            newRule.enabled ? 1 : 0,
            newRule.cooldown,
            newRule.escalationRules ? JSON.stringify(newRule.escalationRules) : null,
            createdBy,
            0
        ], function(err) {
            if (!err) {
                // Update the rule with the database-assigned ID
                newRule.id = this.lastID;
            }
        });

        return newRule;
    }
    
    async removeRule(ruleId) {
        const index = this.rules.findIndex(rule => rule.id === ruleId);
        if (index === -1) return null;

        const rule = this.rules.splice(index, 1)[0];

        // Remove from database
        this.db.run('DELETE FROM alert_rules WHERE id = ?', [ruleId]);

        return rule;
    }

    async getNotificationChannels() {
        return Array.from(this.notificationChannels.values());
    }

    async updateNotificationChannel(channelId, updates) {
        const channel = this.notificationChannels.get(channelId);
        if (!channel) return null;

        Object.assign(channel, updates);

        // Update in database
        this.db.run(`
            UPDATE notification_channels 
            SET name = ?, config = ?, enabled = ?, rate_limit = ?, updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        `, [
            channel.name,
            JSON.stringify(channel.config),
            channel.enabled ? 1 : 0,
            channel.rateLimit,
            channelId
        ]);

        return channel;
    }

    async removeNotificationChannel(channelId) {
        const channel = this.notificationChannels.get(channelId);
        if (!channel) return null;

        this.notificationChannels.delete(channelId);

        // Remove from database
        this.db.run('DELETE FROM notification_channels WHERE id = ?', [channelId]);

        return channel;
    }
}

// ============================================================================
// ADVANCED SEARCH & QUERY LANGUAGE ENGINE
// ============================================================================

class AdvancedSearchEngine {
    constructor(database) {
        this.db = database;
        this.fuseOptions = {
            keys: ['message', 'source', 'device_id', 'category'],
            threshold: 0.4,
            includeScore: true,
            includeMatches: true
        };
        this.queryCache = new Map();
        this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
    }

    // Parse Elasticsearch-style DSL query
    parseQuery(queryDSL) {
        if (typeof queryDSL === 'string') {
            return this.parseSimpleQuery(queryDSL);
        }

        const parsed = {
            filters: [],
            textSearch: null,
            fuzzy: false,
            aggregations: {},
            sort: [],
            size: 100,
            from: 0
        };

        // Parse query structure
        if (queryDSL.query) {
            this.parseQueryClause(queryDSL.query, parsed);
        }

        // Parse aggregations
        if (queryDSL.aggs || queryDSL.aggregations) {
            parsed.aggregations = queryDSL.aggs || queryDSL.aggregations;
        }

        // Parse sort
        if (queryDSL.sort) {
            parsed.sort = Array.isArray(queryDSL.sort) ? queryDSL.sort : [queryDSL.sort];
        }

        // Parse pagination
        if (queryDSL.size !== undefined) parsed.size = queryDSL.size;
        if (queryDSL.from !== undefined) parsed.from = queryDSL.from;

        return parsed;
    }

    parseQueryClause(query, parsed) {
        if (query.bool) {
            this.parseBoolQuery(query.bool, parsed);
        } else if (query.match) {
            this.parseMatchQuery(query.match, parsed);
        } else if (query.term) {
            this.parseTermQuery(query.term, parsed);
        } else if (query.range) {
            this.parseRangeQuery(query.range, parsed);
        } else if (query.wildcard) {
            this.parseWildcardQuery(query.wildcard, parsed);
        } else if (query.fuzzy) {
            this.parseFuzzyQuery(query.fuzzy, parsed);
        } else if (query.query_string) {
            this.parseQueryStringQuery(query.query_string, parsed);
        }
    }

    parseBoolQuery(boolQuery, parsed) {
        const clauses = ['must', 'should', 'must_not', 'filter'];
        
        clauses.forEach(clause => {
            if (boolQuery[clause]) {
                const queries = Array.isArray(boolQuery[clause]) ? boolQuery[clause] : [boolQuery[clause]];
                queries.forEach(subQuery => {
                    this.parseQueryClause(subQuery, parsed);
                });
            }
        });
    }

    parseMatchQuery(matchQuery, parsed) {
        Object.entries(matchQuery).forEach(([field, value]) => {
            if (typeof value === 'object') {
                parsed.textSearch = {
                    field: field,
                    query: value.query,
                    operator: value.operator || 'or',
                    fuzziness: value.fuzziness || 0
                };
                if (value.fuzziness) parsed.fuzzy = true;
            } else {
                parsed.textSearch = { field: field, query: value };
            }
        });
    }

    parseTermQuery(termQuery, parsed) {
        Object.entries(termQuery).forEach(([field, value]) => {
            parsed.filters.push({
                type: 'term',
                field: field,
                value: value
            });
        });
    }

    parseRangeQuery(rangeQuery, parsed) {
        Object.entries(rangeQuery).forEach(([field, ranges]) => {
            parsed.filters.push({
                type: 'range',
                field: field,
                ...ranges
            });
        });
    }

    parseWildcardQuery(wildcardQuery, parsed) {
        Object.entries(wildcardQuery).forEach(([field, pattern]) => {
            parsed.filters.push({
                type: 'wildcard',
                field: field,
                pattern: pattern
            });
        });
    }

    parseFuzzyQuery(fuzzyQuery, parsed) {
        Object.entries(fuzzyQuery).forEach(([field, config]) => {
            parsed.textSearch = {
                field: field,
                query: typeof config === 'string' ? config : config.value,
                fuzziness: typeof config === 'object' ? config.fuzziness : 2
            };
            parsed.fuzzy = true;
        });
    }

    parseQueryStringQuery(queryStringQuery, parsed) {
        const { query, default_field, fields } = queryStringQuery;
        parsed.textSearch = {
            field: default_field || (fields && fields[0]) || 'message',
            query: query,
            queryString: true
        };
    }

    parseSimpleQuery(queryString) {
        const parsed = {
            filters: [],
            textSearch: null,
            fuzzy: false,
            aggregations: {},
            sort: [{ timestamp: 'desc' }],
            size: 100,
            from: 0
        };

        // Parse simple query string like "severity:error AND message:failed"
        const tokens = this.tokenizeQuery(queryString);
        
        for (const token of tokens) {
            if (token.includes(':')) {
                const [field, value] = token.split(':', 2);
                
                if (field === '_all' || field === 'q') {
                    parsed.textSearch = { field: 'message', query: value };
                } else if (this.isDateField(field)) {
                    parsed.filters.push({
                        type: 'range',
                        field: field,
                        gte: this.parseDate(value)
                    });
                } else {
                    parsed.filters.push({
                        type: 'term',
                        field: field,
                        value: value.replace(/['"]/g, '')
                    });
                }
            } else if (!['AND', 'OR', 'NOT'].includes(token.toUpperCase())) {
                // Full-text search
                parsed.textSearch = { field: 'message', query: token };
            }
        }

        return parsed;
    }

    tokenizeQuery(query) {
        // Simple tokenizer - can be enhanced for complex queries
        return query.match(/(?:[^\s"']+|"[^"]*"|'[^']*')+/g) || [];
    }

    isDateField(field) {
        return ['timestamp', 'created_at', 'updated_at', 'date'].includes(field);
    }

    parseDate(dateStr) {
        // Parse various date formats
        const date = new Date(dateStr);
        return date.toISOString();
    }

    async executeSearch(queryDSL, options = {}) {
        try {
            const cacheKey = JSON.stringify(queryDSL);
            const cached = this.queryCache.get(cacheKey);
            
            if (cached && (Date.now() - cached.timestamp) < this.cacheTimeout) {
                return cached.result;
            }

            const parsed = this.parseQuery(queryDSL);
            const sqlResult = await this.buildSQLQuery(parsed);
            
            let results = await this.executeSQLQuery(sqlResult.sql, sqlResult.params);
            
            // Apply fuzzy search if needed
            if (parsed.fuzzy && parsed.textSearch && results.length > 0) {
                results = this.applyFuzzySearch(results, parsed.textSearch);
            }

            // Execute aggregations if specified
            let aggregations = {};
            if (Object.keys(parsed.aggregations).length > 0) {
                aggregations = await this.executeAggregations(parsed.aggregations, parsed);
            }

            const result = {
                hits: {
                    total: results.length,
                    hits: results.slice(parsed.from, parsed.from + parsed.size)
                },
                aggregations: aggregations,
                took: Date.now() - (cached?.timestamp || Date.now())
            };

            // Cache result
            this.queryCache.set(cacheKey, {
                result: result,
                timestamp: Date.now()
            });

            // Cleanup old cache entries
            this.cleanupCache();

            return result;
        } catch (error) {
            loggers.system.error('Advanced search execution error:', error);
            throw error;
        }
    }

    buildSQLQuery(parsed) {
        let sql = 'SELECT * FROM log_events WHERE 1=1';
        const params = [];

        // Add filters
        for (const filter of parsed.filters) {
            const condition = this.buildFilterCondition(filter, params);
            if (condition) {
                sql += ` AND ${condition}`;
            }
        }

        // Add text search
        if (parsed.textSearch && !parsed.fuzzy) {
            const textCondition = this.buildTextSearchCondition(parsed.textSearch, params);
            if (textCondition) {
                sql += ` AND ${textCondition}`;
            }
        }

        // Add sorting
        if (parsed.sort.length > 0) {
            sql += ' ORDER BY ' + parsed.sort.map(sort => {
                if (typeof sort === 'string') {
                    return `${sort} DESC`;
                } else {
                    const field = Object.keys(sort)[0];
                    const direction = sort[field].toUpperCase();
                    return `${field} ${direction}`;
                }
            }).join(', ');
        }

        // Add limit
        sql += ` LIMIT ${parsed.size + parsed.from}`;

        return { sql, params };
    }

    buildFilterCondition(filter, params) {
        switch (filter.type) {
            case 'term':
                params.push(filter.value);
                return `${filter.field} = ?`;
            
            case 'range':
                const conditions = [];
                if (filter.gte !== undefined) {
                    params.push(filter.gte);
                    conditions.push(`${filter.field} >= ?`);
                }
                if (filter.lte !== undefined) {
                    params.push(filter.lte);
                    conditions.push(`${filter.field} <= ?`);
                }
                if (filter.gt !== undefined) {
                    params.push(filter.gt);
                    conditions.push(`${filter.field} > ?`);
                }
                if (filter.lt !== undefined) {
                    params.push(filter.lt);
                    conditions.push(`${filter.field} < ?`);
                }
                return conditions.join(' AND ');
            
            case 'wildcard':
                params.push(filter.pattern.replace(/\*/g, '%').replace(/\?/g, '_'));
                return `${filter.field} LIKE ?`;
            
            default:
                return null;
        }
    }

    buildTextSearchCondition(textSearch, params) {
        if (textSearch.queryString) {
            // Handle query string syntax
            return this.buildQueryStringCondition(textSearch.query, params);
        }

        params.push(`%${textSearch.query}%`);
        return `${textSearch.field} LIKE ?`;
    }

    buildQueryStringCondition(queryString, params) {
        // Simple query string parser for basic operators
        const terms = queryString.split(/\s+/);
        const conditions = [];

        for (const term of terms) {
            if (term.includes(':')) {
                const [field, value] = term.split(':', 2);
                params.push(`%${value}%`);
                conditions.push(`${field} LIKE ?`);
            } else if (term !== 'AND' && term !== 'OR') {
                params.push(`%${term}%`);
                conditions.push(`message LIKE ?`);
            }
        }

        return conditions.join(' AND ');
    }

    async executeSQLQuery(sql, params) {
        return new Promise((resolve, reject) => {
            this.db.all(sql, params, (err, rows) => {
                if (err) return reject(err);

                const results = rows.map(row => ({
                    _id: row.id,
                    _source: {
                        timestamp: row.timestamp,
                        message: row.message,
                        severity: row.severity,
                        source: row.source,
                        device_id: row.device_id,
                        category: row.category,
                        metadata: row.metadata ? JSON.parse(row.metadata) : {}
                    }
                }));

                resolve(results);
            });
        });
    }

    applyFuzzySearch(results, textSearch) {
        const fuse = new Fuse(results.map(r => r._source), {
            ...this.fuseOptions,
            threshold: 0.6 - (textSearch.fuzziness || 0) * 0.1
        });

        const fuzzyResults = fuse.search(textSearch.query);
        
        return fuzzyResults.map(result => ({
            _id: results.find(r => r._source === result.item)._id,
            _source: result.item,
            _score: 1 - result.score,
            _matches: result.matches
        }));
    }

    async executeAggregations(aggregations, parsed) {
        const results = {};

        for (const [aggName, aggConfig] of Object.entries(aggregations)) {
            if (aggConfig.terms) {
                results[aggName] = await this.executeTermsAggregation(aggConfig.terms, parsed);
            } else if (aggConfig.date_histogram) {
                results[aggName] = await this.executeDateHistogramAggregation(aggConfig.date_histogram, parsed);
            } else if (aggConfig.avg) {
                results[aggName] = await this.executeMetricAggregation('AVG', aggConfig.avg.field, parsed);
            } else if (aggConfig.sum) {
                results[aggName] = await this.executeMetricAggregation('SUM', aggConfig.sum.field, parsed);
            } else if (aggConfig.count) {
                results[aggName] = await this.executeMetricAggregation('COUNT', '*', parsed);
            }
        }

        return results;
    }

    async executeTermsAggregation(termsConfig, parsed) {
        const field = termsConfig.field;
        const size = termsConfig.size || 10;

        let sql = `SELECT ${field}, COUNT(*) as doc_count FROM log_events WHERE 1=1`;
        const params = [];

        // Apply same filters as main query
        for (const filter of parsed.filters) {
            const condition = this.buildFilterCondition(filter, params);
            if (condition) {
                sql += ` AND ${condition}`;
            }
        }

        sql += ` GROUP BY ${field} ORDER BY doc_count DESC LIMIT ${size}`;

        return new Promise((resolve, reject) => {
            this.db.all(sql, params, (err, rows) => {
                if (err) return reject(err);

                resolve({
                    buckets: rows.map(row => ({
                        key: row[field],
                        doc_count: row.doc_count
                    }))
                });
            });
        });
    }

    async executeDateHistogramAggregation(histogramConfig, parsed) {
        const field = histogramConfig.field || 'timestamp';
        const interval = histogramConfig.interval || '1h';

        // Convert interval to SQLite date functions
        let dateFunction;
        switch (interval) {
            case '1m': dateFunction = "strftime('%Y-%m-%d %H:%M', timestamp)"; break;
            case '1h': dateFunction = "strftime('%Y-%m-%d %H', timestamp)"; break;
            case '1d': dateFunction = "strftime('%Y-%m-%d', timestamp)"; break;
            default: dateFunction = "strftime('%Y-%m-%d %H', timestamp)";
        }

        let sql = `SELECT ${dateFunction} as key, COUNT(*) as doc_count FROM log_events WHERE 1=1`;
        const params = [];

        // Apply same filters as main query
        for (const filter of parsed.filters) {
            const condition = this.buildFilterCondition(filter, params);
            if (condition) {
                sql += ` AND ${condition}`;
            }
        }

        sql += ` GROUP BY ${dateFunction} ORDER BY key`;

        return new Promise((resolve, reject) => {
            this.db.all(sql, params, (err, rows) => {
                if (err) return reject(err);

                resolve({
                    buckets: rows.map(row => ({
                        key: row.key,
                        key_as_string: row.key,
                        doc_count: row.doc_count
                    }))
                });
            });
        });
    }

    async executeMetricAggregation(metric, field, parsed) {
        let sql = `SELECT ${metric}(${field}) as value FROM log_events WHERE 1=1`;
        const params = [];

        // Apply same filters as main query
        for (const filter of parsed.filters) {
            const condition = this.buildFilterCondition(filter, params);
            if (condition) {
                sql += ` AND ${condition}`;
            }
        }

        return new Promise((resolve, reject) => {
            this.db.get(sql, params, (err, row) => {
                if (err) return reject(err);
                resolve({ value: row.value || 0 });
            });
        });
    }

    cleanupCache() {
        const now = Date.now();
        for (const [key, entry] of this.queryCache.entries()) {
            if (now - entry.timestamp > this.cacheTimeout) {
                this.queryCache.delete(key);
            }
        }
    }

    // Predefined query templates
    getQueryTemplates() {
        return {
            'errors_last_hour': {
                query: {
                    bool: {
                        must: [
                            { term: { severity: 'error' } },
                            { range: { timestamp: { gte: 'now-1h' } } }
                        ]
                    }
                },
                aggs: {
                    by_source: { terms: { field: 'source', size: 10 } }
                }
            },
            'security_events': {
                query: {
                    bool: {
                        should: [
                            { match: { message: 'authentication' } },
                            { match: { message: 'login' } },
                            { match: { category: 'security' } }
                        ]
                    }
                },
                sort: [{ timestamp: 'desc' }]
            },
            'device_activity': {
                query: { match_all: {} },
                aggs: {
                    by_device: { terms: { field: 'device_id', size: 20 } },
                    activity_over_time: {
                        date_histogram: {
                            field: 'timestamp',
                            interval: '1h'
                        }
                    }
                }
            }
        };
    }
}

// MULTI-PROTOCOL LOG INGESTION ENGINE
class MultiProtocolIngestionEngine {
    constructor() {
        this.servers = new Map();
        this.parsers = new Map();
        this.stats = {
            totalMessages: 0,
            messagesByProtocol: {},
            errors: 0,
            bytesReceived: 0,
            connectionsActive: 0
        };
        this.setupParsers();
    }

    setupParsers() {
        // Syslog RFC3164 Parser
        this.parsers.set('syslog-rfc3164', this.parseSyslogRFC3164.bind(this));
        
        // Syslog RFC5424 Parser  
        this.parsers.set('syslog-rfc5424', this.parseSyslogRFC5424.bind(this));
        
        // GELF Parser
        this.parsers.set('gelf', this.parseGELF.bind(this));
        
        // Beats Protocol Parser
        this.parsers.set('beats', this.parseBeats.bind(this));
        
        // Fluent Bit Parser
        this.parsers.set('fluent', this.parseFluentBit.bind(this));
        
        // JSON Parser
        this.parsers.set('json', this.parseJSON.bind(this));
    }

    async initialize() {
        loggers.system.info('üåê Initializing Multi-Protocol Log Ingestion Engine...');
        
        try {
            // Start Syslog UDP Server (RFC3164/5424)
            await this.startSyslogUDPServer();
            
            // Start Syslog TCP Server (RFC3164/5424)
            await this.startSyslogTCPServer();
            
            // Start GELF UDP Server
            await this.startGELFUDPServer();
            
            // Start GELF TCP Server  
            await this.startGELFTCPServer();
            
            // Start Beats TCP Server
            await this.startBeatsTCPServer();
            
            // Start Fluent Bit HTTP Server
            await this.startFluentBitHTTPServer();
            
            loggers.system.info('‚úÖ Multi-Protocol Log Ingestion Engine initialized');
            loggers.system.info(`   ‚Ä¢ Syslog UDP: Port ${config.ingestion?.syslog?.udpPort || 514}`);
            loggers.system.info(`   ‚Ä¢ Syslog TCP: Port ${config.ingestion?.syslog?.tcpPort || 601}`);
            loggers.system.info(`   ‚Ä¢ GELF UDP: Port ${config.ingestion?.gelf?.udpPort || 12201}`);
            loggers.system.info(`   ‚Ä¢ GELF TCP: Port ${config.ingestion?.gelf?.tcpPort || 12202}`);
            loggers.system.info(`   ‚Ä¢ Beats TCP: Port ${config.ingestion?.beats?.tcpPort || 5044}`);
            loggers.system.info(`   ‚Ä¢ Fluent HTTP: Port ${config.ingestion?.fluent?.httpPort || 9880}`);
            
        } catch (error) {
            loggers.system.error('‚ùå Multi-Protocol Ingestion Engine initialization failed:', error);
            throw error;
        }
    }

    // Initialize Distributed Tracing Integration
    async initializeDistributedTracing() {
        try {
            loggers.system.info('üîç Initializing Distributed Tracing Integration...');
            distributedTracing = new DistributedTracingEngine(config.distributedTracing);
            await distributedTracing.initialize();
            loggers.system.info('‚úÖ Distributed Tracing Integration initialized');
            loggers.system.info('   ‚Ä¢ OpenTelemetry SDK: Active');
            loggers.system.info('   ‚Ä¢ Jaeger Exporter: Configured');
            loggers.system.info('   ‚Ä¢ Trace Collection: Enabled');
            loggers.system.info('   ‚Ä¢ Span Analysis: Ready');
        } catch (error) {
            loggers.system.error('‚ùå Distributed Tracing Integration initialization failed:', error);
            throw error;
        }
    }

    // Parser Methods
    parseSyslogRFC3164(message, rinfo) {
        try {
            // Basic syslog RFC3164 parsing
            const match = message.match(/^<(\d+)>(\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})\s+(\S+)\s+(.*)/);
            if (!match) return null;
            
            const [, priority, timestamp, hostname, msg] = match;
            return {
                protocol: 'syslog-rfc3164',
                timestamp: new Date(timestamp),
                hostname,
                message: msg,
                priority: parseInt(priority),
                source: rinfo.address
            };
        } catch (error) {
            loggers.system.error('Failed to parse syslog RFC3164:', error);
            return null;
        }
    }

    parseSyslogRFC5424(message, rinfo) {
        try {
            // Basic syslog RFC5424 parsing
            const match = message.match(/^<(\d+)>1\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(.*)/);
            if (!match) return null;
            
            const [, priority, timestamp, hostname, appName, procId, msgId, structured, msg] = match;
            return {
                protocol: 'syslog-rfc5424',
                timestamp: new Date(timestamp),
                hostname,
                appName,
                processId: procId,
                messageId: msgId,
                message: msg,
                priority: parseInt(priority),
                source: rinfo.address
            };
        } catch (error) {
            loggers.system.error('Failed to parse syslog RFC5424:', error);
            return null;
        }
    }

    parseGELF(message, rinfo) {
        try {
            const data = JSON.parse(message);
            return {
                protocol: 'gelf',
                timestamp: new Date(data.timestamp * 1000),
                hostname: data.host,
                message: data.short_message || data.full_message,
                level: data.level,
                facility: data.facility,
                source: rinfo.address,
                ...data
            };
        } catch (error) {
            loggers.system.error('Failed to parse GELF:', error);
            return null;
        }
    }

    parseBeats(message, rinfo) {
        try {
            const data = JSON.parse(message);
            return {
                protocol: 'beats',
                timestamp: new Date(data['@timestamp']),
                message: data.message,
                source: rinfo.address,
                fields: data.fields || {},
                ...data
            };
        } catch (error) {
            loggers.system.error('Failed to parse Beats:', error);
            return null;
        }
    }

    parseFluentBit(data, rinfo) {
        try {
            return {
                protocol: 'fluent',
                timestamp: new Date(data.timestamp || Date.now()),
                message: data.message || JSON.stringify(data),
                source: rinfo.address,
                tag: data.tag,
                ...data
            };
        } catch (error) {
            loggers.system.error('Failed to parse FluentBit:', error);
            return null;
        }
    }

    parseJSON(message, rinfo) {
        try {
            const data = JSON.parse(message);
            return {
                protocol: 'json',
                timestamp: new Date(data.timestamp || Date.now()),
                message: data.message || JSON.stringify(data),
                source: rinfo.address,
                ...data
            };
        } catch (error) {
            loggers.system.error('Failed to parse JSON:', error);
            return null;
        }
    }

    // Get ingestion statistics
    getStats() {
        return {
            totalMessages: this.stats.totalMessages,
            messagesByProtocol: { ...this.stats.messagesByProtocol },
            errors: this.stats.errors,
            bytesReceived: this.stats.bytesReceived,
            connectionsActive: this.stats.connectionsActive
        };
    }

    // Placeholder server startup methods (implement as needed)
    async startSyslogUDPServer() {
        if (!config.ingestion.syslog.enabled) return;
        loggers.system.info(`Starting Syslog UDP server on port ${config.ingestion.syslog.udpPort}`);
        // Implementation would go here
    }

    async startSyslogTCPServer() {
        if (!config.ingestion.syslog.enabled) return;
        loggers.system.info(`Starting Syslog TCP server on port ${config.ingestion.syslog.tcpPort}`);
        // Implementation would go here
    }

    async startGELFUDPServer() {
        if (!config.ingestion.gelf.enabled) return;
        loggers.system.info(`Starting GELF UDP server on port ${config.ingestion.gelf.udpPort}`);
        // Implementation would go here
    }

    async startGELFTCPServer() {
        if (!config.ingestion.gelf.enabled) return;
        loggers.system.info(`Starting GELF TCP server on port ${config.ingestion.gelf.tcpPort}`);
        // Implementation would go here
    }

    async startBeatsTCPServer() {
        if (!config.ingestion.beats.enabled) return;
        loggers.system.info(`Starting Beats TCP server on port ${config.ingestion.beats.tcpPort}`);
        // Implementation would go here
    }

    async startFluentBitHTTPServer() {
        if (!config.ingestion.fluent.enabled) return;
        loggers.system.info(`Starting Fluent HTTP server on port ${config.ingestion.fluent.httpPort}`);
        // Implementation would go here
    }
}

// ============================================================================
// DATA RETENTION & LIFECYCLE MANAGEMENT ENGINE
// ============================================================================

class DataRetentionEngine {
    constructor(database) {
        this.db = database;
        this.retentionPolicies = new Map();
        this.archiveDirectory = path.join(__dirname, 'data', 'archives');
        this.compressionLevel = 6; // gzip compression level
        this.isProcessing = false;
        this.lastCleanup = null;
        this.statistics = {
            totalRecords: 0,
            archivedRecords: 0,
            compressedSize: 0,
            originalSize: 0,
            spaceFreed: 0
        };
    }

    async initialize() {
        try {
            // Ensure archive directory exists
            if (!fs.existsSync(this.archiveDirectory)) {
                fs.mkdirSync(this.archiveDirectory, { recursive: true });
            }

            // Create retention policies table
            await this.createRetentionSchema();
            
            // Load retention policies from database
            await this.loadRetentionPolicies();
            
            // Initialize default policies if none exist
            await this.createDefaultPolicies();
            
            // Schedule retention tasks
            this.scheduleRetentionTasks();
            
            loggers.system.info('Data Retention Engine initialized successfully');
            return true;
        } catch (error) {
            loggers.system.error('Failed to initialize Data Retention Engine:', error);
            return false;
        }
    }

    async createRetentionSchema() {
        const queries = [
            `CREATE TABLE IF NOT EXISTS retention_policies (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                description TEXT,
                table_name TEXT NOT NULL,
                retention_days INTEGER NOT NULL,
                archive_enabled INTEGER DEFAULT 1,
                compression_enabled INTEGER DEFAULT 1,
                delete_after_archive INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_executed DATETIME,
                status TEXT DEFAULT 'active'
            )`,
            `CREATE TABLE IF NOT EXISTS retention_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                policy_id INTEGER,
                execution_date DATETIME DEFAULT CURRENT_TIMESTAMP,
                records_processed INTEGER DEFAULT 0,
                records_archived INTEGER DEFAULT 0,
                records_deleted INTEGER DEFAULT 0,
                original_size_bytes INTEGER DEFAULT 0,
                compressed_size_bytes INTEGER DEFAULT 0,
                execution_time_ms INTEGER DEFAULT 0,
                status TEXT DEFAULT 'pending',
                error_message TEXT,
                FOREIGN KEY (policy_id) REFERENCES retention_policies (id)
            )`,
            `CREATE TABLE IF NOT EXISTS archived_logs_metadata (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                archive_filename TEXT UNIQUE NOT NULL,
                original_table TEXT NOT NULL,
                date_from DATE NOT NULL,
                date_to DATE NOT NULL,
                record_count INTEGER NOT NULL,
                original_size_bytes INTEGER NOT NULL,
                compressed_size_bytes INTEGER NOT NULL,
                compression_ratio REAL,
                archive_path TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                checksum TEXT
            )`
        ];

        for (const query of queries) {
            await this.db.run(query);
        }
    }

    async loadRetentionPolicies() {
        try {
            const policies = await this.db.all(`
                SELECT * FROM retention_policies 
                WHERE status = 'active' 
                ORDER BY name
            `);

            this.retentionPolicies.clear();
            for (const policy of policies) {
                this.retentionPolicies.set(policy.id, policy);
            }

            loggers.system.info(`Loaded ${policies.length} retention policies`);
        } catch (error) {
            loggers.system.error('Failed to load retention policies:', error);
        }
    }

    async createDefaultPolicies() {
        try {
            const existingPolicies = await this.db.get('SELECT COUNT(*) as count FROM retention_policies');
            if (existingPolicies.count > 0) return;

            const defaultPolicies = [
                {
                    name: 'System Logs Retention',
                    description: 'Archive system logs after 30 days, delete after 365 days',
                    table_name: 'logs',
                    retention_days: 30,
                    archive_enabled: 1,
                    compression_enabled: 1,
                    delete_after_archive: 0
                },
                {
                    name: 'Security Logs Retention',
                    description: 'Archive security logs after 90 days, keep forever',
                    table_name: 'security_logs',
                    retention_days: 90,
                    archive_enabled: 1,
                    compression_enabled: 1,
                    delete_after_archive: 0
                },
                {
                    name: 'Activity Logs Retention',
                    description: 'Archive activity logs after 60 days, delete after 180 days',
                    table_name: 'activity_logs',
                    retention_days: 60,
                    archive_enabled: 1,
                    compression_enabled: 1,
                    delete_after_archive: 0
                },
                {
                    name: 'Metrics Cleanup',
                    description: 'Delete old metrics after 7 days (no archival)',
                    table_name: 'metrics',
                    retention_days: 7,
                    archive_enabled: 0,
                    compression_enabled: 0,
                    delete_after_archive: 1
                }
            ];

            for (const policy of defaultPolicies) {
                await this.db.run(`
                    INSERT INTO retention_policies (
                        name, description, table_name, retention_days,
                        archive_enabled, compression_enabled, delete_after_archive
                    ) VALUES (?, ?, ?, ?, ?, ?, ?)
                `, [
                    policy.name, policy.description, policy.table_name,
                    policy.retention_days, policy.archive_enabled,
                    policy.compression_enabled, policy.delete_after_archive
                ]);
            }

            await this.loadRetentionPolicies();
            loggers.system.info('Created default retention policies');
        } catch (error) {
            loggers.system.error('Failed to create default retention policies:', error);
        }
    }

    scheduleRetentionTasks() {
        // Daily retention check at 2 AM
        cron.schedule(config.maintenance.cleanupSchedule, async () => {
            await this.executeRetentionPolicies();
        });

        // Weekly archive optimization at 3 AM Sunday
        cron.schedule('0 3 * * 0', async () => {
            await this.optimizeArchives();
        });

        loggers.system.info('Scheduled retention tasks');
    }

    async executeRetentionPolicies(policyId = null) {
        if (this.isProcessing) {
            loggers.system.warn('Retention process already running');
            return false;
        }

        this.isProcessing = true;
        const startTime = Date.now();

        try {
            loggers.system.info('Starting retention policy execution');

            const policiesToExecute = policyId 
                ? [this.retentionPolicies.get(policyId)].filter(Boolean)
                : Array.from(this.retentionPolicies.values());

            let totalProcessed = 0;
            let totalArchived = 0;
            let totalDeleted = 0;

            for (const policy of policiesToExecute) {
                const result = await this.executePolicy(policy);
                totalProcessed += result.processed;
                totalArchived += result.archived;
                totalDeleted += result.deleted;
            }

            const executionTime = Date.now() - startTime;
            this.lastCleanup = new Date();

            loggers.system.info(`Retention execution completed`, {
                duration: executionTime,
                processed: totalProcessed,
                archived: totalArchived,
                deleted: totalDeleted
            });

            return {
                success: true,
                processed: totalProcessed,
                archived: totalArchived,
                deleted: totalDeleted,
                executionTime
            };

        } catch (error) {
            loggers.system.error('Retention policy execution failed:', error);
            return { success: false, error: error.message };
        } finally {
            this.isProcessing = false;
        }
    }

    async executePolicy(policy) {
        const historyId = await this.createExecutionHistory(policy.id);
        const startTime = Date.now();
        let processed = 0;
        let archived = 0;
        let deleted = 0;
        let originalSize = 0;
        let compressedSize = 0;

        try {
            // Calculate cutoff date
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - policy.retention_days);

            loggers.system.info(`Executing policy: ${policy.name} for data older than ${cutoffDate.toISOString()}`);

            // Check if table exists
            const tableExists = await this.tableExists(policy.table_name);
            if (!tableExists) {
                loggers.system.warn(`Table ${policy.table_name} does not exist, skipping policy`);
                await this.updateExecutionHistory(historyId, {
                    status: 'skipped',
                    error_message: `Table ${policy.table_name} does not exist`
                });
                return { processed: 0, archived: 0, deleted: 0 };
            }

            // Get records to process
            const oldRecords = await this.getOldRecords(policy.table_name, cutoffDate);
            processed = oldRecords.length;

            if (processed === 0) {
                loggers.system.info(`No records to process for policy: ${policy.name}`);
                await this.updateExecutionHistory(historyId, {
                    status: 'completed',
                    records_processed: processed,
                    execution_time_ms: Date.now() - startTime
                });
                return { processed, archived, deleted };
            }

            // Archive records if enabled
            if (policy.archive_enabled) {
                const archiveResult = await this.archiveRecords(
                    policy.table_name,
                    oldRecords,
                    cutoffDate,
                    policy.compression_enabled
                );
                archived = archiveResult.count;
                originalSize = archiveResult.originalSize;
                compressedSize = archiveResult.compressedSize;
            }

            // Delete old records
            deleted = await this.deleteOldRecords(policy.table_name, cutoffDate);

            // Update statistics
            this.updateStatistics(processed, archived, originalSize, compressedSize);

            // Update execution history
            await this.updateExecutionHistory(historyId, {
                status: 'completed',
                records_processed: processed,
                records_archived: archived,
                records_deleted: deleted,
                original_size_bytes: originalSize,
                compressed_size_bytes: compressedSize,
                execution_time_ms: Date.now() - startTime
            });

            // Update policy last executed time
            await this.db.run(`
                UPDATE retention_policies 
                SET last_executed = CURRENT_TIMESTAMP 
                WHERE id = ?
            `, [policy.id]);

            loggers.system.info(`Policy execution completed: ${policy.name}`, {
                processed,
                archived,
                deleted,
                compressionRatio: originalSize > 0 ? (compressedSize / originalSize).toFixed(2) : 0
            });

            return { processed, archived, deleted };

        } catch (error) {
            loggers.system.error(`Policy execution failed: ${policy.name}`, error);
            await this.updateExecutionHistory(historyId, {
                status: 'failed',
                error_message: error.message,
                execution_time_ms: Date.now() - startTime
            });
            throw error;
        }
    }

    async createExecutionHistory(policyId) {
        const result = await this.db.run(`
            INSERT INTO retention_history (policy_id, status)
            VALUES (?, 'running')
        `, [policyId]);
        return result.lastID;
    }

    async updateExecutionHistory(historyId, updates) {
        const fields = Object.keys(updates);
        const values = Object.values(updates);
        const setClause = fields.map(field => `${field} = ?`).join(', ');

        await this.db.run(`
            UPDATE retention_history 
            SET ${setClause}
            WHERE id = ?
        `, [...values, historyId]);
    }

    async tableExists(tableName) {
        try {
            const result = await this.db.get(`
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name=?
            `, [tableName]);
            return !!result;
        } catch (error) {
            return false;
        }
    }

    async getOldRecords(tableName, cutoffDate) {
        try {
            // Try different timestamp column names
            const timestampColumns = ['timestamp', 'created_at', 'date', 'time'];
            
            for (const column of timestampColumns) {
                try {
                    const records = await this.db.all(`
                        SELECT * FROM ${tableName} 
                        WHERE ${column} < ? 
                        ORDER BY ${column}
                    `, [cutoffDate.toISOString()]);
                    return records;
                } catch (error) {
                    // Column doesn't exist, try next one
                    continue;
                }
            }

            // If no timestamp column found, return empty array
            loggers.system.warn(`No timestamp column found in table ${tableName}`);
            return [];
        } catch (error) {
            loggers.system.error(`Error getting old records from ${tableName}:`, error);
            return [];
        }
    }

    async archiveRecords(tableName, records, cutoffDate, compressionEnabled) {
        if (records.length === 0) {
            return { count: 0, originalSize: 0, compressedSize: 0 };
        }

        const archiveDate = new Date().toISOString().split('T')[0];
        const filename = `${tableName}_${archiveDate}.json`;
        const archivePath = path.join(this.archiveDirectory, filename);

        try {
            // Prepare archive data
            const archiveData = {
                metadata: {
                    table: tableName,
                    exportDate: new Date().toISOString(),
                    dateFrom: records[0].timestamp || records[0].created_at || records[0].date,
                    dateTo: records[records.length - 1].timestamp || records[records.length - 1].created_at || records[records.length - 1].date,
                    recordCount: records.length
                },
                records: records
            };

            const jsonData = JSON.stringify(archiveData, null, 2);
            const originalSize = Buffer.byteLength(jsonData, 'utf8');

            let finalPath = archivePath;
            let compressedSize = originalSize;

            if (compressionEnabled) {
                // Compress the data
                const compressed = zlib.gzipSync(jsonData, { level: this.compressionLevel });
                finalPath = archivePath + '.gz';
                compressedSize = compressed.length;
                fs.writeFileSync(finalPath, compressed);
            } else {
                fs.writeFileSync(finalPath, jsonData);
            }

            // Calculate checksum
            const checksum = crypto.createHash('sha256').update(jsonData).digest('hex');

            // Store archive metadata
            await this.db.run(`
                INSERT INTO archived_logs_metadata (
                    archive_filename, original_table, date_from, date_to,
                    record_count, original_size_bytes, compressed_size_bytes,
                    compression_ratio, archive_path, checksum
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                path.basename(finalPath),
                tableName,
                archiveData.metadata.dateFrom,
                archiveData.metadata.dateTo,
                records.length,
                originalSize,
                compressedSize,
                compressedSize / originalSize,
                finalPath,
                checksum
            ]);

            loggers.system.info(`Archived ${records.length} records to ${finalPath}`, {
                originalSize,
                compressedSize,
                compressionRatio: (compressedSize / originalSize).toFixed(2)
            });

            return {
                count: records.length,
                originalSize,
                compressedSize
            };

        } catch (error) {
            loggers.system.error('Failed to archive records:', error);
            throw error;
        }
    }

    async deleteOldRecords(tableName, cutoffDate) {
        try {
            const timestampColumns = ['timestamp', 'created_at', 'date', 'time'];
            
            for (const column of timestampColumns) {
                try {
                    const result = await this.db.run(`
                        DELETE FROM ${tableName} 
                        WHERE ${column} < ?
                    `, [cutoffDate.toISOString()]);
                    return result.changes || 0;
                } catch (error) {
                    continue;
                }
            }

            return 0;
        } catch (error) {
            loggers.system.error(`Error deleting old records from ${tableName}:`, error);
            return 0;
        }
    }

    updateStatistics(processed, archived, originalSize, compressedSize) {
        this.statistics.totalRecords += processed;
        this.statistics.archivedRecords += archived;
        this.statistics.originalSize += originalSize;
        this.statistics.compressedSize += compressedSize;
        this.statistics.spaceFreed += (originalSize - compressedSize);
    }

    async optimizeArchives() {
        try {
            loggers.system.info('Starting archive optimization');

            // Get all archives older than 30 days
            const oldArchives = await this.db.all(`
                SELECT * FROM archived_logs_metadata 
                WHERE created_at < datetime('now', '-30 days')
                AND archive_filename NOT LIKE '%.optimized.%'
            `);

            for (const archive of oldArchives) {
                await this.optimizeArchive(archive);
            }

            loggers.system.info(`Archive optimization completed for ${oldArchives.length} archives`);
        } catch (error) {
            loggers.system.error('Archive optimization failed:', error);
        }
    }

    async optimizeArchive(archiveInfo) {
        try {
            const archivePath = archiveInfo.archive_path;
            if (!fs.existsSync(archivePath)) {
                loggers.system.warn(`Archive file not found: ${archivePath}`);
                return;
            }

            // Read and recompress with higher compression
            let data;
            if (archivePath.endsWith('.gz')) {
                data = zlib.gunzipSync(fs.readFileSync(archivePath));
            } else {
                data = fs.readFileSync(archivePath);
            }

            // Recompress with maximum compression
            const optimized = zlib.gzipSync(data, { level: 9 });
            const optimizedPath = archivePath.replace(/\.gz$/, '') + '.optimized.gz';

            fs.writeFileSync(optimizedPath, optimized);

            // Update metadata
            await this.db.run(`
                UPDATE archived_logs_metadata 
                SET archive_filename = ?, 
                    archive_path = ?,
                    compressed_size_bytes = ?
                WHERE id = ?
            `, [
                path.basename(optimizedPath),
                optimizedPath,
                optimized.length,
                archiveInfo.id
            ]);

            // Remove old file
            fs.unlinkSync(archivePath);

            loggers.system.info(`Optimized archive: ${archiveInfo.archive_filename}`, {
                originalCompressedSize: archiveInfo.compressed_size_bytes,
                optimizedSize: optimized.length,
                spaceSaved: archiveInfo.compressed_size_bytes - optimized.length
            });

        } catch (error) {
            loggers.system.error(`Failed to optimize archive ${archiveInfo.archive_filename}:`, error);
        }
    }

    async getRetentionStatistics() {
        try {
            const policies = await this.db.all(`
                SELECT p.*, 
                       COUNT(h.id) as execution_count,
                       MAX(h.execution_date) as last_execution,
                       SUM(h.records_processed) as total_processed,
                       SUM(h.records_archived) as total_archived,
                       SUM(h.records_deleted) as total_deleted
                FROM retention_policies p
                LEFT JOIN retention_history h ON p.id = h.policy_id
                WHERE p.status = 'active'
                GROUP BY p.id
                ORDER BY p.name
            `);

            const archives = await this.db.all(`
                SELECT original_table,
                       COUNT(*) as archive_count,
                       SUM(record_count) as total_records,
                       SUM(original_size_bytes) as total_original_size,
                       SUM(compressed_size_bytes) as total_compressed_size,
                       MIN(date_from) as earliest_date,
                       MAX(date_to) as latest_date
                FROM archived_logs_metadata
                GROUP BY original_table
            `);

            const totalStats = await this.db.get(`
                SELECT COUNT(*) as total_archives,
                       SUM(record_count) as total_archived_records,
                       SUM(original_size_bytes) as total_original_size,
                       SUM(compressed_size_bytes) as total_compressed_size
                FROM archived_logs_metadata
            `);

            return {
                policies,
                archives,
                totalStats: {
                    ...totalStats,
                    compressionRatio: totalStats.total_original_size > 0 
                        ? (totalStats.total_compressed_size / totalStats.total_original_size).toFixed(2)
                        : 0,
                    spaceSaved: totalStats.total_original_size - totalStats.total_compressed_size
                },
                runtimeStats: this.statistics,
                lastCleanup: this.lastCleanup,
                isProcessing: this.isProcessing
            };
        } catch (error) {
            loggers.system.error('Failed to get retention statistics:', error);
            return null;
        }
    }

    async createRetentionPolicy(policyData) {
        try {
            const result = await this.db.run(`
                INSERT INTO retention_policies (
                    name, description, table_name, retention_days,
                    archive_enabled, compression_enabled, delete_after_archive
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
            `, [
                policyData.name,
                policyData.description,
                policyData.table_name,
                policyData.retention_days,
                policyData.archive_enabled ? 1 : 0,
                policyData.compression_enabled ? 1 : 0,
                policyData.delete_after_archive ? 1 : 0
            ]);

            await this.loadRetentionPolicies();
            return { success: true, id: result.lastID };
        } catch (error) {
            loggers.system.error('Failed to create retention policy:', error);
            return { success: false, error: error.message };
        }
    }

    async updateRetentionPolicy(policyId, updates) {
        try {
            const fields = Object.keys(updates);
            const values = Object.values(updates);
            const setClause = fields.map(field => `${field} = ?`).join(', ');

            await this.db.run(`
                UPDATE retention_policies 
                SET ${setClause}, updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            `, [...values, policyId]);

            await this.loadRetentionPolicies();
            return { success: true };
        } catch (error) {
            loggers.system.error('Failed to update retention policy:', error);
            return { success: false, error: error.message };
        }
    }

    async deleteRetentionPolicy(policyId) {
        try {
            await this.db.run(`
                UPDATE retention_policies 
                SET status = 'deleted'
                WHERE id = ?
            `, [policyId]);

            await this.loadRetentionPolicies();
            return { success: true };
        } catch (error) {
            loggers.system.error('Failed to delete retention policy:', error);
            return { success: false, error: error.message };
        }
    }

    async restoreFromArchive(archiveId, targetTable = null) {
        try {
            const archive = await this.db.get(`
                SELECT * FROM archived_logs_metadata WHERE id = ?
            `, [archiveId]);

            if (!archive) {
                throw new Error('Archive not found');
            }

            const archivePath = archive.archive_path;
            if (!fs.existsSync(archivePath)) {
                throw new Error('Archive file not found');
            }

            // Read archive data
            let jsonData;
            if (archivePath.endsWith('.gz')) {
                const compressed = fs.readFileSync(archivePath);
                jsonData = zlib.gunzipSync(compressed).toString();
            } else {
                jsonData = fs.readFileSync(archivePath, 'utf8');
            }

            const archiveData = JSON.parse(jsonData);
            const table = targetTable || archive.original_table;

            // Restore records to database
            let restored = 0;
            for (const record of archiveData.records) {
                try {
                    const fields = Object.keys(record);
                    const values = Object.values(record);
                    const placeholders = fields.map(() => '?').join(', ');
                    const fieldsList = fields.join(', ');

                    await this.db.run(`
                        INSERT INTO ${table} (${fieldsList}) 
                        VALUES (${placeholders})
                    `, values);
                    restored++;
                } catch (error) {
                    // Skip duplicate records
                    continue;
                }
            }

            loggers.system.info(`Restored ${restored} records from archive ${archive.archive_filename}`);
            return { success: true, restored };

        } catch (error) {
            loggers.system.error('Failed to restore from archive:', error);
            return { success: false, error: error.message };
        }
    }
}

// Advanced Dashboard Builder Class
class AdvancedDashboardBuilder {
    constructor() {
        this.dashboards = new Map();
        this.widgets = new Map();
        this.layouts = new Map();
        this.templates = new Map();
        this.userPreferences = new Map();
        this.widgetTypes = [
            'log_timeline',
            'metrics_chart',
            'alert_summary',
            'system_status',
            'log_levels_pie',
            'source_breakdown',
            'error_trending',
            'performance_gauge',
            'geo_map',
            'correlation_matrix',
            'real_time_feed',
            'custom_query'
        ];
    }

    async initialize() {
        try {
            loggers.system.info('üìä Initializing Advanced Dashboard Builder...');
            
            // Initialize database tables for dashboards
            await this.initializeDashboardTables();
            
            // Load existing dashboards and widgets
            await this.loadDashboards();
            await this.loadWidgets();
            
            // Initialize default templates
            await this.initializeDefaultTemplates();
            
            loggers.system.info('‚úÖ Advanced Dashboard Builder initialized');
            loggers.system.info('   ‚Ä¢ Widget Types: 12 available');
            loggers.system.info('   ‚Ä¢ Drag & Drop: Enabled');
            loggers.system.info('   ‚Ä¢ Real-time Updates: Active');
            loggers.system.info('   ‚Ä¢ Custom Layouts: Supported');
            
        } catch (error) {
            loggers.system.error('‚ùå Dashboard Builder initialization failed:', error);
            throw error;
        }
    }

    async initializeDashboardTables() {
        // Create dashboards table
        const createDashboardsTable = `
            CREATE TABLE IF NOT EXISTS dashboards (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                owner_user_id TEXT,
                layout_config TEXT,
                is_public BOOLEAN DEFAULT 0,
                is_default BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                tags TEXT
            )`;

        // Create widgets table
        const createWidgetsTable = `
            CREATE TABLE IF NOT EXISTS dashboard_widgets (
                id TEXT PRIMARY KEY,
                dashboard_id TEXT,
                widget_type TEXT NOT NULL,
                title TEXT NOT NULL,
                position_x INTEGER DEFAULT 0,
                position_y INTEGER DEFAULT 0,
                width INTEGER DEFAULT 4,
                height INTEGER DEFAULT 3,
                config TEXT,
                data_source TEXT,
                refresh_interval INTEGER DEFAULT 30,
                is_enabled BOOLEAN DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (dashboard_id) REFERENCES dashboards(id)
            )`;

        // Create widget templates table
        const createTemplatesTable = `
            CREATE TABLE IF NOT EXISTS widget_templates (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                widget_type TEXT NOT NULL,
                default_config TEXT,
                category TEXT,
                is_system BOOLEAN DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )`;

        // Create user dashboard preferences table
        const createPreferencesTable = `
            CREATE TABLE IF NOT EXISTS user_dashboard_preferences (
                user_id TEXT,
                dashboard_id TEXT,
                layout_settings TEXT,
                widget_settings TEXT,
                theme TEXT DEFAULT 'default',
                auto_refresh BOOLEAN DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (user_id, dashboard_id)
            )`;

        db.exec(createDashboardsTable);
        db.exec(createWidgetsTable);
        db.exec(createTemplatesTable);
        db.exec(createPreferencesTable);
        
        loggers.system.info('‚úÖ Dashboard database tables initialized');
    }

    async loadDashboards() {
        try {
            const dashboards = db.prepare(`
                SELECT * FROM dashboards ORDER BY created_at DESC
            `).all();

            // Ensure dashboards is an array
            if (dashboards && Array.isArray(dashboards)) {
                for (const dashboard of dashboards) {
                    this.dashboards.set(dashboard.id, {
                        ...dashboard,
                        layoutConfig: JSON.parse(dashboard.layout_config || '{}'),
                        tags: dashboard.tags ? dashboard.tags.split(',') : []
                    });
                }
                loggers.system.info(`üìä Loaded ${dashboards.length} dashboard(s)`);
            } else {
                loggers.system.info(`üìä No dashboards found or invalid response`);
            }
        } catch (error) {
            loggers.system.error('Failed to load dashboards:', error);
        }
    }

    async loadWidgets() {
        try {
            const widgets = db.prepare(`
                SELECT * FROM dashboard_widgets ORDER BY dashboard_id, position_y, position_x
            `).all();

            // Ensure widgets is an array
            if (widgets && Array.isArray(widgets)) {
                for (const widget of widgets) {
                    if (!this.widgets.has(widget.dashboard_id)) {
                        this.widgets.set(widget.dashboard_id, []);
                    }
                    
                    this.widgets.get(widget.dashboard_id).push({
                        ...widget,
                        config: JSON.parse(widget.config || '{}')
                    });
                }
                loggers.system.info(`üéõÔ∏è Loaded ${widgets.length} widget(s)`);
            } else {
                loggers.system.info(`üéõÔ∏è No widgets found or invalid response`);
            }
        } catch (error) {
            loggers.system.error('Failed to load widgets:', error);
        }
    }

    async initializeDefaultTemplates() {
        const defaultTemplates = [
            {
                id: 'log_timeline_basic',
                name: 'Basic Log Timeline',
                description: 'Simple timeline view of log entries',
                widget_type: 'log_timeline',
                default_config: JSON.stringify({
                    timeRange: '1h',
                    maxEntries: 100,
                    showLevels: true,
                    colorCoding: true
                }),
                category: 'logging'
            },
            {
                id: 'metrics_realtime_chart',
                name: 'Real-time Metrics Chart',
                description: 'Live updating metrics visualization',
                widget_type: 'metrics_chart',
                default_config: JSON.stringify({
                    chartType: 'line',
                    updateInterval: 5,
                    showLegend: true,
                    maxDataPoints: 50
                }),
                category: 'metrics'
            },
            {
                id: 'alert_summary_widget',
                name: 'Alert Summary',
                description: 'Overview of active and recent alerts',
                widget_type: 'alert_summary',
                default_config: JSON.stringify({
                    showActive: true,
                    showRecent: true,
                    timeRange: '24h',
                    groupBySeverity: true
                }),
                category: 'alerting'
            },
            {
                id: 'system_status_overview',
                name: 'System Status Overview',
                description: 'High-level system health indicators',
                widget_type: 'system_status',
                default_config: JSON.stringify({
                    showUptime: true,
                    showMemory: true,
                    showCPU: true,
                    showStorage: true
                }),
                category: 'monitoring'
            }
        ];

        for (const template of defaultTemplates) {
            const existing = db.prepare(`
                SELECT id FROM widget_templates WHERE id = ?
            `).get(template.id);

            if (!existing) {
                db.prepare(`
                    INSERT INTO widget_templates 
                    (id, name, description, widget_type, default_config, category, is_system)
                    VALUES (?, ?, ?, ?, ?, ?, 1)
                `).run(template.id, template.name, template.description, 
                       template.widget_type, template.default_config, template.category);
                
                this.templates.set(template.id, template);
            }
        }

        loggers.system.info(`üé® Initialized ${defaultTemplates.length} default widget template(s)`);
    }

    async createDashboard(userId, dashboardData) {
        try {
            const dashboardId = `dashboard_${Date.now()}_${Math.random().toString(36).substring(7)}`;
            
            const dashboard = {
                id: dashboardId,
                name: dashboardData.name,
                description: dashboardData.description || '',
                owner_user_id: userId,
                layout_config: JSON.stringify(dashboardData.layout || {}),
                is_public: dashboardData.isPublic || false,
                is_default: dashboardData.isDefault || false,
                tags: dashboardData.tags ? dashboardData.tags.join(',') : ''
            };

            db.prepare(`
                INSERT INTO dashboards 
                (id, name, description, owner_user_id, layout_config, is_public, is_default, tags)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            `).run(dashboard.id, dashboard.name, dashboard.description,
                   dashboard.owner_user_id, dashboard.layout_config,
                   dashboard.is_public, dashboard.is_default, dashboard.tags);

            this.dashboards.set(dashboardId, dashboard);

            loggers.system.info(`üìä Created dashboard: ${dashboard.name} (${dashboardId})`);
            return dashboard;
        } catch (error) {
            loggers.system.error('Failed to create dashboard:', error);
            throw error;
        }
    }

    async addWidget(dashboardId, widgetData) {
        try {
            const widgetId = `widget_${Date.now()}_${Math.random().toString(36).substring(7)}`;
            
            const widget = {
                id: widgetId,
                dashboard_id: dashboardId,
                widget_type: widgetData.type,
                title: widgetData.title,
                position_x: widgetData.position?.x || 0,
                position_y: widgetData.position?.y || 0,
                width: widgetData.size?.width || 4,
                height: widgetData.size?.height || 3,
                config: JSON.stringify(widgetData.config || {}),
                data_source: widgetData.dataSource || 'logs',
                refresh_interval: widgetData.refreshInterval || 30,
                is_enabled: widgetData.isEnabled !== false
            };

            db.prepare(`
                INSERT INTO dashboard_widgets 
                (id, dashboard_id, widget_type, title, position_x, position_y, 
                 width, height, config, data_source, refresh_interval, is_enabled)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            `).run(widget.id, widget.dashboard_id, widget.widget_type, widget.title,
                   widget.position_x, widget.position_y, widget.width, widget.height,
                   widget.config, widget.data_source, widget.refresh_interval, widget.is_enabled);

            // Add to widgets map
            if (!this.widgets.has(dashboardId)) {
                this.widgets.set(dashboardId, []);
            }
            this.widgets.get(dashboardId).push(widget);

            loggers.system.info(`üéõÔ∏è Added widget: ${widget.title} to dashboard ${dashboardId}`);
            return widget;
        } catch (error) {
            loggers.system.error('Failed to add widget:', error);
            throw error;
        }
    }

    async generateWidgetData(widget) {
        try {
            switch (widget.widget_type) {
                case 'log_timeline':
                    return await this.generateLogTimelineData(widget);
                
                case 'metrics_chart':
                    return await this.generateMetricsChartData(widget);
                
                case 'alert_summary':
                    return await this.generateAlertSummaryData(widget);
                
                case 'system_status':
                    return await this.generateSystemStatusData(widget);
                
                case 'log_levels_pie':
                    return await this.generateLogLevelsPieData(widget);
                
                case 'real_time_feed':
                    return await this.generateRealTimeFeedData(widget);
                
                default:
                    return { data: [], labels: [], message: 'Widget type not implemented' };
            }
        } catch (error) {
            loggers.system.error(`Failed to generate data for widget ${widget.id}:`, error);
            return { data: [], labels: [], error: error.message };
        }
    }

    async generateLogTimelineData(widget) {
        const config = JSON.parse(widget.config || '{}');
        const timeRange = config.timeRange || '1h';
        const maxEntries = config.maxEntries || 100;
        
        // Calculate time range
        const now = new Date();
        const timeRangeMs = this.parseTimeRange(timeRange);
        const startTime = new Date(now.getTime() - timeRangeMs);

        const logs = db.prepare(`
            SELECT timestamp, level, message, source 
            FROM logs 
            WHERE timestamp >= ? 
            ORDER BY timestamp DESC 
            LIMIT ?
        `).all(startTime.toISOString(), maxEntries);

        return {
            data: logs.map(log => ({
                x: log.timestamp,
                y: log.level,
                message: log.message,
                source: log.source
            })),
            labels: ['timestamp', 'level', 'message'],
            count: logs.length
        };
    }

    async generateMetricsChartData(widget) {
        const config = JSON.parse(widget.config || '{}');
        
        // Get recent metrics data
        const metrics = db.prepare(`
            SELECT timestamp, memory_usage, cpu_usage, request_count 
            FROM system_metrics 
            ORDER BY timestamp DESC 
            LIMIT 50
        `).all();

        return {
            data: metrics.reverse().map(metric => ({
                x: metric.timestamp,
                memory: metric.memory_usage,
                cpu: metric.cpu_usage,
                requests: metric.request_count
            })),
            labels: ['timestamp', 'memory', 'cpu', 'requests']
        };
    }

    async generateAlertSummaryData(widget) {
        const config = JSON.parse(widget.config || '{}');
        
        // Get alert summary data
        const alertCounts = db.prepare(`
            SELECT severity, COUNT(*) as count, 
                   SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END) as active_count
            FROM alerts 
            WHERE created_at >= datetime('now', '-24 hours')
            GROUP BY severity
        `).all();

        return {
            data: alertCounts,
            labels: ['severity', 'total', 'active'],
            summary: {
                total: alertCounts.reduce((sum, item) => sum + item.count, 0),
                active: alertCounts.reduce((sum, item) => sum + item.active_count, 0)
            }
        };
    }

    async generateSystemStatusData(widget) {
        const config = JSON.parse(widget.config || '{}');
        
        // Get latest system metrics
        const latest = db.prepare(`
            SELECT * FROM system_metrics 
            ORDER BY timestamp DESC 
            LIMIT 1
        `).get();

        return {
            data: {
                uptime: process.uptime(),
                memory: latest?.memory_usage || 0,
                cpu: latest?.cpu_usage || 0,
                requests: latest?.request_count || 0,
                timestamp: latest?.timestamp || new Date().toISOString()
            },
            status: 'healthy',
            labels: ['uptime', 'memory', 'cpu', 'requests']
        };
    }

    async generateLogLevelsPieData(widget) {
        const config = JSON.parse(widget.config || '{}');
        const timeRange = config.timeRange || '24h';
        
        const now = new Date();
        const timeRangeMs = this.parseTimeRange(timeRange);
        const startTime = new Date(now.getTime() - timeRangeMs);

        const levelCounts = db.prepare(`
            SELECT level, COUNT(*) as count 
            FROM logs 
            WHERE timestamp >= ? 
            GROUP BY level 
            ORDER BY count DESC
        `).all(startTime.toISOString());

        return {
            data: levelCounts,
            labels: levelCounts.map(item => item.level),
            values: levelCounts.map(item => item.count)
        };
    }

    async generateRealTimeFeedData(widget) {
        const config = JSON.parse(widget.config || '{}');
        const limit = config.limit || 20;

        const recentLogs = db.prepare(`
            SELECT timestamp, level, message, source 
            FROM logs 
            ORDER BY timestamp DESC 
            LIMIT ?
        `).all(limit);

        return {
            data: recentLogs,
            labels: ['timestamp', 'level', 'message', 'source'],
            isLive: true
        };
    }

    parseTimeRange(range) {
        const units = {
            'm': 60 * 1000,
            'h': 60 * 60 * 1000,
            'd': 24 * 60 * 60 * 1000,
            'w': 7 * 24 * 60 * 60 * 1000
        };

        const match = range.match(/^(\d+)([mhdw])$/);
        if (!match) return 60 * 60 * 1000; // Default to 1 hour

        return parseInt(match[1]) * units[match[2]];
    }

    getDashboards(userId = null) {
        const userDashboards = Array.from(this.dashboards.values());
        
        if (userId) {
            return userDashboards.filter(d => 
                d.owner_user_id === userId || d.is_public
            );
        }
        
        return userDashboards;
    }

    getDashboard(dashboardId) {
        return this.dashboards.get(dashboardId);
    }

    getWidgets(dashboardId) {
        return this.widgets.get(dashboardId) || [];
    }

    getWidgetTypes() {
        return this.widgetTypes.map(type => ({
            id: type,
            name: this.formatWidgetTypeName(type),
            category: this.getWidgetCategory(type)
        }));
    }

    formatWidgetTypeName(type) {
        return type.split('_').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
    }

    getWidgetCategory(type) {
        const categories = {
            log_timeline: 'logging',
            log_levels_pie: 'logging',
            real_time_feed: 'logging',
            metrics_chart: 'metrics',
            performance_gauge: 'metrics',
            alert_summary: 'alerting',
            system_status: 'monitoring',
            source_breakdown: 'analytics',
            error_trending: 'analytics',
            correlation_matrix: 'analytics',
            geo_map: 'visualization',
            custom_query: 'custom'
        };
        return categories[type] || 'general';
    }
}

// ============================================================================
// REAL-TIME LOG STREAMING ENGINE
// ============================================================================

class RealTimeStreamingEngine {
    constructor(database) {
        this.db = database;
        this.wsServer = null;
        this.clients = new Map();
        this.subscriptions = new Map();
        this.streamFilters = new Map();
        this.messageBuffer = [];
        this.bufferSize = 1000;
        this.rateLimitMap = new Map();
        this.maxClientsPerIP = 10;
        this.totalMaxClients = 500;
        this.statistics = {
            connectedClients: 0,
            totalMessages: 0,
            filteredMessages: 0,
            bytesTransferred: 0,
            connectionsCount: 0,
            disconnectionsCount: 0
        };
    }

    async initialize() {
        try {
            // Create streaming-related database tables
            await this.createStreamingSchema();
            
            // Initialize WebSocket server
            await this.initializeWebSocketServer();
            
            // Schedule cleanup tasks
            this.scheduleCleanupTasks();
            
            loggers.system.info('Real-time Streaming Engine initialized successfully');
            return true;
        } catch (error) {
            loggers.system.error('Failed to initialize Real-time Streaming Engine:', error);
            return false;
        }
    }

    async createStreamingSchema() {
        const queries = [
            `CREATE TABLE IF NOT EXISTS streaming_sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                client_id TEXT UNIQUE NOT NULL,
                ip_address TEXT NOT NULL,
                user_agent TEXT,
                connected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                disconnected_at DATETIME,
                duration_seconds INTEGER,
                messages_sent INTEGER DEFAULT 0,
                bytes_sent INTEGER DEFAULT 0,
                filter_rules TEXT,
                status TEXT DEFAULT 'active'
            )`,
            `CREATE TABLE IF NOT EXISTS streaming_filters (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                description TEXT,
                filter_criteria TEXT NOT NULL,
                created_by INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                is_public INTEGER DEFAULT 0,
                usage_count INTEGER DEFAULT 0,
                FOREIGN KEY (created_by) REFERENCES users (id)
            )`,
            `CREATE TABLE IF NOT EXISTS streaming_statistics (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                connected_clients INTEGER,
                messages_per_second REAL,
                bytes_per_second REAL,
                average_latency_ms REAL,
                error_count INTEGER DEFAULT 0
            )`
        ];

        for (const query of queries) {
            await this.db.run(query);
        }
    }

    async initializeWebSocketServer() {
        const wsPort = config.integrations.websocket.port || 10181;
        
        this.wsServer = new WebSocket.Server({
            port: wsPort,
            perMessageDeflate: false,
            clientTracking: true,
            maxPayload: 1024 * 1024, // 1MB max message size
            verifyClient: (info) => {
                return this.verifyClient(info);
            }
        });

        this.wsServer.on('connection', (ws, request) => {
            this.handleClientConnection(ws, request);
        });

        this.wsServer.on('error', (error) => {
            loggers.system.error('WebSocket server error:', error);
        });

        loggers.system.info(`Real-time streaming server started on port ${wsPort}`);
    }

    verifyClient(info) {
        const ip = info.req.connection.remoteAddress || info.req.socket.remoteAddress;
        
        // Check rate limiting per IP
        const now = Date.now();
        if (!this.rateLimitMap.has(ip)) {
            this.rateLimitMap.set(ip, { connections: 0, lastReset: now });
        }
        
        const ipData = this.rateLimitMap.get(ip);
        
        // Reset counter every minute
        if (now - ipData.lastReset > 60000) {
            ipData.connections = 0;
            ipData.lastReset = now;
        }
        
        // Check per-IP client limit
        if (ipData.connections >= this.maxClientsPerIP) {
            loggers.security.warn(`WebSocket connection rejected - IP limit exceeded: ${ip}`);
            return false;
        }
        
        // Check total client limit
        if (this.wsServer.clients.size >= this.totalMaxClients) {
            loggers.security.warn(`WebSocket connection rejected - Total client limit exceeded`);
            return false;
        }
        
        return true;
    }

    handleClientConnection(ws, request) {
        const clientId = this.generateClientId();
        const ip = request.connection.remoteAddress || request.socket.remoteAddress;
        const userAgent = request.headers['user-agent'] || 'Unknown';
        
        // Update rate limiting
        const ipData = this.rateLimitMap.get(ip);
        if (ipData) ipData.connections++;
        
        // Initialize client data
        const clientData = {
            id: clientId,
            ip: ip,
            userAgent: userAgent,
            connectedAt: new Date(),
            messagesSent: 0,
            bytesSent: 0,
            filters: [],
            subscriptions: new Set()
        };
        
        this.clients.set(clientId, clientData);
        this.statistics.connectedClients++;
        this.statistics.connectionsCount++;

        // Store session in database
        this.createStreamingSession(clientData);

        // Set up message handlers
        ws.on('message', (data) => {
            this.handleClientMessage(clientId, data);
        });

        ws.on('close', (code, reason) => {
            this.handleClientDisconnection(clientId, code, reason);
        });

        ws.on('error', (error) => {
            loggers.system.error(`WebSocket client error for ${clientId}:`, error);
            this.handleClientDisconnection(clientId, 1006, 'Client error');
        });

        // Store WebSocket reference
        ws.clientId = clientId;
        
        // Send welcome message
        this.sendToClient(clientId, {
            type: 'connection',
            status: 'connected',
            clientId: clientId,
            serverTime: new Date().toISOString(),
            capabilities: ['filtering', 'subscriptions', 'buffering']
        });

        loggers.system.info(`WebSocket client connected: ${clientId} from ${ip}`);
    }

    generateClientId() {
        return `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    async createStreamingSession(clientData) {
        try {
            await this.db.run(`
                INSERT INTO streaming_sessions (
                    client_id, ip_address, user_agent, connected_at
                ) VALUES (?, ?, ?, ?)
            `, [clientData.id, clientData.ip, clientData.userAgent, clientData.connectedAt.toISOString()]);
        } catch (error) {
            loggers.system.error('Failed to create streaming session:', error);
        }
    }

    handleClientMessage(clientId, data) {
        try {
            const message = JSON.parse(data.toString());
            const client = this.clients.get(clientId);
            
            if (!client) return;

            switch (message.type) {
                case 'subscribe':
                    this.handleSubscription(clientId, message);
                    break;
                case 'unsubscribe':
                    this.handleUnsubscription(clientId, message);
                    break;
                case 'filter':
                    this.handleFilterUpdate(clientId, message);
                    break;
                case 'ping':
                    this.sendToClient(clientId, { type: 'pong', timestamp: new Date().toISOString() });
                    break;
                case 'buffer_request':
                    this.sendBufferedMessages(clientId, message.count || 50);
                    break;
                default:
                    loggers.system.warn(`Unknown message type from ${clientId}: ${message.type}`);
            }
        } catch (error) {
            loggers.system.error(`Error handling message from ${clientId}:`, error);
            this.sendToClient(clientId, {
                type: 'error',
                message: 'Invalid message format',
                timestamp: new Date().toISOString()
            });
        }
    }

    handleSubscription(clientId, message) {
        const client = this.clients.get(clientId);
        if (!client) return;

        const subscription = {
            id: message.subscription_id || this.generateSubscriptionId(),
            channels: message.channels || ['logs'],
            filters: message.filters || {},
            throttle: message.throttle || 0 // milliseconds
        };

        client.subscriptions.add(subscription.id);
        this.subscriptions.set(subscription.id, { clientId, ...subscription });

        this.sendToClient(clientId, {
            type: 'subscription_confirmed',
            subscription_id: subscription.id,
            channels: subscription.channels,
            timestamp: new Date().toISOString()
        });

        loggers.system.info(`Client ${clientId} subscribed to channels: ${subscription.channels.join(', ')}`);
    }

    handleUnsubscription(clientId, message) {
        const client = this.clients.get(clientId);
        if (!client) return;

        const subscriptionId = message.subscription_id;
        client.subscriptions.delete(subscriptionId);
        this.subscriptions.delete(subscriptionId);

        this.sendToClient(clientId, {
            type: 'unsubscription_confirmed',
            subscription_id: subscriptionId,
            timestamp: new Date().toISOString()
        });

        loggers.system.info(`Client ${clientId} unsubscribed from ${subscriptionId}`);
    }

    handleFilterUpdate(clientId, message) {
        const client = this.clients.get(clientId);
        if (!client) return;

        client.filters = message.filters || [];

        this.sendToClient(clientId, {
            type: 'filter_updated',
            filters: client.filters,
            timestamp: new Date().toISOString()
        });

        loggers.system.info(`Client ${clientId} updated filters`);
    }

    generateSubscriptionId() {
        return `sub_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    }

    handleClientDisconnection(clientId, code, reason) {
        const client = this.clients.get(clientId);
        if (!client) return;

        const disconnectedAt = new Date();
        const duration = Math.floor((disconnectedAt - client.connectedAt) / 1000);

        // Update statistics
        this.statistics.connectedClients--;
        this.statistics.disconnectionsCount++;

        // Clean up subscriptions
        for (const subscriptionId of client.subscriptions) {
            this.subscriptions.delete(subscriptionId);
        }

        // Update rate limiting
        const ipData = this.rateLimitMap.get(client.ip);
        if (ipData) ipData.connections = Math.max(0, ipData.connections - 1);

        // Update database session
        this.updateStreamingSession(client, disconnectedAt, duration);

        // Remove client
        this.clients.delete(clientId);

        loggers.system.info(`WebSocket client disconnected: ${clientId} (duration: ${duration}s, code: ${code})`);
    }

    async updateStreamingSession(client, disconnectedAt, duration) {
        try {
            await this.db.run(`
                UPDATE streaming_sessions 
                SET disconnected_at = ?, 
                    duration_seconds = ?,
                    messages_sent = ?,
                    bytes_sent = ?,
                    status = 'disconnected'
                WHERE client_id = ?
            `, [
                disconnectedAt.toISOString(),
                duration,
                client.messagesSent,
                client.bytesSent,
                client.id
            ]);
        } catch (error) {
            loggers.system.error('Failed to update streaming session:', error);
        }
    }

    broadcastLogEvent(logEvent) {
        // Add to buffer
        this.messageBuffer.push({
            ...logEvent,
            timestamp: new Date().toISOString(),
            stream_id: this.generateStreamId()
        });

        // Maintain buffer size
        if (this.messageBuffer.length > this.bufferSize) {
            this.messageBuffer = this.messageBuffer.slice(-this.bufferSize);
        }

        // Broadcast to subscribed clients
        const message = {
            type: 'log_event',
            data: logEvent,
            timestamp: new Date().toISOString()
        };

        let sentCount = 0;
        let filteredCount = 0;

        for (const [subscriptionId, subscription] of this.subscriptions) {
            const client = this.clients.get(subscription.clientId);
            if (!client) continue;

            // Check channel subscription
            if (!subscription.channels.includes('logs') && !subscription.channels.includes('all')) {
                continue;
            }

            // Apply filters
            if (!this.matchesFilters(logEvent, subscription.filters, client.filters)) {
                filteredCount++;
                continue;
            }

            // Send to client
            if (this.sendToClient(subscription.clientId, message)) {
                sentCount++;
            }
        }

        // Update statistics
        this.statistics.totalMessages++;
        this.statistics.filteredMessages += filteredCount;

        return { sent: sentCount, filtered: filteredCount };
    }

    matchesFilters(logEvent, subscriptionFilters, clientFilters) {
        // Combine subscription and client filters
        const allFilters = [...(subscriptionFilters || []), ...(clientFilters || [])];
        
        if (allFilters.length === 0) return true;

        for (const filter of allFilters) {
            if (!this.matchesFilter(logEvent, filter)) {
                return false;
            }
        }

        return true;
    }

    matchesFilter(logEvent, filter) {
        try {
            switch (filter.type) {
                case 'level':
                    return this.matchesLevelFilter(logEvent.severity || logEvent.level, filter.value);
                case 'source':
                    return this.matchesStringFilter(logEvent.source, filter.value, filter.operator);
                case 'message':
                    return this.matchesStringFilter(logEvent.message, filter.value, filter.operator);
                case 'timerange':
                    return this.matchesTimeRange(logEvent.timestamp, filter.from, filter.to);
                case 'custom':
                    return this.matchesCustomFilter(logEvent, filter.expression);
                default:
                    return true;
            }
        } catch (error) {
            loggers.system.error('Filter matching error:', error);
            return true; // Default to allowing the message
        }
    }

    matchesLevelFilter(logLevel, filterLevel) {
        const levels = ['debug', 'info', 'warn', 'error', 'critical'];
        const logIndex = levels.indexOf(logLevel?.toLowerCase());
        const filterIndex = levels.indexOf(filterLevel?.toLowerCase());
        return logIndex >= filterIndex;
    }

    matchesStringFilter(value, filterValue, operator = 'contains') {
        if (!value || !filterValue) return false;
        
        const str = value.toString().toLowerCase();
        const filter = filterValue.toString().toLowerCase();
        
        switch (operator) {
            case 'equals':
                return str === filter;
            case 'contains':
                return str.includes(filter);
            case 'starts_with':
                return str.startsWith(filter);
            case 'ends_with':
                return str.endsWith(filter);
            case 'regex':
                try {
                    return new RegExp(filter, 'i').test(str);
                } catch {
                    return false;
                }
            default:
                return str.includes(filter);
        }
    }

    matchesTimeRange(timestamp, from, to) {
        if (!timestamp) return false;
        
        const time = new Date(timestamp).getTime();
        const fromTime = from ? new Date(from).getTime() : 0;
        const toTime = to ? new Date(to).getTime() : Date.now();
        
        return time >= fromTime && time <= toTime;
    }

    matchesCustomFilter(logEvent, expression) {
        try {
            // Simple expression evaluation for basic custom filters
            // This could be expanded with a proper expression parser
            return Function('event', `return ${expression}`)(logEvent);
        } catch (error) {
            loggers.system.error('Custom filter evaluation error:', error);
            return false;
        }
    }

    generateStreamId() {
        return `stream_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    }

    sendToClient(clientId, message) {
        const client = this.clients.get(clientId);
        if (!client) return false;

        try {
            // Find the WebSocket connection
            let ws = null;
            for (const wsClient of this.wsServer.clients) {
                if (wsClient.clientId === clientId && wsClient.readyState === WebSocket.OPEN) {
                    ws = wsClient;
                    break;
                }
            }

            if (!ws) return false;

            const messageStr = JSON.stringify(message);
            const messageSize = Buffer.byteLength(messageStr, 'utf8');

            ws.send(messageStr);

            // Update client statistics
            client.messagesSent++;
            client.bytesSent += messageSize;
            this.statistics.bytesTransferred += messageSize;

            return true;
        } catch (error) {
            loggers.system.error(`Error sending message to client ${clientId}:`, error);
            return false;
        }
    }

    sendBufferedMessages(clientId, count = 50) {
        const client = this.clients.get(clientId);
        if (!client) return;

        const messages = this.messageBuffer.slice(-Math.min(count, this.bufferSize));
        
        this.sendToClient(clientId, {
            type: 'buffered_messages',
            messages: messages,
            count: messages.length,
            timestamp: new Date().toISOString()
        });
    }

    scheduleCleanupTasks() {
        // Clean up old sessions every hour
        setInterval(async () => {
            await this.cleanupOldSessions();
        }, 60 * 60 * 1000);

        // Update statistics every minute
        setInterval(async () => {
            await this.updateStatistics();
        }, 60 * 1000);

        // Clean up rate limiting data every 5 minutes
        setInterval(() => {
            this.cleanupRateLimiting();
        }, 5 * 60 * 1000);
    }

    async cleanupOldSessions() {
        try {
            // Delete sessions older than 30 days
            await this.db.run(`
                DELETE FROM streaming_sessions 
                WHERE connected_at < datetime('now', '-30 days')
            `);

            // Delete old statistics older than 7 days
            await this.db.run(`
                DELETE FROM streaming_statistics 
                WHERE timestamp < datetime('now', '-7 days')
            `);

            loggers.system.info('Cleaned up old streaming sessions and statistics');
        } catch (error) {
            loggers.system.error('Failed to cleanup old streaming data:', error);
        }
    }

    async updateStatistics() {
        try {
            const connectedClients = this.statistics.connectedClients;
            const messagesPerSecond = this.statistics.totalMessages / 60; // Rough calculation
            const bytesPerSecond = this.statistics.bytesTransferred / 60;

            await this.db.run(`
                INSERT INTO streaming_statistics (
                    connected_clients, messages_per_second, bytes_per_second
                ) VALUES (?, ?, ?)
            `, [connectedClients, messagesPerSecond, bytesPerSecond]);

            // Reset counters for next interval
            this.statistics.totalMessages = 0;
            this.statistics.bytesTransferred = 0;

        } catch (error) {
            loggers.system.error('Failed to update streaming statistics:', error);
        }
    }

    cleanupRateLimiting() {
        const now = Date.now();
        for (const [ip, data] of this.rateLimitMap) {
            if (now - data.lastReset > 300000) { // 5 minutes
                this.rateLimitMap.delete(ip);
            }
        }
    }

    async getStreamingStatistics() {
        try {
            const currentStats = {
                connectedClients: this.statistics.connectedClients,
                totalConnections: this.statistics.connectionsCount,
                totalDisconnections: this.statistics.disconnectionsCount,
                activeSubscriptions: this.subscriptions.size,
                bufferedMessages: this.messageBuffer.length,
                rateLimitedIPs: this.rateLimitMap.size
            };

            const recentStats = await this.db.all(`
                SELECT * FROM streaming_statistics 
                WHERE timestamp > datetime('now', '-24 hours')
                ORDER BY timestamp DESC
                LIMIT 100
            `);

            const activeSessions = await this.db.all(`
                SELECT * FROM streaming_sessions 
                WHERE status = 'active'
                ORDER BY connected_at DESC
            `);

            return {
                current: currentStats,
                recent: recentStats,
                activeSessions,
                serverInfo: {
                    port: this.wsServer ? this.wsServer.options.port : null,
                    maxClients: this.totalMaxClients,
                    maxClientsPerIP: this.maxClientsPerIP,
                    bufferSize: this.bufferSize
                }
            };
        } catch (error) {
            loggers.system.error('Failed to get streaming statistics:', error);
            return null;
        }
    }

    async createStreamingFilter(filterData) {
        try {
            const result = await this.db.run(`
                INSERT INTO streaming_filters (
                    name, description, filter_criteria, created_by, is_public
                ) VALUES (?, ?, ?, ?, ?)
            `, [
                filterData.name,
                filterData.description,
                JSON.stringify(filterData.criteria),
                filterData.created_by,
                filterData.is_public ? 1 : 0
            ]);

            return { success: true, id: result.lastID };
        } catch (error) {
            loggers.system.error('Failed to create streaming filter:', error);
            return { success: false, error: error.message };
        }
    }

    async getStreamingFilters(userId = null) {
        try {
            let query = `
                SELECT * FROM streaming_filters 
                WHERE is_public = 1
            `;
            let params = [];

            if (userId) {
                query += ` OR created_by = ?`;
                params.push(userId);
            }

            query += ` ORDER BY name`;

            const filters = await this.db.all(query, params);
            return filters.map(filter => ({
                ...filter,
                filter_criteria: JSON.parse(filter.filter_criteria)
            }));
        } catch (error) {
            loggers.system.error('Failed to get streaming filters:', error);
            return [];
        }
    }

    shutdown() {
        if (this.wsServer) {
            // Notify all clients of shutdown
            for (const [clientId] of this.clients) {
                this.sendToClient(clientId, {
                    type: 'server_shutdown',
                    message: 'Server is shutting down',
                    timestamp: new Date().toISOString()
                });
            }

            // Close all connections
            this.wsServer.close(() => {
                loggers.system.info('Real-time streaming server shut down');
            });
        }
    }
}

// ============================================================================
// AI-POWERED ANOMALY DETECTION ENGINE
// ============================================================================

class AnomalyDetectionEngine {
    constructor(database) {
        this.db = database;
        this.models = new Map();
        this.trainingData = [];
        this.anomalyThresholds = new Map();
        this.detectionRules = new Map();
        this.recentAnomalies = [];
        this.patternCache = new Map();
        this.isTraining = false;
        this.lastTrainingTime = null;
        this.statistics = {
            totalAnalyzed: 0,
            anomaliesDetected: 0,
            falsePositives: 0,
            modelAccuracy: 0,
            trainingIterations: 0
        };
    }

    async initialize() {
        try {
            // Create anomaly detection schema
            await this.createAnomalySchema();
            
            // Create correlation schema
            await this.createCorrelationSchema();
            
            // Load existing models and rules
            await this.loadDetectionRules();
            await this.loadAnomalyThresholds();
            
            // Initialize default detection rules
            await this.createDefaultDetectionRules();
            
            // Schedule training and analysis tasks
            this.scheduleAnalysisTasks();
            
            loggers.system.info('AI-Powered Anomaly Detection Engine initialized successfully');
            return true;
        } catch (error) {
            loggers.system.error('Failed to initialize Anomaly Detection Engine:', error);
            return false;
        }
    }

    async createAnomalySchema() {
        const queries = [
            `CREATE TABLE IF NOT EXISTS anomaly_detections (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                log_id INTEGER,
                anomaly_type TEXT NOT NULL,
                severity TEXT DEFAULT 'medium',
                confidence_score REAL DEFAULT 0,
                description TEXT,
                pattern_data TEXT,
                context_data TEXT,
                resolved INTEGER DEFAULT 0,
                resolved_at DATETIME,
                resolved_by INTEGER,
                false_positive INTEGER DEFAULT 0,
                feedback_provided INTEGER DEFAULT 0,
                FOREIGN KEY (log_id) REFERENCES logs (id),
                FOREIGN KEY (resolved_by) REFERENCES users (id)
            )`,
            `CREATE TABLE IF NOT EXISTS anomaly_rules (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                description TEXT,
                rule_type TEXT NOT NULL,
                parameters TEXT NOT NULL,
                enabled INTEGER DEFAULT 1,
                confidence_threshold REAL DEFAULT 0.7,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                usage_count INTEGER DEFAULT 0,
                accuracy_rating REAL DEFAULT 0
            )`,
            `CREATE TABLE IF NOT EXISTS anomaly_patterns (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                pattern_type TEXT NOT NULL,
                pattern_signature TEXT NOT NULL,
                frequency_normal REAL DEFAULT 0,
                frequency_threshold REAL DEFAULT 0,
                first_seen DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_seen DATETIME DEFAULT CURRENT_TIMESTAMP,
                occurrence_count INTEGER DEFAULT 1,
                is_baseline INTEGER DEFAULT 0
            )`,
            `CREATE TABLE IF NOT EXISTS anomaly_training_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                feature_vector TEXT NOT NULL,
                label TEXT NOT NULL,
                weight REAL DEFAULT 1.0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                source_type TEXT DEFAULT 'automatic'
            )`,
            `CREATE TABLE IF NOT EXISTS anomaly_models (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                model_name TEXT UNIQUE NOT NULL,
                model_type TEXT NOT NULL,
                model_data TEXT NOT NULL,
                training_date DATETIME DEFAULT CURRENT_TIMESTAMP,
                accuracy_score REAL DEFAULT 0,
                validation_score REAL DEFAULT 0,
                parameters TEXT,
                is_active INTEGER DEFAULT 1
            )`
        ];

        for (const query of queries) {
            await this.db.run(query);
        }
    }

    async createCorrelationSchema() {
        const queries = [
            `CREATE TABLE IF NOT EXISTS log_correlations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                rule_id TEXT NOT NULL,
                rule_name TEXT NOT NULL,
                pattern_type TEXT NOT NULL,
                severity TEXT DEFAULT 'medium',
                event_count INTEGER DEFAULT 0,
                time_window INTEGER DEFAULT 300,
                confidence_score REAL DEFAULT 0,
                threshold_value REAL DEFAULT 0,
                detected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                first_event_time DATETIME,
                last_event_time DATETIME,
                events_json TEXT,
                alert_triggered INTEGER DEFAULT 0,
                alert_sent_at DATETIME,
                resolved INTEGER DEFAULT 0,
                resolved_at DATETIME,
                resolved_by TEXT,
                notes TEXT
            )`,
            `CREATE TABLE IF NOT EXISTS correlation_rules (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                pattern_type TEXT NOT NULL,
                conditions TEXT NOT NULL,
                time_window INTEGER DEFAULT 300,
                threshold INTEGER DEFAULT 5,
                severity TEXT DEFAULT 'medium',
                enabled INTEGER DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_triggered DATETIME,
                trigger_count INTEGER DEFAULT 0
            )`,
            `CREATE TABLE IF NOT EXISTS correlation_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                correlation_id INTEGER NOT NULL,
                log_id INTEGER NOT NULL,
                event_timestamp DATETIME NOT NULL,
                event_data TEXT,
                matched_pattern TEXT,
                FOREIGN KEY (correlation_id) REFERENCES log_correlations (id),
                FOREIGN KEY (log_id) REFERENCES logs (id)
            )`
        ];

        for (const query of queries) {
            await this.db.run(query);
        }
    }

    async loadDetectionRules() {
        try {
            const rules = await this.db.all(`
                SELECT * FROM anomaly_rules 
                WHERE enabled = 1 
                ORDER BY name
            `);

            this.detectionRules.clear();
            for (const rule of rules) {
                this.detectionRules.set(rule.id, {
                    ...rule,
                    parameters: JSON.parse(rule.parameters)
                });
            }

            loggers.system.info(`Loaded ${rules.length} anomaly detection rules`);
        } catch (error) {
            loggers.system.error('Failed to load detection rules:', error);
        }
    }

    async loadAnomalyThresholds() {
        try {
            const patterns = await this.db.all(`
                SELECT * FROM anomaly_patterns 
                WHERE is_baseline = 1
            `);

            this.anomalyThresholds.clear();
            for (const pattern of patterns) {
                this.anomalyThresholds.set(pattern.pattern_signature, pattern);
            }

            loggers.system.info(`Loaded ${patterns.length} baseline patterns`);
        } catch (error) {
            loggers.system.error('Failed to load anomaly thresholds:', error);
        }
    }

    async createDefaultDetectionRules() {
        try {
            const existingRules = await this.db.get('SELECT COUNT(*) as count FROM anomaly_rules');
            if (existingRules.count > 0) return;

            const defaultRules = [
                {
                    name: 'High Error Rate Spike',
                    description: 'Detects sudden spikes in error log frequency',
                    rule_type: 'frequency_spike',
                    parameters: {
                        log_level: 'error',
                        time_window: 300, // 5 minutes
                        spike_threshold: 3.0, // 3x normal rate
                        minimum_count: 5
                    },
                    confidence_threshold: 0.8
                },
                {
                    name: 'Unusual Source Pattern',
                    description: 'Detects logs from unusual or new sources',
                    rule_type: 'source_anomaly',
                    parameters: {
                        min_confidence: 0.7,
                        learning_period_days: 7,
                        new_source_threshold: 0.9
                    },
                    confidence_threshold: 0.7
                },
                {
                    name: 'Message Content Anomaly',
                    description: 'Detects unusual patterns in log message content',
                    rule_type: 'content_anomaly',
                    parameters: {
                        similarity_threshold: 0.3,
                        min_message_length: 10,
                        pattern_window: 1000 // messages
                    },
                    confidence_threshold: 0.75
                },
                {
                    name: 'Time Series Anomaly',
                    description: 'Detects anomalies in log timing patterns',
                    rule_type: 'temporal_anomaly',
                    parameters: {
                        time_buckets: 24, // hourly buckets
                        deviation_threshold: 2.0, // 2 standard deviations
                        min_history_days: 3
                    },
                    confidence_threshold: 0.8
                },
                {
                    name: 'Security Event Clustering',
                    description: 'Detects potential security incidents through event clustering',
                    rule_type: 'security_cluster',
                    parameters: {
                        cluster_window: 600, // 10 minutes
                        security_keywords: ['failed', 'unauthorized', 'denied', 'blocked', 'attack'],
                        cluster_threshold: 5,
                        confidence_boost: 1.2
                    },
                    confidence_threshold: 0.85
                }
            ];

            for (const rule of defaultRules) {
                await this.db.run(`
                    INSERT INTO anomaly_rules (
                        name, description, rule_type, parameters, confidence_threshold
                    ) VALUES (?, ?, ?, ?, ?)
                `, [
                    rule.name,
                    rule.description,
                    rule.rule_type,
                    JSON.stringify(rule.parameters),
                    rule.confidence_threshold
                ]);
            }

            await this.loadDetectionRules();
            loggers.system.info('Created default anomaly detection rules');
        } catch (error) {
            loggers.system.error('Failed to create default detection rules:', error);
        }
    }

    async analyzeLogEvent(logEvent) {
        try {
            this.statistics.totalAnalyzed++;

            // Extract features from log event
            const features = this.extractFeatures(logEvent);
            
            // Run through all detection rules
            const anomalies = [];
            for (const [ruleId, rule] of this.detectionRules) {
                const result = await this.evaluateRule(rule, logEvent, features);
                if (result.isAnomaly) {
                    anomalies.push({
                        ruleId,
                        rule,
                        ...result
                    });
                }
            }

            // Process detected anomalies
            for (const anomaly of anomalies) {
                await this.processAnomaly(logEvent, anomaly);
            }

            return {
                analyzed: true,
                anomaliesFound: anomalies.length,
                anomalies: anomalies.map(a => ({
                    type: a.rule.rule_type,
                    confidence: a.confidence,
                    description: a.description
                }))
            };

        } catch (error) {
            loggers.system.error('Error analyzing log event:', error);
            return { analyzed: false, error: error.message };
        }
    }

    extractFeatures(logEvent) {
        const features = {};

        // Basic features
        features.timestamp = new Date(logEvent.timestamp).getTime();
        features.hour = new Date(logEvent.timestamp).getHours();
        features.dayOfWeek = new Date(logEvent.timestamp).getDay();
        features.severity = this.encodeSeverity(logEvent.severity || logEvent.level);
        features.sourceHash = this.hashString(logEvent.source || 'unknown');
        features.messageLength = (logEvent.message || '').length;

        // Text features
        const message = logEvent.message || '';
        features.hasNumbers = /\d/.test(message);
        features.hasSpecialChars = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(message);
        features.wordCount = message.split(/\s+/).length;
        features.upperCaseRatio = (message.match(/[A-Z]/g) || []).length / message.length;

        // Pattern features
        features.containsIP = /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/.test(message);
        features.containsURL = /(https?:\/\/[^\s]+)/.test(message);
        features.containsEmail = /[^\s@]+@[^\s@]+\.[^\s@]+/.test(message);

        // Security-related features
        const securityKeywords = ['error', 'failed', 'denied', 'unauthorized', 'blocked', 'attack', 'malware', 'virus'];
        features.securityScore = securityKeywords.reduce((score, keyword) => {
            return score + (message.toLowerCase().includes(keyword) ? 1 : 0);
        }, 0) / securityKeywords.length;

        return features;
    }

    encodeSeverity(severity) {
        const severityMap = {
            'debug': 0,
            'info': 1,
            'warn': 2,
            'warning': 2,
            'error': 3,
            'critical': 4,
            'fatal': 5
        };
        return severityMap[severity?.toLowerCase()] || 1;
    }

    hashString(str) {
        let hash = 0;
        if (str.length === 0) return hash;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return Math.abs(hash) % 10000; // Normalize to 0-9999
    }

    async evaluateRule(rule, logEvent, features) {
        try {
            switch (rule.rule_type) {
                case 'frequency_spike':
                    return await this.evaluateFrequencySpike(rule, logEvent, features);
                case 'source_anomaly':
                    return await this.evaluateSourceAnomaly(rule, logEvent, features);
                case 'content_anomaly':
                    return await this.evaluateContentAnomaly(rule, logEvent, features);
                case 'temporal_anomaly':
                    return await this.evaluateTemporalAnomaly(rule, logEvent, features);
                case 'security_cluster':
                    return await this.evaluateSecurityCluster(rule, logEvent, features);
                default:
                    return { isAnomaly: false, confidence: 0, description: 'Unknown rule type' };
            }
        } catch (error) {
            loggers.system.error(`Error evaluating rule ${rule.name}:`, error);
            return { isAnomaly: false, confidence: 0, description: 'Evaluation error' };
        }
    }

    async evaluateFrequencySpike(rule, logEvent, features) {
        const params = rule.parameters;
        const targetLevel = logEvent.severity || logEvent.level;
        
        if (targetLevel !== params.log_level) {
            return { isAnomaly: false, confidence: 0 };
        }

        // Get recent count within time window
        const cutoffTime = new Date(Date.now() - params.time_window * 1000);
        const recentCount = await this.db.get(`
            SELECT COUNT(*) as count 
            FROM logs 
            WHERE timestamp > ? AND (severity = ? OR level = ?)
        `, [cutoffTime.toISOString(), params.log_level, params.log_level]);

        if (recentCount.count < params.minimum_count) {
            return { isAnomaly: false, confidence: 0 };
        }

        // Get historical average for same time period
        const historicalAvg = await this.getHistoricalAverage(params.log_level, params.time_window);
        
        const spikeRatio = recentCount.count / Math.max(historicalAvg, 1);
        
        if (spikeRatio >= params.spike_threshold) {
            const confidence = Math.min(0.9, 0.5 + (spikeRatio - params.spike_threshold) * 0.1);
            return {
                isAnomaly: true,
                confidence,
                description: `${params.log_level} frequency spike: ${recentCount.count} events (${spikeRatio.toFixed(1)}x normal)`
            };
        }

        return { isAnomaly: false, confidence: 0 };
    }

    async evaluateSourceAnomaly(rule, logEvent, features) {
        const params = rule.parameters;
        const source = logEvent.source || 'unknown';
        
        // Check if source is in baseline patterns
        const sourcePattern = await this.db.get(`
            SELECT * FROM anomaly_patterns 
            WHERE pattern_type = 'source' AND pattern_signature = ?
        `, [source]);

        if (!sourcePattern) {
            // New source detected
            const confidence = params.new_source_threshold || 0.8;
            
            // Store new pattern
            await this.db.run(`
                INSERT INTO anomaly_patterns (
                    pattern_type, pattern_signature, frequency_normal
                ) VALUES (?, ?, ?)
            `, ['source', source, 1]);

            return {
                isAnomaly: true,
                confidence,
                description: `New log source detected: ${source}`
            };
        }

        // Check if source frequency is unusual
        const recentActivity = await this.db.get(`
            SELECT COUNT(*) as count 
            FROM logs 
            WHERE source = ? AND timestamp > datetime('now', '-1 hour')
        `, [source]);

        const expectedFrequency = sourcePattern.frequency_normal;
        const actualFrequency = recentActivity.count;
        
        if (expectedFrequency > 0) {
            const deviationRatio = Math.abs(actualFrequency - expectedFrequency) / expectedFrequency;
            
            if (deviationRatio > 2.0) { // Significant deviation
                const confidence = Math.min(0.9, params.min_confidence + deviationRatio * 0.1);
                return {
                    isAnomaly: true,
                    confidence,
                    description: `Unusual activity from source ${source}: ${actualFrequency} vs expected ${expectedFrequency}`
                };
            }
        }

        return { isAnomaly: false, confidence: 0 };
    }

    async evaluateContentAnomaly(rule, logEvent, features) {
        const params = rule.parameters;
        const message = logEvent.message || '';
        
        if (message.length < params.min_message_length) {
            return { isAnomaly: false, confidence: 0 };
        }

        // Get recent similar messages for comparison
        const recentMessages = await this.db.all(`
            SELECT message FROM logs 
            WHERE timestamp > datetime('now', '-1 hour')
            ORDER BY timestamp DESC 
            LIMIT ?
        `, [params.pattern_window]);

        // Calculate similarity scores
        let maxSimilarity = 0;
        for (const recentMsg of recentMessages) {
            const similarity = this.calculateMessageSimilarity(message, recentMsg.message);
            maxSimilarity = Math.max(maxSimilarity, similarity);
        }

        if (maxSimilarity < params.similarity_threshold) {
            const confidence = 0.6 + (params.similarity_threshold - maxSimilarity) * 0.5;
            return {
                isAnomaly: true,
                confidence: Math.min(0.95, confidence),
                description: `Unusual message pattern detected (similarity: ${maxSimilarity.toFixed(2)})`
            };
        }

        return { isAnomaly: false, confidence: 0 };
    }

    async evaluateTemporalAnomaly(rule, logEvent, features) {
        const params = rule.parameters;
        const currentHour = features.hour;
        
        // Get historical activity for this hour
        const historicalData = await this.db.all(`
            SELECT COUNT(*) as count, 
                   strftime('%H', timestamp) as hour
            FROM logs 
            WHERE timestamp > datetime('now', '-${params.min_history_days} days')
            GROUP BY strftime('%H', timestamp)
        `);

        const hourlyStats = historicalData.reduce((acc, row) => {
            acc[parseInt(row.hour)] = row.count;
            return acc;
        }, {});

        const expectedCount = hourlyStats[currentHour] || 0;
        
        // Get current hour activity
        const currentActivity = await this.db.get(`
            SELECT COUNT(*) as count 
            FROM logs 
            WHERE strftime('%H', timestamp) = ?
            AND date(timestamp) = date('now')
        `, [currentHour.toString().padStart(2, '0')]);

        const actualCount = currentActivity.count;
        
        if (expectedCount > 0) {
            const deviation = Math.abs(actualCount - expectedCount) / expectedCount;
            
            if (deviation >= params.deviation_threshold) {
                const confidence = Math.min(0.9, 0.5 + deviation * 0.2);
                return {
                    isAnomaly: true,
                    confidence,
                    description: `Temporal anomaly at hour ${currentHour}: ${actualCount} vs expected ${expectedCount}`
                };
            }
        }

        return { isAnomaly: false, confidence: 0 };
    }

    async evaluateSecurityCluster(rule, logEvent, features) {
        const params = rule.parameters;
        const message = (logEvent.message || '').toLowerCase();
        
        // Check if message contains security keywords
        const hasSecurityKeywords = params.security_keywords.some(keyword => 
            message.includes(keyword)
        );

        if (!hasSecurityKeywords) {
            return { isAnomaly: false, confidence: 0 };
        }

        // Look for clustering of security events
        const cutoffTime = new Date(Date.now() - params.cluster_window * 1000);
        const securityEvents = await this.db.get(`
            SELECT COUNT(*) as count 
            FROM logs 
            WHERE timestamp > ?
            AND (${params.security_keywords.map(() => 'LOWER(message) LIKE ?').join(' OR ')})
        `, [
            cutoffTime.toISOString(),
            ...params.security_keywords.map(keyword => `%${keyword}%`)
        ]);

        if (securityEvents.count >= params.cluster_threshold) {
            const confidence = Math.min(0.95, 
                rule.confidence_threshold * params.confidence_boost * 
                (securityEvents.count / params.cluster_threshold)
            );

            return {
                isAnomaly: true,
                confidence,
                description: `Security event cluster detected: ${securityEvents.count} events in ${params.cluster_window}s`
            };
        }

        return { isAnomaly: false, confidence: 0 };
    }

    calculateMessageSimilarity(message1, message2) {
        // Simple Jaccard similarity based on word sets
        const words1 = new Set(message1.toLowerCase().split(/\s+/));
        const words2 = new Set(message2.toLowerCase().split(/\s+/));
        
        const intersection = new Set([...words1].filter(x => words2.has(x)));
        const union = new Set([...words1, ...words2]);
        
        return intersection.size / union.size;
    }

    async getHistoricalAverage(level, timeWindow) {
        try {
            const result = await this.db.get(`
                SELECT AVG(hourly_count) as avg_count
                FROM (
                    SELECT COUNT(*) as hourly_count
                    FROM logs 
                    WHERE (severity = ? OR level = ?)
                    AND timestamp > datetime('now', '-7 days')
                    AND timestamp <= datetime('now', '-1 day')
                    GROUP BY strftime('%Y-%m-%d %H', timestamp)
                ) hourly_data
            `, [level, level]);

            return result?.avg_count || 1;
        } catch (error) {
            loggers.system.error('Error getting historical average:', error);
            return 1;
        }
    }

    async processAnomaly(logEvent, anomalyResult) {
        try {
            // Store anomaly detection
            const anomalyId = await this.db.run(`
                INSERT INTO anomaly_detections (
                    log_id, anomaly_type, severity, confidence_score,
                    description, pattern_data, context_data
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
            `, [
                logEvent.id,
                anomalyResult.rule.rule_type,
                this.getSeverityFromConfidence(anomalyResult.confidence),
                anomalyResult.confidence,
                anomalyResult.description,
                JSON.stringify(anomalyResult.pattern || {}),
                JSON.stringify({ features: this.extractFeatures(logEvent) })
            ]);

            // Update statistics
            this.statistics.anomaliesDetected++;
            
            // Update rule usage
            await this.db.run(`
                UPDATE anomaly_rules 
                SET usage_count = usage_count + 1
                WHERE id = ?
            `, [anomalyResult.ruleId]);

            // Add to recent anomalies for tracking
            this.recentAnomalies.push({
                id: anomalyId.lastID,
                timestamp: new Date(),
                type: anomalyResult.rule.rule_type,
                confidence: anomalyResult.confidence,
                description: anomalyResult.description
            });

            // Keep only recent anomalies (last 100)
            if (this.recentAnomalies.length > 100) {
                this.recentAnomalies = this.recentAnomalies.slice(-100);
            }

            // Trigger alert if confidence is high enough
            if (anomalyResult.confidence >= 0.8 && alertingEngine) {
                const alertEvent = {
                    ...logEvent,
                    anomaly_detected: true,
                    anomaly_confidence: anomalyResult.confidence,
                    anomaly_description: anomalyResult.description
                };
                
                await alertingEngine.processLogEvent(alertEvent);
            }

            loggers.system.info(`Anomaly detected: ${anomalyResult.description} (confidence: ${anomalyResult.confidence.toFixed(2)})`);

        } catch (error) {
            loggers.system.error('Error processing anomaly:', error);
        }
    }

    getSeverityFromConfidence(confidence) {
        if (confidence >= 0.9) return 'critical';
        if (confidence >= 0.8) return 'high';
        if (confidence >= 0.6) return 'medium';
        return 'low';
    }

    scheduleAnalysisTasks() {
        // Update baseline patterns every hour
        setInterval(async () => {
            await this.updateBaselinePatterns();
        }, 60 * 60 * 1000);

        // Train models daily at 3 AM
        cron.schedule('0 3 * * *', async () => {
            await this.trainAnomalyModels();
        });

        // Clean up old anomalies weekly
        cron.schedule('0 4 * * 0', async () => {
            await this.cleanupOldAnomalies();
        });

        loggers.system.info('Scheduled anomaly detection tasks');
    }

    async updateBaselinePatterns() {
        try {
            loggers.system.info('Updating baseline patterns...');

            // Update source patterns
            const sourceCounts = await this.db.all(`
                SELECT source, COUNT(*) as count
                FROM logs 
                WHERE timestamp > datetime('now', '-24 hours')
                GROUP BY source
            `);

            for (const sourceCount of sourceCounts) {
                await this.db.run(`
                    INSERT OR REPLACE INTO anomaly_patterns (
                        pattern_type, pattern_signature, frequency_normal, 
                        last_seen, occurrence_count, is_baseline
                    ) VALUES (?, ?, ?, CURRENT_TIMESTAMP, ?, 1)
                `, ['source', sourceCount.source, sourceCount.count, sourceCount.count]);
            }

            // Update hourly patterns
            const hourlyCounts = await this.db.all(`
                SELECT strftime('%H', timestamp) as hour, COUNT(*) as count
                FROM logs 
                WHERE timestamp > datetime('now', '-7 days')
                GROUP BY strftime('%H', timestamp)
            `);

            for (const hourlyCount of hourlyCounts) {
                await this.db.run(`
                    INSERT OR REPLACE INTO anomaly_patterns (
                        pattern_type, pattern_signature, frequency_normal,
                        last_seen, occurrence_count, is_baseline
                    ) VALUES (?, ?, ?, CURRENT_TIMESTAMP, ?, 1)
                `, ['hourly', hourlyCount.hour, hourlyCount.count, hourlyCount.count]);
            }

            loggers.system.info('Baseline patterns updated');
        } catch (error) {
            loggers.system.error('Failed to update baseline patterns:', error);
        }
    }

    async trainAnomalyModels() {
        if (this.isTraining) {
            loggers.system.warn('Model training already in progress');
            return;
        }

        this.isTraining = true;
        
        try {
            loggers.system.info('Starting anomaly model training...');

            // Collect training data from recent logs and anomalies
            const trainingData = await this.collectTrainingData();
            
            if (trainingData.length < 100) {
                loggers.system.warn('Insufficient training data for model training');
                return;
            }

            // Simple statistical model training
            const model = await this.trainStatisticalModel(trainingData);
            
            // Validate model
            const validationScore = await this.validateModel(model, trainingData);
            
            // Store model if it performs well
            if (validationScore > 0.7) {
                await this.storeModel('statistical_v1', model, validationScore);
                this.statistics.modelAccuracy = validationScore;
                this.statistics.trainingIterations++;
                loggers.system.info(`Model training completed with accuracy: ${validationScore.toFixed(3)}`);
            } else {
                loggers.system.warn(`Model training resulted in low accuracy: ${validationScore.toFixed(3)}`);
            }

            this.lastTrainingTime = new Date();

        } catch (error) {
            loggers.system.error('Model training failed:', error);
        } finally {
            this.isTraining = false;
        }
    }

    async collectTrainingData() {
        try {
            // Get confirmed anomalies (positive examples)
            const anomalies = await this.db.all(`
                SELECT l.*, ad.anomaly_type, ad.confidence_score
                FROM logs l
                JOIN anomaly_detections ad ON l.id = ad.log_id
                WHERE ad.false_positive = 0
                AND ad.timestamp > datetime('now', '-30 days')
                LIMIT 500
            `);

            // Get normal logs (negative examples)
            const normalLogs = await this.db.all(`
                SELECT l.* FROM logs l
                LEFT JOIN anomaly_detections ad ON l.id = ad.log_id
                WHERE ad.id IS NULL
                AND l.timestamp > datetime('now', '-7 days')
                ORDER BY RANDOM()
                LIMIT 1000
            `);

            const trainingData = [];

            // Process anomalies as positive examples
            for (const log of anomalies) {
                const features = this.extractFeatures(log);
                trainingData.push({
                    features,
                    label: 'anomaly',
                    weight: 1.0
                });
            }

            // Process normal logs as negative examples
            for (const log of normalLogs) {
                const features = this.extractFeatures(log);
                trainingData.push({
                    features,
                    label: 'normal',
                    weight: 0.5 // Lower weight for normal examples
                });
            }

            return trainingData;
        } catch (error) {
            loggers.system.error('Error collecting training data:', error);
            return [];
        }
    }

    async trainStatisticalModel(trainingData) {
        // Simple statistical model based on feature distributions
        const model = {
            type: 'statistical',
            featureStats: {},
            thresholds: {},
            created: new Date().toISOString()
        };

        const anomalyData = trainingData.filter(d => d.label === 'anomaly');
        const normalData = trainingData.filter(d => d.label === 'normal');

        if (anomalyData.length === 0 || normalData.length === 0) {
            throw new Error('Insufficient training data for both classes');
        }

        // Calculate feature statistics for both classes
        const featureNames = Object.keys(anomalyData[0].features);
        
        for (const feature of featureNames) {
            const anomalyValues = anomalyData.map(d => d.features[feature]).filter(v => typeof v === 'number');
            const normalValues = normalData.map(d => d.features[feature]).filter(v => typeof v === 'number');

            if (anomalyValues.length > 0 && normalValues.length > 0) {
                model.featureStats[feature] = {
                    anomaly: {
                        mean: this.calculateMean(anomalyValues),
                        std: this.calculateStdDev(anomalyValues),
                        min: Math.min(...anomalyValues),
                        max: Math.max(...anomalyValues)
                    },
                    normal: {
                        mean: this.calculateMean(normalValues),
                        std: this.calculateStdDev(normalValues),
                        min: Math.min(...normalValues),
                        max: Math.max(...normalValues)
                    }
                };

                // Calculate threshold for this feature
                const anomalyMean = model.featureStats[feature].anomaly.mean;
                const normalMean = model.featureStats[feature].normal.mean;
                model.thresholds[feature] = (anomalyMean + normalMean) / 2;
            }
        }

        return model;
    }

    calculateMean(values) {
        return values.reduce((sum, val) => sum + val, 0) / values.length;
    }

    calculateStdDev(values) {
        const mean = this.calculateMean(values);
        const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
        return Math.sqrt(variance);
    }

    async validateModel(model, trainingData) {
        let correct = 0;
        let total = 0;

        for (const sample of trainingData) {
            const prediction = this.predictWithModel(model, sample.features);
            const actualLabel = sample.label;
            
            if ((prediction.isAnomaly && actualLabel === 'anomaly') || 
                (!prediction.isAnomaly && actualLabel === 'normal')) {
                correct++;
            }
            total++;
        }

        return total > 0 ? correct / total : 0;
    }

    predictWithModel(model, features) {
        let anomalyScore = 0;
        let featureCount = 0;

        for (const [featureName, value] of Object.entries(features)) {
            if (typeof value === 'number' && model.featureStats[featureName]) {
                const stats = model.featureStats[featureName];
                const threshold = model.thresholds[featureName];
                
                // Simple threshold-based scoring
                if (Math.abs(value - stats.anomaly.mean) < Math.abs(value - stats.normal.mean)) {
                    anomalyScore += 1;
                }
                featureCount++;
            }
        }

        const confidence = featureCount > 0 ? anomalyScore / featureCount : 0;
        return {
            isAnomaly: confidence > 0.5,
            confidence: confidence,
            score: anomalyScore
        };
    }

    async storeModel(modelName, modelData, accuracy) {
        try {
            await this.db.run(`
                INSERT OR REPLACE INTO anomaly_models (
                    model_name, model_type, model_data, accuracy_score, validation_score
                ) VALUES (?, ?, ?, ?, ?)
            `, [
                modelName,
                modelData.type,
                JSON.stringify(modelData),
                accuracy,
                accuracy
            ]);

            this.models.set(modelName, modelData);
        } catch (error) {
            loggers.system.error('Failed to store model:', error);
        }
    }

    async cleanupOldAnomalies() {
        try {
            // Delete old resolved anomalies (keep for 90 days)
            await this.db.run(`
                DELETE FROM anomaly_detections 
                WHERE resolved = 1 
                AND resolved_at < datetime('now', '-90 days')
            `);

            // Delete old training data (keep for 30 days)
            await this.db.run(`
                DELETE FROM anomaly_training_data 
                WHERE created_at < datetime('now', '-30 days')
            `);

            loggers.system.info('Cleaned up old anomaly data');
        } catch (error) {
            loggers.system.error('Failed to cleanup old anomalies:', error);
        }
    }

    async getAnomalyStatistics() {
        try {
            const totalAnomalies = await this.db.get(`
                SELECT COUNT(*) as count FROM anomaly_detections
            `);

            const recentAnomalies = await this.db.get(`
                SELECT COUNT(*) as count FROM anomaly_detections
                WHERE timestamp > datetime('now', '-24 hours')
            `);

            const anomaliesBySeverity = await this.db.all(`
                SELECT severity, COUNT(*) as count
                FROM anomaly_detections
                WHERE timestamp > datetime('now', '-7 days')
                GROUP BY severity
            `);

            const topRules = await this.db.all(`
                SELECT ar.name, ar.usage_count, ar.accuracy_rating
                FROM anomaly_rules ar
                WHERE ar.enabled = 1
                ORDER BY ar.usage_count DESC
                LIMIT 10
            `);

            const modelInfo = await this.db.all(`
                SELECT * FROM anomaly_models
                WHERE active = 1
                ORDER BY training_date DESC
            `);

            return {
                totalAnomalies: totalAnomalies.count,
                recentAnomalies: recentAnomalies.count,
                anomaliesBySeverity,
                topRules,
                modelInfo,
                runtimeStats: this.statistics,
                isTraining: this.isTraining,
                lastTrainingTime: this.lastTrainingTime,
                recentAnomaliesBuffer: this.recentAnomalies.slice(-20)
            };
        } catch (error) {
            loggers.system.error('Failed to get anomaly statistics:', error);
            return null;
        }
    }

    async markAnomalyAsFalsePositive(anomalyId, userId) {
        try {
            await this.db.run(`
                UPDATE anomaly_detections 
                SET false_positive = 1, 
                    feedback_provided = 1,
                    resolved = 1,
                    resolved_at = CURRENT_TIMESTAMP,
                    resolved_by = ?
                WHERE id = ?
            `, [userId, anomalyId]);

            this.statistics.falsePositives++;
            return { success: true };
        } catch (error) {
            loggers.system.error('Failed to mark anomaly as false positive:', error);
            return { success: false, error: error.message };
        }
    }

    async resolveAnomaly(anomalyId, userId) {
        try {
            await this.db.run(`
                UPDATE anomaly_detections 
                SET resolved = 1,
                    resolved_at = CURRENT_TIMESTAMP,
                    resolved_by = ?
                WHERE id = ?
            `, [userId, anomalyId]);

            return { success: true };
        } catch (error) {
            loggers.system.error('Failed to resolve anomaly:', error);
            return { success: false, error: error.message };
        }
    }
}

// ============================================================================
// LOG CORRELATION ENGINE
// ============================================================================
class LogCorrelationEngine {
    constructor(database) {
        this.db = database;
        this.correlationRules = [];
        this.activeCorrelations = new Map();
    }

    async initialize() {
        loggers.system.info('üîó Initializing Log Correlation Engine...');
        await this.loadCorrelationRules();
        loggers.system.info('‚úÖ Log Correlation Engine initialized successfully');
        return true;
    }

    async loadCorrelationRules() {
        // Default correlation rules for common patterns
        this.correlationRules = [
            {
                id: 'auth_failures',
                name: 'Authentication Failure Pattern',
                pattern: 'authentication|login.*fail',
                timeWindow: 300, // 5 minutes
                threshold: 3,
                severity: 'high'
            },
            {
                id: 'error_burst',
                name: 'Error Message Burst',
                pattern: 'error|exception|fail',
                timeWindow: 60, // 1 minute
                threshold: 10,
                severity: 'medium'
            },
            {
                id: 'system_restart',
                name: 'System Restart Sequence',
                pattern: 'restart|reboot|shutdown',
                timeWindow: 120, // 2 minutes
                threshold: 1,
                severity: 'low'
            }
        ];
    }

    async correlateLogEvent(logEvent) {
        for (const rule of this.correlationRules) {
            if (this.matchesPattern(logEvent.message, rule.pattern)) {
                await this.processCorrelation(rule, logEvent);
            }
        }
    }

    matchesPattern(message, pattern) {
        const regex = new RegExp(pattern, 'i');
        return regex.test(message);
    }

    async processCorrelation(rule, logEvent) {
        const correlationKey = `${rule.id}_${Math.floor(Date.now() / (rule.timeWindow * 1000))}`;
        
        if (!this.activeCorrelations.has(correlationKey)) {
            this.activeCorrelations.set(correlationKey, {
                rule: rule,
                events: [],
                startTime: Date.now()
            });
        }

        const correlation = this.activeCorrelations.get(correlationKey);
        correlation.events.push(logEvent);

        // Check if threshold is met
        if (correlation.events.length >= rule.threshold) {
            await this.triggerCorrelationAlert(correlation);
            this.activeCorrelations.delete(correlationKey);
        }
    }

    async triggerCorrelationAlert(correlation) {
        const alertMessage = `Pattern detected: ${correlation.rule.name} - ${correlation.events.length} related events found`;
        
        // Log the correlation
        loggers.system.warn('Log correlation detected:', {
            rule: correlation.rule.name,
            eventCount: correlation.events.length,
            severity: correlation.rule.severity
        });

        // Store correlation in database
        try {
            await this.db.run(`
                INSERT INTO log_correlations (rule_id, rule_name, event_count, severity, detected_at, events_json)
                VALUES (?, ?, ?, ?, ?, ?)
            `, [
                correlation.rule.id,
                correlation.rule.name,
                correlation.events.length,
                correlation.rule.severity,
                new Date().toISOString(),
                JSON.stringify(correlation.events.map(e => ({
                    timestamp: e.timestamp,
                    message: e.message,
                    source: e.source,
                    level: e.level
                })))
            ]);
        } catch (error) {
            loggers.system.error('Failed to store log correlation:', error);
        }

        return {
            type: 'correlation',
            rule: correlation.rule,
            eventCount: correlation.events.length,
            message: alertMessage
        };
    }

    getCorrelationStats() {
        return {
            activeCorrelations: this.activeCorrelations.size,
            rulesLoaded: this.correlationRules.length,
            status: 'active'
        };
    }
}

// ============================================================================
// PERFORMANCE OPTIMIZATION ENGINE
// ============================================================================
class PerformanceOptimizationEngine {
    constructor(database) {
        this.db = database;
        this.optimizationRules = [];
        this.performanceHistory = [];
        this.thresholds = {
            highCpu: 80,
            highMemory: 85,
            highDisk: 90,
            slowQuery: 1000,
            errorRate: 5
        };
    }

    async initialize() {
        loggers.system.info('üöÄ Initializing Performance Optimization Engine...');
        await this.loadOptimizationRules();
        this.startPerformanceMonitoring();
        loggers.system.info('‚úÖ Performance Optimization Engine initialized successfully');
        return true;
    }

    async loadOptimizationRules() {
        this.optimizationRules = [
            {
                id: 'log_retention_optimization',
                name: 'Automatic Log Retention',
                type: 'cleanup',
                condition: 'log_count > 100000',
                action: 'archive_old_logs',
                priority: 'medium'
            },
            {
                id: 'database_vacuum',
                name: 'Database Optimization',
                type: 'database',
                condition: 'db_fragmentation > 20',
                action: 'vacuum_database',
                priority: 'low'
            },
            {
                id: 'memory_cleanup',
                name: 'Memory Usage Optimization',
                type: 'memory',
                condition: 'memory_usage > 85',
                action: 'clear_caches',
                priority: 'high'
            }
        ];
    }

    startPerformanceMonitoring() {
        // Monitor performance every 30 seconds
        setInterval(async () => {
            await this.collectPerformanceMetrics();
            await this.evaluateOptimizations();
        }, 30000);
    }

    async collectPerformanceMetrics() {
        try {
            const metrics = {
                timestamp: Date.now(),
                memoryUsage: process.memoryUsage(),
                cpuUsage: await this.getCpuUsage(),
                uptime: process.uptime(),
                activeConnections: this.getActiveConnections(),
                databaseSize: await this.getDatabaseSize()
            };

            this.performanceHistory.push(metrics);
            
            // Keep only last 100 measurements (50 minutes of history)
            if (this.performanceHistory.length > 100) {
                this.performanceHistory.shift();
            }

            return metrics;
        } catch (error) {
            loggers.system.error('Error collecting performance metrics:', error);
            return null;
        }
    }

    async getCpuUsage() {
        return new Promise((resolve) => {
            const startUsage = process.cpuUsage();
            const startTime = Date.now();
            
            setTimeout(() => {
                const currentUsage = process.cpuUsage(startUsage);
                const totalTime = Date.now() - startTime;
                const cpuPercent = (currentUsage.user + currentUsage.system) / (totalTime * 1000) * 100;
                resolve(Math.min(Math.max(cpuPercent, 0), 100));
            }, 100);
        });
    }

    getActiveConnections() {
        // Count active WebSocket connections if available
        if (integrationManager && integrationManager.connectedClients) {
            return integrationManager.connectedClients.size;
        }
        return 0;
    }

    async getDatabaseSize() {
        try {
            // TODO: Update to use DAL once global dal is available in this scope
            return new Promise((resolve, reject) => {
                db.get("SELECT COUNT(*) as count FROM logs", (err, row) => {
                    if (err) reject(err);
                    else resolve(row ? row.count : 0);
                });
            });
        } catch (error) {
            return 0;
        }
    }

    async evaluateOptimizations() {
        const currentMetrics = this.performanceHistory[this.performanceHistory.length - 1];
        if (!currentMetrics) return;

        const memoryUsagePercent = (currentMetrics.memoryUsage.heapUsed / currentMetrics.memoryUsage.heapTotal) * 100;
        
        // Check for performance issues and apply optimizations
        if (memoryUsagePercent > this.thresholds.highMemory) {
            await this.optimizeMemoryUsage();
        }

        if (currentMetrics.databaseSize > 50000) {
            await this.optimizeDatabasePerformance();
        }
    }

    async optimizeMemoryUsage() {
        loggers.system.info('üßπ Optimizing memory usage...');
        
        try {
            // Force garbage collection if available
            if (global.gc) {
                global.gc();
                loggers.system.info('‚úÖ Garbage collection completed');
            }

            // Clear performance history older than 30 minutes
            const thirtyMinutesAgo = Date.now() - (30 * 60 * 1000);
            this.performanceHistory = this.performanceHistory.filter(m => m.timestamp > thirtyMinutesAgo);

        } catch (error) {
            loggers.system.error('Memory optimization failed:', error);
        }
    }

    async optimizeDatabasePerformance() {
        loggers.system.info('üóÑÔ∏è Optimizing database performance...');
        
        try {
            // Run VACUUM to defragment database
            await new Promise((resolve, reject) => {
                this.db.run('VACUUM', (err) => {
                    if (err) reject(err);
                    else resolve();
                });
            });

            loggers.system.info('‚úÖ Database optimization completed');
        } catch (error) {
            loggers.system.error('Database optimization failed:', error);
        }
    }

    getPerformanceReport() {
        if (this.performanceHistory.length === 0) {
            return { status: 'no_data', message: 'No performance data available' };
        }

        const latest = this.performanceHistory[this.performanceHistory.length - 1];
        const memoryUsagePercent = (latest.memoryUsage.heapUsed / latest.memoryUsage.heapTotal) * 100;
        
        return {
            status: 'active',
            currentMetrics: {
                memoryUsage: memoryUsagePercent.toFixed(1) + '%',
                uptime: Math.floor(latest.uptime / 3600) + 'h ' + Math.floor((latest.uptime % 3600) / 60) + 'm',
                activeConnections: latest.activeConnections,
                databaseSize: latest.databaseSize.toLocaleString() + ' logs'
            },
            optimizationRules: this.optimizationRules.length,
            historyLength: this.performanceHistory.length
        };
    }
}

// ============================================================================
// DISTRIBUTED TRACING ENGINE
// ============================================================================
class DistributedTracingEngine {
    constructor(config = {}) {
        this.config = config;
        this.isInitialized = false;
        this.traces = [];
        this.spans = [];
        this.services = new Set();
        this.dependencies = [];
        this.stats = {
            totalTraces: 0,
            totalSpans: 0,
            avgDuration: 0,
            errorsCount: 0,
            activeSpans: 0,
            activeTraces: 0
        };
    }

    async initialize() {
        try {
            loggers.system.info('üîç Initializing Distributed Tracing Engine...');
            
            // Initialize OpenTelemetry if configured
            if (this.config && this.config.enabled) {
                // TODO: Initialize OpenTelemetry SDK
                loggers.system.info('   ‚Ä¢ OpenTelemetry SDK: Active');
                loggers.system.info('   ‚Ä¢ Jaeger Exporter: Configured');
                loggers.system.info('   ‚Ä¢ Trace Collection: Enabled');
                loggers.system.info('   ‚Ä¢ Span Analysis: Ready');
            }
            
            this.isInitialized = true;
            loggers.system.info('‚úÖ Distributed Tracing Engine initialized successfully');
            return true;
        } catch (error) {
            loggers.system.error('Failed to initialize Distributed Tracing Engine:', error);
            return false;
        }
    }

    getTraceStats() {
        return {
            totalTraces: this.stats.totalTraces,
            totalSpans: this.stats.totalSpans,
            avgDuration: this.stats.avgDuration,
            errorsCount: this.stats.errorsCount,
            activeSpans: this.stats.activeSpans,
            activeTraces: this.stats.activeTraces,
            servicesCount: this.services.size
        };
    }

    async searchTraces(filters = {}) {
        // Mock implementation - return empty array for now
        // TODO: Implement actual trace search functionality
        return [];
    }

    async getTraceData(traceId) {
        // Mock implementation - return null for now
        // TODO: Implement actual trace data retrieval
        return null;
    }

    async getServiceDependencies() {
        // Mock implementation - return empty array for now
        // TODO: Implement actual service dependency mapping
        return [];
    }

    addTrace(trace) {
        this.traces.push(trace);
        this.stats.totalTraces++;
        if (trace.service) {
            this.services.add(trace.service);
        }
    }

    addSpan(span) {
        this.spans.push(span);
        this.stats.totalSpans++;
        if (span.duration) {
            this.stats.avgDuration = (this.stats.avgDuration * (this.stats.totalSpans - 1) + span.duration) / this.stats.totalSpans;
        }
        if (span.error) {
            this.stats.errorsCount++;
        }
    }
}

// ============================================================================
// INTEGRATION MANAGER - Central hub for all external integrations
// ============================================================================

class IntegrationManager {
    constructor() {
        this.connections = {};
        this.mqttClient = null;
        this.haWebSocket = null;
        this.unifiClient = null;
        this.wsServer = null;
        this.connectedClients = new Set();
    }

    async initialize() {
        loggers.system.info('üîå Initializing integrations...');
        
        try {
            // Initialize WebSocket server
            if (config.integrations.websocket.enabled) {
                await this.initializeWebSocket();
            }
            
            // Initialize MQTT
            if (config.integrations.mqtt.enabled) {
                await this.initializeMQTT();
            }
            
            loggers.system.info('‚úÖ All integrations initialized');
        } catch (error) {
            loggers.system.error('‚ùå Integration initialization failed:', error);
        }
    }

    async initializeWebSocket() {
        try {
            this.wsServer = new WebSocket.Server({ port: config.integrations.websocket.port });
            
            this.wsServer.on('connection', (ws, req) => {
                const clientId = crypto.randomUUID();
                this.connectedClients.add(ws);
                
                loggers.system.info(`üîó WebSocket client connected: ${clientId}`);
                
                ws.on('close', () => {
                    this.connectedClients.delete(ws);
                    loggers.system.info(`üîå WebSocket client disconnected: ${clientId}`);
                });
                
                ws.on('error', (error) => {
                    loggers.system.error(`WebSocket error for ${clientId}:`, error);
                });
                
                // Send welcome message
                ws.send(JSON.stringify({
                    type: 'connection',
                    message: 'Connected to Enterprise Logging Platform',
                    timestamp: moment().tz(TIMEZONE).toISOString()
                }));
            });
            
            loggers.system.info(`‚úÖ WebSocket server running on port ${config.integrations.websocket.port}`);
        } catch (error) {
            loggers.system.error('‚ùå WebSocket initialization failed:', error);
        }
    }

    async initializeMQTT() {
        try {
            loggers.system.info('üîó Connecting to MQTT broker...');
            
            const mqttOptions = {};
            if (config.integrations.mqtt.username) {
                mqttOptions.username = config.integrations.mqtt.username;
                mqttOptions.password = config.integrations.mqtt.password;
            }
            
            this.mqttClient = mqtt.connect(config.integrations.mqtt.broker, mqttOptions);
            
            this.mqttClient.on('connect', () => {
                loggers.system.info('‚úÖ MQTT connected successfully');
                
                // Subscribe to configured topics
                config.integrations.mqtt.topics.forEach(topic => {
                    this.mqttClient.subscribe(topic);
                    loggers.system.info(`üì° Subscribed to MQTT topic: ${topic}`);
                });
                
                // Subscribe to Node-RED error/critical logs if enabled
                if (config.integrations.mqtt.nodeRedLogging.enabled) {
                    this.mqttClient.subscribe(config.integrations.mqtt.nodeRedLogging.errorTopic);
                    this.mqttClient.subscribe(config.integrations.mqtt.nodeRedLogging.criticalTopic);
                    loggers.system.info(`üì° Subscribed to Node-RED error logs: ${config.integrations.mqtt.nodeRedLogging.errorTopic}`);
                    loggers.system.info(`üì° Subscribed to Node-RED critical logs: ${config.integrations.mqtt.nodeRedLogging.criticalTopic}`);
                }
            });
            
            this.mqttClient.on('message', (topic, message) => {
                // Process MQTT message and log to database
                this.processMQTTMessage(topic, message);
            });
            
            this.mqttClient.on('error', (error) => {
                loggers.system.error('‚ùå MQTT connection error:', error);
            });
        } catch (error) {
            loggers.system.error('‚ùå MQTT initialization failed:', error);
        }
    }

    async processMQTTMessage(topic, message) {
        try {
            const messageStr = message.toString();
            let logData;
            
            try {
                logData = JSON.parse(messageStr);
            } catch {
                logData = { message: messageStr };
            }
            
            // Handle Node-RED logging specifically
            if (topic.startsWith('homeassistant/logging/')) {
                const [_, __, service, level] = topic.split('/');
                const log = logData;
                
                // Create Node-RED specific log entry
                const logEntry = {
                    timestamp: log.timestamp || new Date().toISOString(),
                    source: `nodered-${service}`,
                    message: log.msg || log.message || messageStr,
                    level: level,
                    category: 'node-red',
                    service: service,
                    node_id: log.node_id || null,
                    flow_id: log.flow_id || null,
                    data: log
                };
                
                // Store in database with Node-RED specific metadata
                try {
                    await dal.insertLog({
                        timestamp: logEntry.timestamp,
                        level: logEntry.level,
                        message: logEntry.message,
                        source: logEntry.source,
                        ip: 'mqtt',
                        details: JSON.stringify({
                            category: logEntry.category,
                            service: logEntry.service,
                            node_id: logEntry.node_id,
                            flow_id: logEntry.flow_id,
                            original_data: logEntry.data
                        }),
                        tags: JSON.stringify(['node-red', 'mqtt', level, service])
                    });
                } catch (dbError) {
                    loggers.system.error('Failed to store Node-RED log to database:', dbError);
                }
                
                loggers.system.info(`üìã Node-RED ${level} log from ${service}: ${logEntry.message}`);
                
                // Broadcast to WebSocket clients
                this.broadcastToWebSockets({
                    type: 'node_red_log',
                    topic: topic,
                    data: logEntry
                });
                
                return;
            }
            
            // Create standardized log entry for other MQTT messages
            const logEntry = {
                timestamp: new Date().toISOString(),
                source: topic,
                message: logData.message || messageStr,
                level: logData.level || 'info',
                category: 'mqtt',
                data: logData
            };
            
            // Store in database
            logToDatabase(logEntry.message, logEntry.level, logEntry.category, logEntry.source);
            
            // Broadcast to WebSocket clients
            this.broadcastToWebSockets({
                type: 'mqtt_message',
                topic: topic,
                data: logEntry
            });
            
        } catch (error) {
            loggers.system.error('Error processing MQTT message:', error);
        }
    }

    broadcastToWebSockets(data) {
        if (this.connectedClients.size === 0) return;
        
        const message = JSON.stringify(data);
        this.connectedClients.forEach(client => {
            if (client.readyState === WebSocket.OPEN) {
                client.send(message);
            }
        });
    }

    getStatus() {
        return {
            websocket: {
                enabled: config.integrations.websocket.enabled,
                connected: this.wsServer ? true : false,
                clients: this.connectedClients.size
            },
            mqtt: {
                enabled: config.integrations.mqtt.enabled,
                connected: this.mqttClient ? this.mqttClient.connected : false,
                broker: config.integrations.mqtt.broker
            }
        };
    }

    async checkIntegrationHealth(name) {
        const status = this.getStatus();
        return status[name] || { enabled: false, connected: false };
    }

    async checkAllIntegrationsHealth() {
        return this.getStatus();
    }

    initializeHealthChecks() {
        loggers.system.info('üè• Initializing integration health checks...');
        
        // Set up periodic health checks for all integrations
        setInterval(async () => {
            try {
                const healthStatus = await this.checkAllIntegrationsHealth();
                
                // Log health status to database
                Object.entries(healthStatus).forEach(([integration, status]) => {
                    if (!status.connected && status.enabled) {
                        loggers.system.warn(`‚ö†Ô∏è Integration ${integration} is enabled but not connected`);
                    }
                });
                
            } catch (error) {
                loggers.system.error('Health check failed:', error);
            }
        }, 60000); // Check every minute
        
        loggers.system.info('‚úÖ Integration health checks initialized');
    }
}

// Global variables for enterprise features  
let alertingEngine = null;
let advancedSearchEngine = null;
let multiProtocolIngestionEngine = null;
let distributedTracingEngine = null;
let advancedDashboardBuilder = null;
let integrationManager = null;

// Start metrics collection
setTimeout(() => metricsManager.initializeMetricsCollection(), 5000);

// ============================================================================
// DATABASE INITIALIZATION
// ============================================================================

// SQLite database path
const dbPath = path.join(dbDir, 'logs.db');

// Initialize Database Access Layer (centralized database operations)
dal = new DatabaseAccessLayer(dbPath, loggers.system);
let db; // Legacy variable for gradual migration

// Initialize DAL and get database connection for legacy compatibility
try {
    db = dal.db; // Legacy compatibility
    loggers.system.info('‚úÖ Database Access Layer initialized successfully');
    loggers.system.info('‚úÖ Connected to SQLite database via DAL');
} catch (error) {
    loggers.system.error('‚ùå Database initialization failed:', error.message);
    process.exit(1);
}

// Database schema initialization
const SYSTEM_SETTINGS = {};
let METRICSMANAGER_INITIALIZED = false;

// Initialize system settings from database using DAL
async function loadSystemSettings() {
    try {
        const globalSettings = await dal.getSetting('global');
        if (globalSettings) {
            try {
                const settings = JSON.parse(globalSettings);
                Object.assign(SYSTEM_SETTINGS, settings);
                loggers.system.info('üìã System settings loaded via DAL');
            } catch (error) {
                loggers.system.warn('‚ö†Ô∏è  Invalid system settings JSON:', error);
            }
        }
    } catch (error) {
        // Settings table might not exist yet or dal not initialized
        loggers.system.debug('Settings not loaded, using defaults');
    }
}

// ============================================================================
// METRICS MANAGER
// ============================================================================

class MetricsManager {
    constructor() {
        this.serverMetrics = {
            startTime: new Date(),
            totalRequests: 0,
            totalLogs: 0,
            totalBytes: 0,
            activeConnections: 0,
            errors: 0,
            avgResponseTime: 0,
            uptime: 0
        };
        this.integrationMetrics = {};
        this.performanceMetrics = {
            cpuUsage: 0,
            memoryUsage: 0,
            diskUsage: 0
        };
        this.initialized = false;
    }

    async initialize() {
        if (this.initialized) return;
        
        loggers.system.info('üìä Initializing Metrics Manager...');
        
        // Start metrics collection intervals
        this.initializeMetricsCollection();
        
        this.initialized = true;
        loggers.system.info('‚úÖ Metrics Manager initialized');
    }

    initializeMetricsCollection() {
        // Update server uptime every minute
        setInterval(() => {
            this.serverMetrics.uptime = Date.now() - this.serverMetrics.startTime.getTime();
        }, 60000);

        // Collect performance metrics every 30 seconds
        setInterval(() => {
            this.collectPerformanceMetrics();
        }, 30000);
    }

    collectPerformanceMetrics() {
        const used = process.memoryUsage();
        this.performanceMetrics.memoryUsage = Math.round(used.heapUsed / 1024 / 1024); // MB
        
        // CPU usage calculation
        this.updateCpuUsage();
        
        // Disk usage calculation
        this.updateDiskUsage();
    }

    incrementRequests() {
        this.serverMetrics.totalRequests++;
    }

    incrementLogs() {
        this.serverMetrics.totalLogs++;
    }

    incrementBytes(bytes) {
        this.serverMetrics.totalBytes += bytes;
    }

    incrementErrors() {
        this.serverMetrics.errors++;
    }

    updateCpuUsage() {
        // Real CPU usage calculation using process.cpuUsage()
        if (!this.lastCpuUsage) {
            this.lastCpuUsage = process.cpuUsage();
            this.lastCpuTime = Date.now();
            this.performanceMetrics.cpuUsage = 0;
            return;
        }

        const currentUsage = process.cpuUsage();
        const currentTime = Date.now();
        const timeDiff = currentTime - this.lastCpuTime;
        
        if (timeDiff > 0) {
            // Calculate CPU usage percentage
            const userDiff = currentUsage.user - this.lastCpuUsage.user;
            const systemDiff = currentUsage.system - this.lastCpuUsage.system;
            const totalDiff = userDiff + systemDiff;
            
            // Convert microseconds to percentage
            const cpuPercent = (totalDiff / (timeDiff * 1000)) * 100;
            this.performanceMetrics.cpuUsage = Math.min(Math.max(cpuPercent, 0), 100);
        }

        this.lastCpuUsage = currentUsage;
        this.lastCpuTime = currentTime;
    }

    updateDiskUsage() {
        // Calculate database size as disk usage indicator
        try {
            const fs = require('fs');
            const path = require('path');
            const dbPath = path.join(__dirname, 'data', 'databases', 'logs.db');
            
            if (fs.existsSync(dbPath)) {
                const stats = fs.statSync(dbPath);
                const sizeInMB = stats.size / (1024 * 1024);
                
                // Estimate disk usage percentage based on database size
                // Assume 1GB = 100%, adjust as needed
                this.performanceMetrics.diskUsage = Math.min((sizeInMB / 1024) * 100, 100);
            } else {
                this.performanceMetrics.diskUsage = 0;
            }
        } catch (error) {
            // Fallback to minimal usage if file system check fails
            this.performanceMetrics.diskUsage = 5; // 5% default
        }
    }

    getMetrics() {
        return {
            server: this.serverMetrics,
            integrations: this.integrationMetrics,
            performance: this.performanceMetrics
        };
    }

    getSystemMetrics() {
        return {
            ...this.serverMetrics,
            ...this.performanceMetrics,
            uptime: Date.now() - this.serverMetrics.startTime.getTime(),
            timestamp: new Date().toISOString()
        };
    }
}

// Initialize global metrics manager
const metricsManager = new MetricsManager();

// Initialize integration manager
integrationManager = new IntegrationManager();

// Initialize multi-protocol ingestion engine
multiProtocolIngestionEngine = new MultiProtocolIngestionEngine();

// Initialize distributed tracing engine
distributedTracingEngine = new DistributedTracingEngine();

// Initialize alerting engine
alertingEngine = new AlertingEngine(db);

// Initialize advanced dashboard builder
advancedDashboardBuilder = new AdvancedDashboardBuilder();

// ============================================================================
// LOG DATABASE FUNCTIONS  
// ============================================================================

// Function to log data to database using DAL
async function logToDatabase(message, level = 'info', source = 'system', ip = 'localhost') {
    try {
        const logId = await dal.insertLog({
            level,
            message,
            source,
            ip
        });
        
        // Update metrics
        if (metricsManager) {
            metricsManager.incrementLogs();
            metricsManager.incrementBytes(message.length || 0);
        }
        
        return logId;
    } catch (error) {
        loggers.system.error('Database log insert error:', error);
        throw error;
    }
}

// ============================================================================
// DATABASE SCHEMA INITIALIZATION
// ============================================================================

// Create database tables
db.serialize(() => {
    // System logs table
    db.run(`CREATE TABLE IF NOT EXISTS logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        level TEXT NOT NULL DEFAULT 'info',
        message TEXT NOT NULL,
        source TEXT DEFAULT 'system',
        ip TEXT DEFAULT 'localhost',
        user_id INTEGER,
        metadata TEXT,
        severity INTEGER DEFAULT 0,
        facility INTEGER DEFAULT 16,
        hostname TEXT,
        appname TEXT,
        procid TEXT,
        msgid TEXT,
        structured_data TEXT,
        tags TEXT,
        trace_id TEXT,
        span_id TEXT,
        correlation_id TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        indexed BOOLEAN DEFAULT 0,
        archived BOOLEAN DEFAULT 0
    )`);

    // Users table
    db.run(`CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        role TEXT NOT NULL DEFAULT 'user',
        email TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        last_login DATETIME,
        active BOOLEAN DEFAULT 1,
        mfa_enabled BOOLEAN DEFAULT 0,
        mfa_secret TEXT,
        preferences TEXT DEFAULT '{}',
        session_token TEXT,
        reset_token TEXT,
        reset_expires DATETIME
    )`);

    // User sessions table
    db.run(`CREATE TABLE IF NOT EXISTS user_sessions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        session_token TEXT UNIQUE NOT NULL,
        ip_address TEXT,
        user_agent TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        last_activity DATETIME DEFAULT CURRENT_TIMESTAMP,
        expires_at DATETIME NOT NULL,
        is_active BOOLEAN DEFAULT 1,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
    )`);

    // System settings table
    db.run(`CREATE TABLE IF NOT EXISTS system_settings (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        setting_key TEXT UNIQUE NOT NULL,
        setting_value TEXT NOT NULL,
        description TEXT,
        updated_by TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Webhooks table
    db.run(`CREATE TABLE IF NOT EXISTS webhooks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        url TEXT NOT NULL,
        method TEXT DEFAULT 'POST',
        headers TEXT DEFAULT '{}',
        active BOOLEAN DEFAULT 1,
        secret TEXT,
        events TEXT DEFAULT '["all"]',
        filter_conditions TEXT,
        retry_count INTEGER DEFAULT 3,
        timeout INTEGER DEFAULT 30000,
        last_triggered DATETIME,
        total_calls INTEGER DEFAULT 0,
        success_calls INTEGER DEFAULT 0,
        failed_calls INTEGER DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        created_by INTEGER,
        FOREIGN KEY (created_by) REFERENCES users (id)
    )`);

    // API keys table
    db.run(`CREATE TABLE IF NOT EXISTS api_keys (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        key_hash TEXT NOT NULL UNIQUE,
        prefix TEXT NOT NULL,
        permissions TEXT DEFAULT '["read"]',
        rate_limit INTEGER DEFAULT 100,
        active BOOLEAN DEFAULT 1,
        expires_at DATETIME,
        last_used DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        created_by INTEGER,
        FOREIGN KEY (created_by) REFERENCES users (id)
    )`);

    // Ensure api_keys table has required columns (migration)
    db.run(`ALTER TABLE api_keys ADD COLUMN scopes TEXT DEFAULT '["read"]'`, (err) => {
        if (err && !err.message.includes('duplicate column')) {
            loggers.system.warn('API keys scopes column migration warning:', err.message);
        }
    });

    // Activity log table
    db.run(`CREATE TABLE IF NOT EXISTS activity_log (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        action TEXT NOT NULL,
        resource_type TEXT,
        resource_id TEXT,
        details TEXT,
        ip_address TEXT,
        user_agent TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (id)
    )`);

    // Integrations status table
    db.run(`CREATE TABLE IF NOT EXISTS integrations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT UNIQUE NOT NULL,
        type TEXT NOT NULL,
        status TEXT DEFAULT 'disabled',
        config TEXT DEFAULT '{}',
        last_sync DATETIME,
        error_count INTEGER DEFAULT 0,
        last_error TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Alert rules table
    db.run(`CREATE TABLE IF NOT EXISTS alert_rules (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        description TEXT,
        type TEXT NOT NULL DEFAULT 'pattern',
        condition TEXT NOT NULL,
        severity TEXT DEFAULT 'warning',
        cooldown INTEGER DEFAULT 300,
        enabled BOOLEAN DEFAULT 1,
        channels TEXT DEFAULT '[]',
        escalation_rules TEXT,
        trigger_count INTEGER DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        created_by INTEGER,
        FOREIGN KEY (created_by) REFERENCES users (id)
    )`);

    // Ensure alert_rules table has required columns (migration)
    db.run(`ALTER TABLE alert_rules ADD COLUMN channels TEXT DEFAULT '[]'`, (err) => {
        if (err && !err.message.includes('duplicate column')) {
            loggers.system.warn('Alert rules channels column migration warning:', err.message);
        }
    });
    
    db.run(`ALTER TABLE alert_rules ADD COLUMN escalation_rules TEXT`, (err) => {
        if (err && !err.message.includes('duplicate column')) {
            loggers.system.warn('Alert rules escalation_rules column migration warning:', err.message);
        }
    });

    // Notification channels table
    db.run(`CREATE TABLE IF NOT EXISTS notification_channels (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        type TEXT NOT NULL,
        config TEXT NOT NULL DEFAULT '{}',
        enabled BOOLEAN DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        created_by INTEGER,
        FOREIGN KEY (created_by) REFERENCES users (id)
    )`);

    // System alerts table
    db.run(`CREATE TABLE IF NOT EXISTS system_alerts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        rule_id INTEGER,
        message TEXT NOT NULL,
        severity TEXT DEFAULT 'info',
        source TEXT DEFAULT 'system',
        details TEXT,
        is_resolved BOOLEAN DEFAULT 0,
        resolved_at DATETIME,
        resolved_by INTEGER,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (rule_id) REFERENCES alert_rules (id),
        FOREIGN KEY (resolved_by) REFERENCES users (id)
    )`);

    // Alert history table (for alert tracking)
    db.run(`CREATE TABLE IF NOT EXISTS alert_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        rule_id INTEGER,
        message TEXT NOT NULL,
        severity TEXT DEFAULT 'info',
        source TEXT DEFAULT 'system',
        details TEXT,
        is_resolved BOOLEAN DEFAULT 0,
        resolved_at DATETIME,
        resolved_by INTEGER,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (rule_id) REFERENCES alert_rules (id),
        FOREIGN KEY (resolved_by) REFERENCES users (id)
    )`);

    // System metrics table
    db.run(`CREATE TABLE IF NOT EXISTS system_metrics (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        metric_name TEXT NOT NULL,
        metric_value REAL NOT NULL,
        metric_type TEXT DEFAULT 'gauge',
        tags TEXT DEFAULT '{}',
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // User theme preferences table
    db.run(`CREATE TABLE IF NOT EXISTS user_theme_preferences (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        theme TEXT DEFAULT 'auto',
        sidebar_collapsed BOOLEAN DEFAULT 0,
        dashboard_layout TEXT DEFAULT '{}',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
    )`);

    // Webhook deliveries table
    db.run(`CREATE TABLE IF NOT EXISTS webhook_deliveries (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        webhook_id INTEGER NOT NULL,
        payload TEXT NOT NULL,
        response_code INTEGER,
        response_body TEXT,
        delivery_status TEXT DEFAULT 'pending',
        attempted_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        delivered_at DATETIME,
        error_message TEXT,
        retry_count INTEGER DEFAULT 0,
        FOREIGN KEY (webhook_id) REFERENCES webhooks (id) ON DELETE CASCADE
    )`);

    // Integration health table
    db.run(`CREATE TABLE IF NOT EXISTS integration_health (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        integration_name TEXT NOT NULL,
        status TEXT DEFAULT 'unknown',
        last_check DATETIME DEFAULT CURRENT_TIMESTAMP,
        response_time INTEGER DEFAULT 0,
        error_count INTEGER DEFAULT 0,
        last_error TEXT,
        uptime_percentage REAL DEFAULT 100.0,
        last_success DATETIME,
        metadata TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);
    
    // Add missing columns to existing integration_health table
    db.run(`ALTER TABLE integration_health ADD COLUMN last_success DATETIME`, (err) => {
        // Ignore error if column already exists
    });
    db.run(`ALTER TABLE integration_health ADD COLUMN metadata TEXT`, (err) => {
        // Ignore error if column already exists
    });

    // Integration metrics table
    db.run(`CREATE TABLE IF NOT EXISTS integration_metrics (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        integration_name TEXT NOT NULL,
        metric_type TEXT NOT NULL,
        metric_value REAL NOT NULL,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        details TEXT DEFAULT '{}'
    )`);

    // Custom integrations table
    db.run(`CREATE TABLE IF NOT EXISTS custom_integrations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        description TEXT,
        type TEXT NOT NULL,
        config TEXT DEFAULT '{}',
        script_content TEXT,
        enabled BOOLEAN DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        created_by INTEGER,
        FOREIGN KEY (created_by) REFERENCES users (id)
    )`);

    // Integration configs table
    db.run(`CREATE TABLE IF NOT EXISTS integration_configs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        integration_name TEXT NOT NULL UNIQUE,
        config TEXT NOT NULL DEFAULT '{}',
        enabled BOOLEAN DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Retention policies table
    db.run(`CREATE TABLE IF NOT EXISTS retention_policies (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        table_name TEXT NOT NULL,
        retention_days INTEGER NOT NULL DEFAULT 30,
        archive_enabled BOOLEAN DEFAULT 0,
        archive_path TEXT,
        compression_enabled BOOLEAN DEFAULT 1,
        last_cleanup DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Retention history table
    db.run(`CREATE TABLE IF NOT EXISTS retention_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        policy_id INTEGER NOT NULL,
        records_deleted INTEGER DEFAULT 0,
        records_archived INTEGER DEFAULT 0,
        execution_time INTEGER DEFAULT 0,
        status TEXT DEFAULT 'success',
        error_message TEXT,
        executed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (policy_id) REFERENCES retention_policies (id)
    )`);

    // Archived logs metadata table
    db.run(`CREATE TABLE IF NOT EXISTS archived_logs_metadata (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        original_table TEXT NOT NULL,
        archive_path TEXT NOT NULL,
        start_date DATETIME NOT NULL,
        end_date DATETIME NOT NULL,
        record_count INTEGER DEFAULT 0,
        compressed BOOLEAN DEFAULT 0,
        file_size INTEGER DEFAULT 0,
        checksum TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Dashboards table
    db.run(`CREATE TABLE IF NOT EXISTS dashboards (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        description TEXT,
        layout TEXT DEFAULT '{}',
        is_default BOOLEAN DEFAULT 0,
        is_public BOOLEAN DEFAULT 0,
        created_by INTEGER,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (created_by) REFERENCES users (id)
    )`);

    // Dashboard widgets table
    db.run(`CREATE TABLE IF NOT EXISTS dashboard_widgets (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        dashboard_id INTEGER NOT NULL,
        widget_type TEXT NOT NULL,
        title TEXT NOT NULL,
        config TEXT DEFAULT '{}',
        position_x INTEGER DEFAULT 0,
        position_y INTEGER DEFAULT 0,
        width INTEGER DEFAULT 1,
        height INTEGER DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (dashboard_id) REFERENCES dashboards (id) ON DELETE CASCADE
    )`);

    // Widget templates table
    db.run(`CREATE TABLE IF NOT EXISTS widget_templates (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        widget_type TEXT NOT NULL,
        template_config TEXT DEFAULT '{}',
        is_system BOOLEAN DEFAULT 0,
        created_by INTEGER,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (created_by) REFERENCES users (id)
    )`);

    // User dashboard preferences table
    db.run(`CREATE TABLE IF NOT EXISTS user_dashboard_preferences (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        dashboard_id INTEGER NOT NULL,
        is_favorite BOOLEAN DEFAULT 0,
        custom_layout TEXT DEFAULT '{}',
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
        FOREIGN KEY (dashboard_id) REFERENCES dashboards (id) ON DELETE CASCADE
    )`);

    // Streaming sessions table
    db.run(`CREATE TABLE IF NOT EXISTS streaming_sessions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        session_id TEXT UNIQUE NOT NULL,
        filters TEXT DEFAULT '{}',
        buffer_size INTEGER DEFAULT 100,
        is_active BOOLEAN DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        last_activity DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (id)
    )`);

    // Streaming filters table
    db.run(`CREATE TABLE IF NOT EXISTS streaming_filters (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,
        filter_type TEXT NOT NULL,
        filter_value TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (session_id) REFERENCES streaming_sessions (session_id) ON DELETE CASCADE
    )`);

    // Streaming statistics table
    db.run(`CREATE TABLE IF NOT EXISTS streaming_statistics (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,
        messages_sent INTEGER DEFAULT 0,
        bytes_sent INTEGER DEFAULT 0,
        start_time DATETIME DEFAULT CURRENT_TIMESTAMP,
        end_time DATETIME,
        FOREIGN KEY (session_id) REFERENCES streaming_sessions (session_id) ON DELETE CASCADE
    )`);

    // Anomaly detections table
    db.run(`CREATE TABLE IF NOT EXISTS anomaly_detections (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        log_id INTEGER,
        anomaly_type TEXT NOT NULL,
        confidence_score REAL DEFAULT 0.0,
        details TEXT DEFAULT '{}',
        is_confirmed BOOLEAN DEFAULT 0,
        confirmed_by INTEGER,
        detected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (log_id) REFERENCES logs (id),
        FOREIGN KEY (confirmed_by) REFERENCES users (id)
    )`);

    // Anomaly rules table
    db.run(`CREATE TABLE IF NOT EXISTS anomaly_rules (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        rule_type TEXT NOT NULL,
        conditions TEXT NOT NULL,
        threshold REAL DEFAULT 0.5,
        enabled BOOLEAN DEFAULT 1,
        created_by INTEGER,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (created_by) REFERENCES users (id)
    )`);

    // Anomaly patterns table
    db.run(`CREATE TABLE IF NOT EXISTS anomaly_patterns (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        pattern_name TEXT NOT NULL,
        pattern_data TEXT NOT NULL,
        frequency INTEGER DEFAULT 1,
        last_seen DATETIME DEFAULT CURRENT_TIMESTAMP,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Anomaly training data table
    db.run(`CREATE TABLE IF NOT EXISTS anomaly_training_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        model_id TEXT NOT NULL,
        training_data TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // Anomaly models table
    db.run(`CREATE TABLE IF NOT EXISTS anomaly_models (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        model_name TEXT NOT NULL,
        model_type TEXT NOT NULL,
        model_data TEXT NOT NULL,
        accuracy REAL DEFAULT 0.0,
        is_active BOOLEAN DEFAULT 0,
        trained_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        created_by INTEGER,
        FOREIGN KEY (created_by) REFERENCES users (id)
    )`);

    // Log correlations table
    db.run(`CREATE TABLE IF NOT EXISTS log_correlations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        primary_log_id INTEGER NOT NULL,
        related_log_id INTEGER NOT NULL,
        correlation_type TEXT DEFAULT 'temporal',
        confidence_score REAL DEFAULT 0.0,
        time_window INTEGER DEFAULT 300,
        correlation_data TEXT DEFAULT '{}',
        detected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (primary_log_id) REFERENCES logs (id),
        FOREIGN KEY (related_log_id) REFERENCES logs (id)
    )`);

    // Correlation rules table
    db.run(`CREATE TABLE IF NOT EXISTS correlation_rules (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        description TEXT,
        rule_conditions TEXT NOT NULL,
        time_window INTEGER DEFAULT 300,
        enabled BOOLEAN DEFAULT 1,
        created_by INTEGER,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (created_by) REFERENCES users (id)
    )`);

    // Correlation events table
    db.run(`CREATE TABLE IF NOT EXISTS correlation_events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        rule_id INTEGER NOT NULL,
        event_data TEXT NOT NULL,
        matched_logs TEXT NOT NULL,
        correlation_strength REAL DEFAULT 0.0,
        detected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (rule_id) REFERENCES correlation_rules (id)
    )`);

    // Log events table (critical missing table - used extensively throughout the application)
    db.run(`CREATE TABLE IF NOT EXISTS log_events (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        level TEXT DEFAULT 'info',
        severity TEXT DEFAULT 'info',
        source TEXT,
        category TEXT,
        message TEXT NOT NULL,
        raw_message TEXT,
        details TEXT DEFAULT '{}',
        tags TEXT DEFAULT '[]',
        zone_number INTEGER,
        zone_name TEXT,
        sensor_id TEXT,
        device_id TEXT,
        event_type TEXT,
        metadata TEXT DEFAULT '{}',
        user_id INTEGER,
        session_id TEXT,
        ip_address TEXT,
        user_agent TEXT,
        correlation_id TEXT,
        trace_id TEXT,
        span_id TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (id)
    )`);

    // Rate limits table (critical for API security)
    db.run(`CREATE TABLE IF NOT EXISTS rate_limits (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        ip_address TEXT NOT NULL,
        endpoint TEXT NOT NULL,
        request_count INTEGER DEFAULT 1,
        window_start DATETIME DEFAULT CURRENT_TIMESTAMP,
        blocked_until DATETIME,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    // User activity table (critical for audit trail)
    db.run(`CREATE TABLE IF NOT EXISTS user_activity (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        action TEXT NOT NULL,
        resource TEXT,
        details TEXT DEFAULT '{}',
        ip_address TEXT,
        user_agent TEXT,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (id)
    )`);

    // Saved searches table (for user search preferences)
    db.run(`CREATE TABLE IF NOT EXISTS saved_searches (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        name TEXT NOT NULL,
        description TEXT,
        filters TEXT NOT NULL DEFAULT '{}',
        is_public BOOLEAN DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
    )`);

    // Alert escalations table (for alert management)
    db.run(`CREATE TABLE IF NOT EXISTS alert_escalations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        alert_id INTEGER NOT NULL,
        escalation_level INTEGER DEFAULT 1,
        escalated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        escalated_to INTEGER,
        status TEXT DEFAULT 'pending',
        response_deadline DATETIME,
        acknowledged_at DATETIME,
        acknowledged_by INTEGER,
        FOREIGN KEY (alert_id) REFERENCES system_alerts (id) ON DELETE CASCADE,
        FOREIGN KEY (escalated_to) REFERENCES users (id),
        FOREIGN KEY (acknowledged_by) REFERENCES users (id)
    )`);

    // Schema migrations table (for database versioning)
    db.run(`CREATE TABLE IF NOT EXISTS schema_migrations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        version TEXT NOT NULL UNIQUE,
        description TEXT,
        executed_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);

    loggers.system.info('‚úÖ Database tables initialized');
    
    // Initialize default integrations in health table
    const defaultIntegrations = [
        { name: 'websocket', type: 'WebSocket', description: 'Real-time WebSocket connections' },
        { name: 'mqtt', type: 'MQTT', description: 'MQTT message broker integration' },
        { name: 'unifi', type: 'UniFi', description: 'Ubiquiti UniFi network management' },
        { name: 'homeassistant', type: 'Home Assistant', description: 'Home Assistant smart home platform' }
    ];
    
    defaultIntegrations.forEach(integration => {
        db.run(`
            INSERT OR IGNORE INTO integration_health 
            (integration_name, status, last_check, error_count, metadata)
            VALUES (?, 'offline', CURRENT_TIMESTAMP, 0, ?)
        `, [
            integration.name,
            JSON.stringify({ type: integration.type, description: integration.description, enabled: false })
        ], (err) => {
            if (err) {
                loggers.system.error(`Failed to initialize ${integration.name} health record:`, err);
            } else {
                loggers.system.info(`‚úÖ Initialized ${integration.name} integration health record`);
            }
        });
    });
});

// ============================================================================
// DATABASE TRANSACTION SAFETY HELPERS
// ============================================================================

// Enhanced transaction wrapper to prevent data corruption during critical operations
function runTransaction(operations, callback) {
    db.serialize(() => {
        db.run('BEGIN TRANSACTION', (err) => {
            if (err) {
                loggers.system.error('Failed to begin transaction:', err);
                return callback(err);
            }
            
            let completed = 0;
            let hasError = false;
            
            const handleCompletion = (err) => {
                completed++;
                if (err && !hasError) {
                    hasError = true;
                    db.run('ROLLBACK', (rollbackErr) => {
                        if (rollbackErr) {
                            loggers.system.error('Transaction rollback failed:', rollbackErr);
                        }
                        loggers.system.error('Transaction failed, rolled back:', err);
                        callback(err);
                    });
                    return;
                }
                
                if (completed === operations.length && !hasError) {
                    db.run('COMMIT', (commitErr) => {
                        if (commitErr) {
                            loggers.system.error('Transaction commit failed:', commitErr);
                            return callback(commitErr);
                        }
                        loggers.system.info('Transaction committed successfully');
                        callback(null);
                    });
                }
            };
            
            operations.forEach(op => {
                db.run(op.sql, op.params || [], function(err) {
                    if (op.callback) op.callback(err, this);
                    handleCompletion(err);
                });
            });
        });
    });
}

// Safe database write operation with comprehensive error handling
function safeDbRun(sql, params, callback) {
    db.run(sql, params, function(err) {
        if (err) {
            loggers.system.error(`Database operation failed: ${sql}`, err);
            loggers.system.error('Parameters:', params);
        }
        if (callback) callback(err, this);
    });
}

// Safe database query with error handling and logging
function safeDbGet(sql, params, callback) {
    db.get(sql, params, (err, row) => {
        if (err) {
            loggers.system.error(`Database query failed: ${sql}`, err);
            loggers.system.error('Parameters:', params);
        }
        callback(err, row);
    });
}

// Safe database query all with error handling and logging
function safeDbAll(sql, params, callback) {
    db.all(sql, params, (err, rows) => {
        if (err) {
            loggers.system.error(`Database query failed: ${sql}`, err);
            loggers.system.error('Parameters:', params);
        }
        callback(err, rows);
    });
}

// Critical operation wrapper for important tasks that must not fail silently
function runCriticalOperation(operationName, operation, callback) {
    loggers.system.info(`Starting critical operation: ${operationName}`);
    
    operation((err, result) => {
        if (err) {
            loggers.system.error(`CRITICAL OPERATION FAILED: ${operationName}`, err);
            // Log to system alerts for admin notification
            safeDbRun(
                `INSERT INTO system_alerts (message, severity, source, details) VALUES (?, ?, ?, ?)`,
                [`Critical operation failed: ${operationName}`, 'critical', 'database', JSON.stringify({ error: err.message, stack: err.stack })],
                () => {} // Silent callback for alert logging
            );
        } else {
            loggers.system.info(`Critical operation completed successfully: ${operationName}`);
        }
        callback(err, result);
    });
}

// ============================================================================
// INTEGRATION MANAGER  
// ============================================================================

// ============================================================================
// USER MANAGER  
// ============================================================================

// Placeholder for UserManager (actual UserManager class is defined below)

Object.assign(SYSTEM_SETTINGS, {
    timezone: TIMEZONE,
    default_theme: 'ocean', 
    date_format: 'MM/DD/YYYY, hh:mm:ss A'
});

async function loadSystemSettings(callback) {
    try {
        const settings = await dal.getAllSettings();
        
        settings.forEach(row => {
            SYSTEM_SETTINGS[row.setting_key] = row.setting_value;
        });
        
        loggers.system.info('‚úÖ System settings loaded via DAL:', SYSTEM_SETTINGS);
        if (callback) callback(null, SYSTEM_SETTINGS);
    } catch (error) {
        loggers.system.error('Failed to load system settings:', error);
        if (callback) callback(error);
    }
}

// Load settings on startup (with delay to ensure DB is ready)
setTimeout(() => {
    loadSystemSettings((err, settings) => {
        if (!err) {
            // Update config with loaded timezone
            config.system.timezone = settings.timezone;
        }
    });
}, 1000);

// Start metrics collection
setTimeout(() => metricsManager.initializeMetricsCollection(), 5000);

// Start metrics collection
setTimeout(() => metricsManager.initializeMetricsCollection(), 5000);

// Additional manager initialization (integrationManager and metricsManager are already defined above)
// Enterprise Engines - variables are already declared above
let performanceOptimizationEngine = null;

// Start metrics collection
setTimeout(() => metricsManager.initializeMetricsCollection(), 5000);

// User Management Class
class UserManager {
    constructor() {
        this.jwtSecret = config.auth.jwtSecret;
        this.initializeDefaultAdmin();
    }

    async initializeDefaultAdmin() {
        try {
            // Check if admin user exists using DAL
            const adminUser = await dal.getUserByUsername('admin');
            
            if (!adminUser) {
                // Create default admin user using DAL - require env var
                const defaultPassword = process.env.AUTH_PASSWORD || (() => {
                    throw new Error('AUTH_PASSWORD environment variable required for admin creation');
                })();
                const passwordHash = await bcrypt.hash(defaultPassword, config.auth.saltRounds);
                
                const newAdmin = await dal.createUser({
                    username: 'admin',
                    email: 'admin@enterprise.local',
                    password_hash: passwordHash,
                    role: 'admin'
                });
                
                if (newAdmin) {
                    loggers.system.info('‚úÖ Default admin user created', {
                        username: 'admin',
                        password: defaultPassword
                    });
                    console.log(`\nüîê Default Admin Created:`);
                    console.log(`   Username: admin`);
                    console.log(`   Password: ${defaultPassword}`);
                    console.log(`   Please change this password after first login!\n`);
                } else {
                    loggers.system.error('Failed to create default admin user');
                }
            }
        } catch (error) {
            loggers.system.error('Error initializing default admin:', error);
        }
    }

    async authenticateUser(username, password) {
        try {
            console.log('üîç authenticateUser called with:', { username, passwordLength: password.length });
            
            // Get user using DAL
            const user = await dal.getUserByUsername(username);
            console.log('üîç User from DB:', user ? { id: user.id, username: user.username, hasHash: !!user.password_hash, hashLength: user.password_hash?.length } : 'null');
            
            if (!user) {
                console.log('‚ùå User not found in DB');
                return { success: false, error: 'Invalid credentials' };
            }

            console.log('üß™ Comparing password:', password, 'with hash:', user.password_hash);
            const validPassword = await bcrypt.compare(password, user.password_hash);
            console.log('üîç bcrypt.compare result:', validPassword);
            
            if (validPassword) {
                // Update last login using DAL
                const utcNow = moment.utc().format('YYYY-MM-DD HH:mm:ss');
                await dal.updateUser(user.id, { last_login: utcNow });
                
                return {
                    success: true,
                    user: {
                        id: user.id,
                        username: user.username,
                        email: user.email,
                        role: user.role
                    }
                };
            } else {
                return { success: false, error: 'Invalid credentials' };
            }
        } catch (error) {
            loggers.system.error('Authentication error:', error);
            return { success: false, error: 'Authentication failed' };
        }
    }

    generateJWT(user) {
        return jwt.sign(
            { 
                id: user.id, 
                username: user.username, 
                role: user.role 
            },
            this.jwtSecret,
            { expiresIn: '24h' }
        );
    }

    verifyJWT(token) {
        try {
            return jwt.verify(token, this.jwtSecret);
        } catch (error) {
            return null;
        }
    }
}

const userManager = new UserManager();

// Authentication middleware - logs to security.log file
const requireAuth = (req, res, next) => {
    const token = req.session?.token;
    
    loggers.security.info(`Auth check for ${req.path}: token=${token ? 'present' : 'missing'}`);
    
    if (!token) {
        loggers.security.warn(`No token for ${req.path}, redirecting to login`);
        if (req.path.startsWith('/api/')) {
            return res.status(401).json({ error: 'Authentication required' });
        }
        return res.redirect('/login');
    }

    const user = userManager.verifyJWT(token);
    if (!user) {
        loggers.security.warn(`Invalid token for ${req.path}, redirecting to login`);
        if (req.path.startsWith('/api/')) {
            return res.status(401).json({ error: 'Invalid token' });
        }
        return res.redirect('/login');
    }

    loggers.security.info(`Auth successful for ${req.path}, user: ${user.username}`);
    req.user = user;
    
    // Update session last_activity (use explicit UTC time)
    const utcNow = moment.utc().format('YYYY-MM-DD HH:mm:ss');
    db.run(
        `UPDATE user_sessions SET last_activity = ? WHERE session_token = ? AND is_active = 1`,
        [utcNow, token],
        (err) => {
            if (err) loggers.system.error('Failed to update session activity:', err);
        }
    );
    
    next();
};

const requireAdmin = (req, res, next) => {
    if (req.user?.role !== 'admin') {
        if (req.path.startsWith('/api/')) {
            return res.status(403).json({ error: 'Admin access required' });
        }
        return res.status(403).send('<h1>Access Denied</h1><p>Administrator privileges required</p>');
    }
    next();
};

// Rate limiting middleware
const rateLimiter = (options = {}) => {
    const { maxRequests = 100, windowMs = 60000, blockDurationMs = 300000 } = options;
    
    return (req, res, next) => {
        const ip = req.ip || req.connection.remoteAddress;
        const endpoint = req.path;
        const now = new Date();
        
        // Check if IP is currently blocked
        db.get(
            'SELECT blocked_until FROM rate_limits WHERE ip_address = ? AND endpoint = ? AND blocked_until > ?',
            [ip, endpoint, now.toISOString()],
            (err, blocked) => {
                if (blocked) {
                    return res.status(429).json({ 
                        error: 'Too many requests. Please try again later.',
                        retryAfter: Math.ceil((new Date(blocked.blocked_until) - now) / 1000)
                    });
                }
                
                // Clean up old entries
                const windowStart = new Date(now.getTime() - windowMs);
                db.run(
                    'DELETE FROM rate_limits WHERE ip_address = ? AND endpoint = ? AND window_start < ?',
                    [ip, endpoint, windowStart.toISOString()]
                );
                
                // Check current request count
                db.get(
                    'SELECT request_count FROM rate_limits WHERE ip_address = ? AND endpoint = ? AND window_start > ?',
                    [ip, endpoint, windowStart.toISOString()],
                    (err, record) => {
                        if (record && record.request_count >= maxRequests) {
                            // Block the IP
                            const blockedUntil = new Date(now.getTime() + blockDurationMs);
                            db.run(
                                'UPDATE rate_limits SET blocked_until = ? WHERE ip_address = ? AND endpoint = ?',
                                [blockedUntil.toISOString(), ip, endpoint]
                            );
                            
                            loggers.security.warn('Rate limit exceeded', { ip, endpoint, count: record.request_count });
                            
                            return res.status(429).json({ 
                                error: 'Too many requests. Your IP has been temporarily blocked.',
                                retryAfter: Math.ceil(blockDurationMs / 1000)
                            });
                        }
                        
                        // Increment or create record
                        if (record) {
                            db.run(
                                'UPDATE rate_limits SET request_count = request_count + 1 WHERE ip_address = ? AND endpoint = ?',
                                [ip, endpoint]
                            );
                        } else {
                            db.run(
                                'INSERT INTO rate_limits (ip_address, endpoint, request_count, window_start) VALUES (?, ?, 1, ?)',
                                [ip, endpoint, now.toISOString()]
                            );
                        }
                        
                        next();
                    }
                );
            }
        );
    };
};

// Legacy ESP32 authentication
const legacyAuth = (req, res, next) => {
    const credentials = basicAuth(req);
    const validUsername = process.env.AUTH_USERNAME || 'admin';
    const validPassword = process.env.AUTH_PASSWORD || (() => {
        throw new Error('AUTH_PASSWORD environment variable required for legacy auth');
    })();
    
    if (!credentials || credentials.name !== validUsername || credentials.pass !== validPassword) {
        res.status(401);
        res.setHeader('WWW-Authenticate', 'Basic realm="DSC Logging Server"');
        res.end('Access denied');
        return;
    }
    next();
};

// =============================================================================
// ROUTES
// =============================================================================

// Root redirect
app.get('/', (req, res) => {
    res.redirect('/dashboard');
});

// Login page
app.get('/login', (req, res) => {
    if (req.session?.token && userManager.verifyJWT(req.session.token)) {
        return res.redirect('/dashboard');
    }

    res.send(`
        <!DOCTYPE html>
        <html lang="en" data-theme="auto">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Enterprise Login | Universal Logging Platform</title>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
            <style>
                :root {
                    /* Light Theme Colors */
                    --bg-primary: #ffffff;
                    --bg-secondary: #f8fafc;
                    --bg-tertiary: #f1f5f9;
                    --text-primary: #1e293b;
                    --text-secondary: #475569;
                    --text-muted: #64748b;
                    --border-color: #e2e8f0;
                    --success-color: #10b981;
                    --warning-color: #f59e0b;
                    --error-color: #ef4444;
                    --shadow-light: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
                    --shadow-medium: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
                    --shadow-glow: 0 0 20px rgba(59, 130, 246, 0.3);
                    
                    /* Ocean Gradients */
                    --gradient-ocean: linear-gradient(135deg, #0ea5e9 0%, #3b82f6 50%, #6366f1 100%);
                    --gradient-deep-blue: linear-gradient(135deg, #1e40af 0%, #1e3a8a 50%, #312e81 100%);
                    --gradient-sky: linear-gradient(135deg, #7dd3fc 0%, #38bdf8 50%, #0ea5e9 100%);
                    
                    /* Standard Colors - Using Ocean Gradient as Primary */
                    --accent-primary: var(--gradient-ocean);
                    --btn-primary: var(--gradient-ocean);
                    --accent-secondary: #1d4ed8;
                    --login-bg: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 50%, #60a5fa 100%);
                }

                /* Dark Theme */
                [data-theme="dark"] {
                    --bg-primary: #1e293b;
                    --bg-secondary: #334155;
                    --bg-tertiary: #475569;
                    --text-primary: #f1f5f9;
                    --text-secondary: #cbd5e1;
                    --text-muted: #94a3b8;
                    --border-color: #475569;
                    --shadow-light: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
                    --shadow-medium: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
                    --shadow-glow: 0 0 20px rgba(96, 165, 250, 0.4);
                    
                    /* Ocean Gradients for Dark Theme */
                    --gradient-ocean: linear-gradient(135deg, #1e40af 0%, #1e3a8a 50%, #312e81 100%);
                    --gradient-deep-blue: linear-gradient(135deg, #0c1e3f 0%, #1e293b 50%, #334155 100%);
                    --gradient-sky: linear-gradient(135deg, #1e40af 0%, #3730a3 50%, #4338ca 100%);
                    
                    /* Standard Colors - Using Ocean Gradient as Primary */
                    --accent-primary: var(--gradient-ocean);
                    --btn-primary: var(--gradient-ocean);
                    --accent-secondary: #3b82f6;
                    --login-bg: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
                }

                /* Auto Theme - follows system preference */
                @media (prefers-color-scheme: dark) {
                    [data-theme="auto"] {
                        --bg-primary: #1e293b;
                        --bg-secondary: #334155;
                        --bg-tertiary: #475569;
                        --text-primary: #f1f5f9;
                        --text-secondary: #cbd5e1;
                        --text-muted: #94a3b8;
                        --border-color: #475569;
                        --shadow-light: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
                        --shadow-medium: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
                        --shadow-glow: 0 0 20px rgba(96, 165, 250, 0.4);
                        
                        /* Ocean Gradients for Auto Dark Mode */
                        --gradient-ocean: linear-gradient(135deg, #1e40af 0%, #1e3a8a 50%, #312e81 100%);
                        --gradient-deep-blue: linear-gradient(135deg, #0c1e3f 0%, #1e293b 50%, #334155 100%);
                        --gradient-sky: linear-gradient(135deg, #1e40af 0%, #3730a3 50%, #4338ca 100%);
                        
                        /* Standard Colors - Using Ocean Gradient as Primary */
                        --accent-primary: var(--gradient-ocean);
                        --btn-primary: var(--gradient-ocean);
                        --accent-secondary: #3b82f6;
                        --login-bg: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
                    }
                }

                * { margin: 0; padding: 0; box-sizing: border-box; }
                body {
                    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    background: var(--login-bg);
                    min-height: 100vh;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    position: relative;
                    overflow: hidden;
                    transition: all 0.3s ease;
                }
                
                /* Animated background elements */
                body::before {
                    content: '';
                    position: absolute;
                    top: -50%;
                    left: -50%;
                    width: 200%;
                    height: 200%;
                    background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
                    animation: shimmer 3s ease-in-out infinite;
                }
                
                @keyframes shimmer {
                    0%, 100% { transform: translateX(-100%) translateY(-100%) rotate(30deg); }
                    50% { transform: translateX(100%) translateY(100%) rotate(30deg); }
                }
                
                .login-container {
                    background: var(--bg-primary);
                    backdrop-filter: blur(20px);
                    border-radius: 20px;
                    box-shadow: var(--shadow-medium);
                    overflow: hidden;
                    width: 100%;
                    max-width: 420px;
                    margin: 2rem;
                    border: 1px solid var(--border-color);
                    position: relative;
                    z-index: 1;
                    transition: all 0.3s ease;
                }
                
                .login-header {
                    background: var(--gradient-ocean);
                    color: white;
                    padding: 2.5rem 2rem;
                    text-align: center;
                    position: relative;
                    overflow: hidden;
                }
                
                .login-header::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
                    animation: headerShimmer 4s ease-in-out infinite;
                }
                
                @keyframes headerShimmer {
                    0%, 100% { transform: translateX(-100%); }
                    50% { transform: translateX(100%); }
                }
                
                .login-header h1 {
                    font-size: 2rem;
                    margin-bottom: 0.5rem;
                    font-weight: 700;
                    position: relative;
                    z-index: 1;
                    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                }
                
                .login-header p {
                    opacity: 0.9;
                    font-size: 0.95rem;
                    position: relative;
                    z-index: 1;
                }
                
                .login-form {
                    padding: 2.5rem 2rem;
                }
                
                /* Theme Toggle Button */
                .theme-toggle {
                    position: absolute;
                    top: 1rem;
                    right: 1rem;
                    background: var(--gradient-sky);
                    border: 2px solid rgba(255, 255, 255, 0.3);
                    color: white;
                    padding: 0.75rem;
                    border-radius: 50%;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    font-size: 1.2rem;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
                    z-index: 10;
                }
                .theme-toggle:hover {
                    transform: scale(1.1) rotate(15deg);
                    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
                    background: var(--gradient-deep-blue);
                }
                
                .form-group {
                    margin-bottom: 1.75rem;
                }
                
                .form-group label {
                    display: block;
                    margin-bottom: 0.75rem;
                    font-weight: 600;
                    color: var(--text-primary);
                    font-size: 0.95rem;
                }
                
                .form-group input {
                    width: 100%;
                    padding: 1rem 1.25rem;
                    border: 2px solid var(--border-color);
                    border-radius: 12px;
                    font-size: 1rem;
                    transition: all 0.3s ease;
                    background: var(--bg-secondary);
                    color: var(--text-primary);
                }
                
                .form-group input:focus {
                    outline: none;
                    border-color: var(--accent-primary);
                    box-shadow: var(--shadow-glow);
                    transform: translateY(-1px);
                }
                
                .login-btn {
                    width: 100%;
                    padding: 1.25rem;
                    background: var(--gradient-ocean);
                    color: white;
                    border: none;
                    border-radius: 12px;
                    font-size: 1.05rem;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    position: relative;
                    overflow: hidden;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                }
                
                .login-btn::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: -100%;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
                    transition: left 0.5s;
                }
                
                .login-btn:hover::before {
                    left: 100%;
                }
                
                .login-btn:hover {
                    transform: translateY(-3px);
                    box-shadow: var(--shadow-glow);
                    background: var(--gradient-deep-blue);
                }
                
                .login-btn:active {
                    transform: translateY(-1px);
                    box-shadow: 0 8px 20px rgba(29, 78, 216, 0.3);
                }
                
                .error-message {
                    margin-top: 1.5rem;
                    padding: 1rem;
                    background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
                    border: 1px solid #fecaca;
                    border-radius: 12px;
                    color: #dc2626;
                    display: none;
                    font-weight: 500;
                }
                
                .login-footer {
                    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
                    padding: 1.75rem;
                    text-align: center;
                    border-top: 1px solid #e2e8f0;
                    color: #64748b;
                    font-size: 0.85rem;
                }
                
                .welcome-message {
                    background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
                    padding: 1.25rem;
                    border-radius: 12px;
                    margin-bottom: 1.5rem;
                    font-size: 0.9rem;
                    color: #1e40af;
                    border: 1px solid #93c5fd;
                    font-weight: 500;
                }
                
                /* Responsive design */
                @media (max-width: 480px) {
                    .login-container {
                        margin: 1rem;
                        border-radius: 16px;
                    }
                    
                    .login-header {
                        padding: 2rem 1.5rem;
                    }
                    
                    .login-form {
                        padding: 2rem 1.5rem;
                    }
                    
                    .login-header h1 {
                        font-size: 1.75rem;
                    }
                }
            </style>
        </head>
        <body>
            <div class="login-container">
                <div class="login-header">
                    <h1>ÔøΩ Enterprise Logger</h1>
                    <p>Advanced Infrastructure Monitoring Platform</p>
                </div>
                
                <div class="login-form">
                    <div class="welcome-message">
                        <strong>üöÄ Welcome to Enterprise Logging Platform</strong><br>
                        Secure access to your infrastructure monitoring dashboard
                    </div>
                    
                    <form id="loginForm">
                        <div class="form-group">
                            <label for="username">Username</label>
                            <input type="text" id="username" name="username" placeholder="Enter username" autocomplete="username" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="password">Password</label>
                            <input type="password" id="password" name="password" placeholder="Enter your password" autocomplete="current-password" required>
                        </div>
                        
                        <button type="submit" class="login-btn" id="loginBtn">
                            Sign In
                        </button>
                    </form>
                    
                    <div id="error-message" class="error-message"></div>
                </div>
                
                <div class="login-footer">
                    <strong>Enterprise Logging Platform v${config.system.version}</strong><br>
                    Multi-Source Infrastructure Monitoring
                </div>
            </div>

            <script>
                // Enhanced theme management with light/dark/auto
                function toggleTheme() {
                    const html = document.documentElement;
                    const currentTheme = html.getAttribute('data-theme') || 'auto';
                    let newTheme;
                    
                    // Cycle through: auto -> light -> dark -> auto
                    switch(currentTheme) {
                        case 'auto':
                            newTheme = 'light';
                            break;
                        case 'light':
                            newTheme = 'dark';
                            break;
                        case 'dark':
                            newTheme = 'auto';
                            break;
                        default:
                            newTheme = 'auto';
                    }
                    
                    html.setAttribute('data-theme', newTheme);
                    localStorage.setItem('theme', newTheme);
                    updateThemeIcon(newTheme);
                }
                
                function updateThemeIcon(theme) {
                    const themeButton = document.querySelector('.theme-toggle i');
                    if (themeButton) {
                        switch(theme) {
                            case 'light':
                                themeButton.className = 'fas fa-sun';
                                themeButton.parentElement.title = 'Light Mode (Click for Dark)';
                                break;
                            case 'dark':
                                themeButton.className = 'fas fa-moon';
                                themeButton.parentElement.title = 'Dark Mode (Click for Auto)';
                                break;
                            case 'auto':
                            default:
                                themeButton.className = 'fas fa-adjust';
                                themeButton.parentElement.title = 'Auto Mode (Click for Light)';
                                break;
                        }
                    }
                }
                
                // Initialize theme
                function initializeTheme() {
                    const savedTheme = localStorage.getItem('theme') || 'auto';
                    document.documentElement.setAttribute('data-theme', savedTheme);
                    updateThemeIcon(savedTheme);
                }
                
                // Initialize theme on page load
                document.addEventListener('DOMContentLoaded', initializeTheme);
                
                document.getElementById('loginForm').addEventListener('submit', async function(e) {
                    e.preventDefault();
                    
                    const btn = document.getElementById('loginBtn');
                    const errorDiv = document.getElementById('error-message');
                    
                    btn.disabled = true;
                    btn.textContent = 'Signing in...';
                    errorDiv.style.display = 'none';
                    
                    try {
                        const formData = new FormData(this);
                        const response = await fetch('/api/auth/login', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                username: formData.get('username'),
                                password: formData.get('password')
                            })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            btn.textContent = 'Success! Redirecting...';
                            setTimeout(() => {
                                window.location.href = '/dashboard';
                            }, 500);
                        } else {
                            throw new Error(result.error);
                        }
                    } catch (error) {
                        errorDiv.textContent = error.message;
                        errorDiv.style.display = 'block';
                        btn.disabled = false;
                        btn.textContent = 'Sign In';
                    }
                });
            </script>
        </body>
        </html>
    `);
});

// Login API
app.post('/api/auth/login', authLimiter, async (req, res) => {
    try {
        console.log('üîê Login endpoint called');
        const { username, password } = req.body;
        console.log(`üîê Login attempt for username: ${username}`);
        
        if (!username || !password) {
            console.log('‚ùå Missing credentials');
            return res.status(400).json({ error: 'Username and password required' });
        }

        console.log('üîç Calling authenticateUser...');
        const result = await userManager.authenticateUser(username, password);
        console.log('üîç Auth result:', result);
        
        if (result.success) {
            const token = userManager.generateJWT(result.user);
            req.session.token = token;
            req.session.userId = result.user.id;
            
            loggers.audit.info('User login successful', { 
                username: result.user.username,
                ip: req.ip 
            });
            
            // Log successful login to database
            logToDatabase(`User login: ${result.user.username} from ${req.ip}`, 'info', 'auth', 'logging-server');
            
            // Log login activity
            await logActivity(result.user.id, 'login', '/api/auth/login', `Successful login from ${req.ip}`, req);
            
            // Create session record in database
            const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours from now
            const utcNow = moment.utc().format('YYYY-MM-DD HH:mm:ss');
            db.run(
                `INSERT INTO user_sessions (user_id, session_token, ip_address, user_agent, created_at, last_activity, expires_at) 
                 VALUES (?, ?, ?, ?, ?, ?, ?)`,
                [result.user.id, token, req.ip || req.connection.remoteAddress, req.get('User-Agent'), utcNow, utcNow, expiresAt.toISOString()],
                (err) => {
                    if (err) {
                        loggers.system.error('Failed to create session record:', err);
                    }
                }
            );
            
            res.json({
                success: true,
                token: token,
                user: result.user
            });
        } else {
            loggers.audit.warn('User login failed', { 
                username,
                ip: req.ip,
                error: result.error 
            });
            
            // Track failed login attempt for security monitoring
            trackFailedLogin(req.ip || req.connection.remoteAddress, username);
            
            // Log failed login to database
            logToDatabase(`Failed login attempt: ${username} from ${req.ip}`, 'warn', 'auth', 'logging-server');
            
            res.status(401).json({ error: result.error });
        }
    } catch (error) {
        console.error('üö® Login endpoint error:', error);
        loggers.audit.error('Login error:', error);
        loggers.system.error('Login endpoint error details:', {
            message: error.message,
            stack: error.stack,
            username: req.body?.username
        });
        res.status(500).json({ error: 'Authentication failed' });
    }
});

// Logout API
app.post('/api/auth/logout', async (req, res) => {
    const token = req.session?.token;
    
    // Log logout activity before destroying session
    if (req.user) {
        await logActivity(req.user.id, 'logout', '/api/auth/logout', `User logged out from ${req.ip}`, req);
    }
    
    if (token) {
        // Mark session as inactive in database
        db.run(
            `UPDATE user_sessions SET is_active = 0 WHERE session_token = ?`,
            [token],
            (err) => {
                if (err) loggers.system.error('Failed to deactivate session:', err);
            }
        );
    }
    req.session.destroy();
    res.json({ success: true });
});

// Logout GET route
app.get('/logout', async (req, res) => {
    const token = req.session?.token;
    
    // Log logout activity before destroying session
    if (req.user) {
        await logActivity(req.user.id, 'logout', '/logout', `User logged out from ${req.ip}`, req);
    }
    
    if (token) {
        // Mark session as inactive in database
        db.run(
            `UPDATE user_sessions SET is_active = 0 WHERE session_token = ?`,
            [token],
            (err) => {
                if (err) loggers.system.error('Failed to deactivate session:', err);
            }
        );
    }
    req.session.destroy();
    res.redirect('/');
});

// User Management API
app.get('/api/users', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    try {
        // Get all users using DAL
        const users = await dal.getAllUsers();
        
        // Format timestamps
        const usersWithFormattedDates = users.map(user => ({
            ...user,
            created_at_formatted: formatSQLiteTimestamp(user.created_at),
            last_login_formatted: formatSQLiteTimestamp(user.last_login)
        }));
        
        res.json({ success: true, users: usersWithFormattedDates });
    } catch (error) {
        loggers.system.error('Error fetching users:', error);
        res.status(500).json({ error: 'Database error' });
    }
});

app.post('/api/users', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    try {
        const { username, email, password, role } = req.body;
        
        if (!username || !email || !password || !role) {
            return res.status(400).json({ error: 'All fields are required' });
        }
        
        if (!['admin', 'user'].includes(role)) {
            return res.status(400).json({ error: 'Invalid role. Must be admin or user' });
        }
        
        // Check if username already exists using DAL
        const existingUser = await dal.getUserByUsername(username);
        if (existingUser) {
            return res.status(400).json({ error: 'Username already exists' });
        }
        
        // Hash password and create user using DAL
        const passwordHash = await bcrypt.hash(password, config.auth.saltRounds);
        
        const newUser = await dal.createUser({
            username,
            email,
            password_hash: passwordHash,
            role
        });
        
        if (newUser) {
            loggers.audit.info('User created', { 
                newUserId: newUser.id,
                newUsername: username,
                newUserRole: role,
                createdBy: req.user.username 
            });
            
            // Log admin activity using DAL
            await dal.logActivity(req.user.id, 'admin_action', '/api/users', `Created new user: ${username} (${role})`, req);
            
            res.json({
                success: true,
                message: 'User created successfully',
                userId: newUser.id
            });
        } else {
            res.status(500).json({ error: 'Failed to create user' });
        }
    } catch (error) {
        loggers.audit.error('User creation error:', error);
        res.status(500).json({ error: 'Failed to create user' });
    }
});

app.put('/api/users/:id', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    try {
        const userId = req.params.id;
        const { username, email, role, password } = req.body;
        
        if (!username || !email || !role) {
            return res.status(400).json({ error: 'Username, email, and role are required' });
        }
        
        if (!['admin', 'user'].includes(role)) {
            return res.status(400).json({ error: 'Invalid role. Must be admin or user' });
        }
        
        // Prepare update data using DAL
        const updateData = { username, email, role };
        
        // If password is provided, hash and include it
        if (password) {
            const passwordHash = await bcrypt.hash(password, config.auth.saltRounds);
            updateData.password_hash = passwordHash;
        }
        
        const result = await dal.updateUser(userId, updateData);
        
        if (result) {
            loggers.audit.info('User updated', { 
                updatedUserId: userId,
                updatedUsername: username,
                updatedBy: req.user.username 
            });
            
            res.json({ success: true, message: 'User updated successfully' });
        } else {
            res.status(404).json({ error: 'User not found' });
        }
    } catch (error) {
        loggers.audit.error('User update error:', error);
        res.status(500).json({ error: 'Failed to update user' });
    }
});

app.delete('/api/users/:id', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    try {
        const userId = req.params.id;
        
        // Use DAL method to safely delete user (includes admin protection)
        const result = await dal.deleteUser(userId);
        
        if (result === 'LAST_ADMIN') {
            return res.status(400).json({ error: 'Cannot delete the last admin user' });
        }
        
        if (result) {
            loggers.audit.info('User deleted', { 
                deletedUserId: userId,
                deletedBy: req.user.username 
            });
            
            res.json({ success: true, message: 'User deleted successfully' });
        } else {
            res.status(404).json({ error: 'User not found' });
        }
    } catch (error) {
        loggers.audit.error('User deletion error:', error);
        res.status(500).json({ error: 'Failed to delete user' });
    }
});

// Settings API endpoints
app.get('/api/settings', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    // Return comprehensive enterprise settings configuration
    res.json({
        system: {
            name: config.system.name || 'Enterprise Logging Platform',
            version: config.system.version || '2.1.0-stable-enhanced',
            owner: config.system.owner || 'Tom Nelson',
            timezone: SYSTEM_SETTINGS.timezone || config.system.timezone || 'America/Edmonton',
            theme: SYSTEM_SETTINGS.default_theme || 'auto',
            dateFormat: SYSTEM_SETTINGS.date_format || 'MM/DD/YYYY, hh:mm:ss A'
        },
        server: {
            port: PORT,
            host: 'localhost',
            wsPort: config.integrations.websocket.port || 10181
        },
        database: {
            path: dbPath,
            retentionDays: config.maintenance?.logRetentionDays || 30
        },
        rateLimiting: {
            general: {
                enabled: true,
                windowMs: 15 * 60 * 1000, // Current: 15 minutes
                maxRequests: 100, // Current: 100 requests per window
                description: 'General API rate limiting for all endpoints'
            },
            logIngestion: {
                enabled: true,
                windowMs: 5 * 60 * 1000, // Current: 5 minutes  
                maxRequests: 1000, // Current: 1000 requests per window
                description: 'Rate limiting for log ingestion endpoints'
            },
            authentication: {
                enabled: true,
                windowMs: 15 * 60 * 1000, // Current: 15 minutes
                maxRequests: 5, // Current: 5 requests per window
                description: 'Rate limiting for authentication attempts'
            }
        },
        alerting: {
            enabled: alertingEngine ? true : false,
            rules: alertingEngine ? alertingEngine.getRules().length : 0,
            channels: {
                slack: {
                    enabled: false,
                    webhook: ''
                },
                discord: {
                    enabled: false,
                    webhook: ''
                },
                email: {
                    enabled: false,
                    smtp: ''
                }
            },
            cooldownPeriod: 300, // 5 minutes default
            maxAlertsPerHour: 10
        },
        logParsing: {
            enabled: true,
            formats: ['nginx', 'apache', 'docker', 'syslog', 'json'],
            autoDetection: true,
            enrichment: {
                geoip: true,
                userAgent: true,
                timestamp: true
            }
        },
        websocket: {
            enabled: config.integrations.websocket.enabled,
            port: config.integrations.websocket.port || 10181,
            maxConnections: 100,
            heartbeatInterval: 30000, // 30 seconds
            compression: true,
            clientFiltering: true
        },
        maintenance: {
            logRetentionDays: config.maintenance?.logRetentionDays || 30,
            backupSchedule: config.maintenance?.backupSchedule || '0 2 * * *',
            cleanupSchedule: config.maintenance?.cleanupSchedule || '0 3 * * 0',
            autoOptimize: true,
            compressionEnabled: false
        },
        integrations: {
            websocket: {
                enabled: config.integrations.websocket.enabled,
                port: config.integrations.websocket.port
            },
            mqtt: {
                enabled: config.integrations.mqtt.enabled,
                broker: config.integrations.mqtt.broker || '',
                username: config.integrations.mqtt.username || '',
                topic: config.integrations.mqtt.topic || 'enterprise/logs'
            },
            unifi: {
                enabled: config.integrations.unifi.enabled,
                host: config.integrations.unifi.host || '',
                username: config.integrations.unifi.username || '',
                site: 'default'
            },
            homeAssistant: {
                enabled: config.integrations.homeAssistant.enabled,
                host: config.integrations.homeAssistant.host || '',
                token: config.integrations.homeAssistant.token ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : ''
            }
        },
        security: {
            sessionTimeout: 24 * 60 * 60 * 1000, // 24 hours
            requireAuth: true,
            ipWhitelist: [],
            failedLoginThreshold: 5,
            accountLockoutDuration: 15 * 60 * 1000 // 15 minutes
        }
    });
});

app.put('/api/settings', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    try {
        const updates = req.body;
        const changedSettings = [];
        
        // =====================================================================
        // SYSTEM SETTINGS
        // =====================================================================
        if (updates.systemName) {
            config.system.name = updates.systemName;
            changedSettings.push('systemName');
        }
        
        if (updates.systemOwner) {
            config.system.owner = updates.systemOwner;
            changedSettings.push('systemOwner');
        }
        
        if (updates.timezone) {
            const validTimezones = moment.tz.names();
            if (validTimezones.includes(updates.timezone)) {
                config.system.timezone = updates.timezone;
                await dal.setSetting('timezone', updates.timezone);
                SYSTEM_SETTINGS.timezone = updates.timezone;
                changedSettings.push('timezone');
            }
        }
        
        if (updates.default_theme) {
            const validThemes = ['auto', 'light', 'dark', 'ocean'];
            if (validThemes.includes(updates.default_theme)) {
                await dal.setSetting('default_theme', updates.default_theme);
                SYSTEM_SETTINGS.default_theme = updates.default_theme;
                changedSettings.push('default_theme');
            }
        }
        
        // =====================================================================
        // RATE LIMITING SETTINGS
        // =====================================================================
        if (updates.rateLimiting) {
            const rateUpdates = updates.rateLimiting;
            
            // Update general rate limiting
            if (rateUpdates.general) {
                if (rateUpdates.general.windowMs && rateUpdates.general.windowMs > 0) {
                    db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                        ['rate_limit_general_window', rateUpdates.general.windowMs, req.user.id]);
                    changedSettings.push('rate_limit_general_window');
                }
                if (rateUpdates.general.maxRequests && rateUpdates.general.maxRequests > 0) {
                    db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                        ['rate_limit_general_max', rateUpdates.general.maxRequests, req.user.id]);
                    changedSettings.push('rate_limit_general_max');
                }
            }
            
            // Update log ingestion rate limiting
            if (rateUpdates.logIngestion) {
                if (rateUpdates.logIngestion.windowMs && rateUpdates.logIngestion.windowMs > 0) {
                    db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                        ['rate_limit_logs_window', rateUpdates.logIngestion.windowMs, req.user.id]);
                    changedSettings.push('rate_limit_logs_window');
                }
                if (rateUpdates.logIngestion.maxRequests && rateUpdates.logIngestion.maxRequests > 0) {
                    db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                        ['rate_limit_logs_max', rateUpdates.logIngestion.maxRequests, req.user.id]);
                    changedSettings.push('rate_limit_logs_max');
                }
            }
            
            // Update auth rate limiting
            if (rateUpdates.authentication) {
                if (rateUpdates.authentication.windowMs && rateUpdates.authentication.windowMs > 0) {
                    db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                        ['rate_limit_auth_window', rateUpdates.authentication.windowMs, req.user.id]);
                    changedSettings.push('rate_limit_auth_window');
                }
                if (rateUpdates.authentication.maxRequests && rateUpdates.authentication.maxRequests > 0) {
                    db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                        ['rate_limit_auth_max', rateUpdates.authentication.maxRequests, req.user.id]);
                    changedSettings.push('rate_limit_auth_max');
                }
            }
        }
        
        // =====================================================================
        // ALERTING SETTINGS
        // =====================================================================
        if (updates.alerting) {
            const alertUpdates = updates.alerting;
            
            if (typeof alertUpdates.enabled !== 'undefined') {
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['alerting_enabled', alertUpdates.enabled ? 'true' : 'false', req.user.id]);
                changedSettings.push('alerting_enabled');
            }
            
            if (alertUpdates.cooldownPeriod && alertUpdates.cooldownPeriod > 0) {
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['alerting_cooldown', alertUpdates.cooldownPeriod, req.user.id]);
                changedSettings.push('alerting_cooldown');
            }
            
            if (alertUpdates.maxAlertsPerHour && alertUpdates.maxAlertsPerHour > 0) {
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['alerting_max_hourly', alertUpdates.maxAlertsPerHour, req.user.id]);
                changedSettings.push('alerting_max_hourly');
            }
            
            // Update alert channels
            if (alertUpdates.channels) {
                if (alertUpdates.channels.slack) {
                    if (typeof alertUpdates.channels.slack.enabled !== 'undefined') {
                        db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                            ['alert_slack_enabled', alertUpdates.channels.slack.enabled ? 'true' : 'false', req.user.id]);
                    }
                    if (alertUpdates.channels.slack.webhook) {
                        db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                            ['alert_slack_webhook', alertUpdates.channels.slack.webhook, req.user.id]);
                    }
                    changedSettings.push('slack_alerts');
                }
                
                if (alertUpdates.channels.discord) {
                    if (typeof alertUpdates.channels.discord.enabled !== 'undefined') {
                        db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                            ['alert_discord_enabled', alertUpdates.channels.discord.enabled ? 'true' : 'false', req.user.id]);
                    }
                    if (alertUpdates.channels.discord.webhook) {
                        db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                            ['alert_discord_webhook', alertUpdates.channels.discord.webhook, req.user.id]);
                    }
                    changedSettings.push('discord_alerts');
                }
            }
        }
        
        // =====================================================================
        // WEBSOCKET SETTINGS
        // =====================================================================
        if (updates.websocket) {
            const wsUpdates = updates.websocket;
            
            if (typeof wsUpdates.enabled !== 'undefined') {
                config.integrations.websocket.enabled = wsUpdates.enabled;
                changedSettings.push('websocket_enabled');
            }
            
            if (wsUpdates.maxConnections && wsUpdates.maxConnections > 0) {
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['websocket_max_connections', wsUpdates.maxConnections, req.user.id]);
                changedSettings.push('websocket_max_connections');
            }
            
            if (wsUpdates.heartbeatInterval && wsUpdates.heartbeatInterval > 0) {
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['websocket_heartbeat', wsUpdates.heartbeatInterval, req.user.id]);
                changedSettings.push('websocket_heartbeat');
            }
        }
        
        // =====================================================================
        // MAINTENANCE SETTINGS
        // =====================================================================
        if (updates.maintenance) {
            const maintUpdates = updates.maintenance;
            
            if (maintUpdates.logRetentionDays && maintUpdates.logRetentionDays > 0) {
                config.maintenance.logRetentionDays = maintUpdates.logRetentionDays;
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['log_retention_days', maintUpdates.logRetentionDays, req.user.id]);
                changedSettings.push('log_retention_days');
            }
            
            if (maintUpdates.backupSchedule) {
                config.maintenance.backupSchedule = maintUpdates.backupSchedule;
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['backup_schedule', maintUpdates.backupSchedule, req.user.id]);
                changedSettings.push('backup_schedule');
            }
            
            if (maintUpdates.cleanupSchedule) {
                config.maintenance.cleanupSchedule = maintUpdates.cleanupSchedule;
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['cleanup_schedule', maintUpdates.cleanupSchedule, req.user.id]);
                changedSettings.push('cleanup_schedule');
            }
        }
        
        // =====================================================================
        // INTEGRATION SETTINGS (Legacy support)
        // =====================================================================
        if (typeof updates.wsEnabled !== 'undefined') config.integrations.websocket.enabled = updates.wsEnabled;
        if (typeof updates.mqttEnabled !== 'undefined') config.integrations.mqtt.enabled = updates.mqttEnabled;
        if (updates.mqttBroker) config.integrations.mqtt.broker = updates.mqttBroker;
        if (updates.mqttUsername) config.integrations.mqtt.username = updates.mqttUsername;
        if (updates.mqttPassword) config.integrations.mqtt.password = updates.mqttPassword;
        if (updates.mqttTopic) config.integrations.mqtt.topic = updates.mqttTopic;
        
        if (typeof updates.unifiEnabled !== 'undefined') config.integrations.unifi.enabled = updates.unifiEnabled;
        if (updates.unifiHost) config.integrations.unifi.host = updates.unifiHost;
        if (updates.unifiUsername) config.integrations.unifi.username = updates.unifiUsername;
        if (updates.unifiPassword) config.integrations.unifi.password = updates.unifiPassword;
        if (updates.unifiSite) config.integrations.unifi.site = updates.unifiSite;
        
        if (typeof updates.haEnabled !== 'undefined') config.integrations.homeAssistant.enabled = updates.haEnabled;
        if (updates.haHost) config.integrations.homeAssistant.host = updates.haHost;
        if (updates.haToken) config.integrations.homeAssistant.token = updates.haToken;
        
        loggers.audit.info('Enterprise settings updated', { 
            updatedBy: req.user.username,
            settingsChanged: changedSettings,
            totalChanges: changedSettings.length
        });
        
        const requiresRestart = changedSettings.some(setting => 
            setting.includes('rate_limit') || 
            setting.includes('websocket') || 
            setting === 'websocket_enabled'
        );
        
        res.json({ 
            success: true, 
            message: `Settings saved successfully. ${changedSettings.length} setting(s) updated.${requiresRestart ? ' Server restart required for rate limiting changes.' : ''}`,
            changedSettings: changedSettings,
            requiresRestart: requiresRestart
        });
        
    } catch (error) {
        loggers.system.error('Failed to save enterprise settings:', error);
        res.status(500).json({ error: 'Failed to save settings: ' + error.message });
    }
});

app.post('/api/settings', requireAuth, async (req, res) => {
    // Redirect POST to PUT for compatibility
    req.method = 'PUT';
    return app._router.handle(req, res);
});

// Get timezone setting (public endpoint for timestamp formatting)
app.get('/api/timezone', (req, res) => {
    res.json({ timezone: SYSTEM_SETTINGS.timezone || config.system.timezone || 'America/Edmonton' });
});

// ============================================================================
// ENTERPRISE SETTINGS API ENDPOINTS
// ============================================================================

// Get rate limiting configuration
app.get('/api/settings/rate-limiting', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    // Get current rate limiting settings from database or defaults
    db.all('SELECT setting_key, setting_value FROM system_settings WHERE setting_key LIKE "rate_limit_%"', [], (err, rows) => {
        if (err) {
            return res.status(500).json({ error: 'Failed to fetch rate limiting settings' });
        }
        
        const settings = {};
        rows.forEach(row => {
            settings[row.setting_key] = row.setting_value;
        });
        
        res.json({
            general: {
                windowMs: parseInt(settings.rate_limit_general_window) || 15 * 60 * 1000,
                maxRequests: parseInt(settings.rate_limit_general_max) || 100,
                description: 'General API rate limiting for all endpoints'
            },
            logIngestion: {
                windowMs: parseInt(settings.rate_limit_logs_window) || 5 * 60 * 1000,
                maxRequests: parseInt(settings.rate_limit_logs_max) || 1000,
                description: 'Rate limiting for log ingestion endpoints'
            },
            authentication: {
                windowMs: parseInt(settings.rate_limit_auth_window) || 15 * 60 * 1000,
                maxRequests: parseInt(settings.rate_limit_auth_max) || 5,
                description: 'Rate limiting for authentication attempts'
            }
        });
    });
});

// Get alerting configuration
app.get('/api/settings/alerting', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    db.all('SELECT setting_key, setting_value FROM system_settings WHERE setting_key LIKE "alert%" OR setting_key = "alerting_enabled" OR setting_key = "alerting_cooldown" OR setting_key = "alerting_max_hourly"', [], (err, rows) => {
        if (err) {
            return res.status(500).json({ error: 'Failed to fetch alerting settings' });
        }
        
        const settings = {};
        rows.forEach(row => {
            settings[row.setting_key] = row.setting_value;
        });
        
        res.json({
            enabled: settings.alerting_enabled === 'true',
            cooldownPeriod: parseInt(settings.alerting_cooldown) || 300,
            maxAlertsPerHour: parseInt(settings.alerting_max_hourly) || 10,
            rules: alertingEngine ? alertingEngine.getRules().length : 0,
            channels: {
                slack: {
                    enabled: settings.alert_slack_enabled === 'true',
                    webhook: settings.alert_slack_webhook ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : ''
                },
                discord: {
                    enabled: settings.alert_discord_enabled === 'true',
                    webhook: settings.alert_discord_webhook ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : ''
                }
            }
        });
    });
});

// Get WebSocket configuration
app.get('/api/settings/websocket', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    db.all('SELECT setting_key, setting_value FROM system_settings WHERE setting_key LIKE "websocket_%"', [], (err, rows) => {
        if (err) {
            return res.status(500).json({ error: 'Failed to fetch WebSocket settings' });
        }
        
        const settings = {};
        rows.forEach(row => {
            settings[row.setting_key] = row.setting_value;
        });
        
        // Get current WebSocket client count
        const clientCount = wss && wss.clients ? wss.clients.size : 0;
        
        res.json({
            enabled: config.integrations.websocket.enabled,
            port: config.integrations.websocket.port || 10181,
            maxConnections: parseInt(settings.websocket_max_connections) || 100,
            currentConnections: clientCount,
            heartbeatInterval: parseInt(settings.websocket_heartbeat) || 30000,
            compression: true,
            clientFiltering: true
        });
    });
});

// Get maintenance configuration
app.get('/api/settings/maintenance', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    db.all('SELECT setting_key, setting_value FROM system_settings WHERE setting_key IN ("log_retention_days", "backup_schedule", "cleanup_schedule")', [], (err, rows) => {
        if (err) {
            return res.status(500).json({ error: 'Failed to fetch maintenance settings' });
        }
        
        const settings = {};
        rows.forEach(row => {
            settings[row.setting_key] = row.setting_value;
        });
        
        res.json({
            logRetentionDays: parseInt(settings.log_retention_days) || config.maintenance?.logRetentionDays || 30,
            backupSchedule: settings.backup_schedule || config.maintenance?.backupSchedule || '0 2 * * *',
            cleanupSchedule: settings.cleanup_schedule || config.maintenance?.cleanupSchedule || '0 3 * * 0',
            autoOptimize: true,
            compressionEnabled: false
        });
    });
});

// Get log parsing configuration
app.get('/api/settings/log-parsing', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    res.json({
        enabled: true,
        formats: ['nginx', 'apache', 'docker', 'syslog', 'json'],
        autoDetection: true,
        enrichment: {
            geoip: true,
            userAgent: true,
            timestamp: true
        },
        customPatterns: []
    });
});

// Bulk update settings by category
app.put('/api/settings/rate-limiting', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }
    
    const updates = req.body;
    const changedSettings = [];
    
    try {
        if (updates.general) {
            if (updates.general.windowMs) {
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['rate_limit_general_window', updates.general.windowMs, req.user.id]);
                changedSettings.push('general_window');
            }
            if (updates.general.maxRequests) {
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['rate_limit_general_max', updates.general.maxRequests, req.user.id]);
                changedSettings.push('general_max');
            }
        }
        
        if (updates.logIngestion) {
            if (updates.logIngestion.windowMs) {
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['rate_limit_logs_window', updates.logIngestion.windowMs, req.user.id]);
                changedSettings.push('logs_window');
            }
            if (updates.logIngestion.maxRequests) {
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['rate_limit_logs_max', updates.logIngestion.maxRequests, req.user.id]);
                changedSettings.push('logs_max');
            }
        }
        
        if (updates.authentication) {
            if (updates.authentication.windowMs) {
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['rate_limit_auth_window', updates.authentication.windowMs, req.user.id]);
                changedSettings.push('auth_window');
            }
            if (updates.authentication.maxRequests) {
                db.run('INSERT OR REPLACE INTO system_settings (setting_key, setting_value, updated_at, updated_by) VALUES (?, ?, CURRENT_TIMESTAMP, ?)',
                    ['rate_limit_auth_max', updates.authentication.maxRequests, req.user.id]);
                changedSettings.push('auth_max');
            }
        }
        
        loggers.audit.info('Rate limiting settings updated', {
            updatedBy: req.user.username,
            changes: changedSettings
        });
        
        res.json({
            success: true,
            message: `Rate limiting settings updated. ${changedSettings.length} setting(s) changed. Server restart required.`,
            changedSettings: changedSettings,
            requiresRestart: true
        });
        
    } catch (error) {
        loggers.system.error('Failed to update rate limiting settings:', error);
        res.status(500).json({ error: 'Failed to update settings: ' + error.message });
    }
});

// Update a specific system setting in database (admin only)
app.put('/api/settings/:key', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Access denied' });
    }

    const { key } = req.params;
    const { value } = req.body;

    if (!value) {
        return res.status(400).json({ error: 'Setting value is required' });
    }

    // Validate timezone if that's what we're updating
    if (key === 'timezone') {
        const validTimezones = moment.tz.names();
        if (!validTimezones.includes(value)) {
            return res.status(400).json({ error: 'Invalid timezone. Must be a valid IANA timezone.' });
        }
    }

    // Validate theme if that's what we're updating
    if (key === 'default_theme') {
        const validThemes = ['auto', 'light', 'dark', 'ocean'];
        if (!validThemes.includes(value)) {
            return res.status(400).json({ error: 'Invalid theme. Must be auto, light, dark, or ocean.' });
        }
    }

    try {
        const result = await dal.setSetting(key, value);

        if (!result) {
            return res.status(404).json({ error: 'Setting not found' });
        }

        // Update the cached settings
        SYSTEM_SETTINGS[key] = value;

        // Update config if timezone changed
        if (key === 'timezone') {
            config.system.timezone = value;
        }

        loggers.system.info(`‚öôÔ∏è  Setting '${key}' updated to '${value}' by user ${req.user.username}`);
        res.json({ success: true, setting_key: key, setting_value: value });
    } catch (error) {
        loggers.system.error('‚ùå Failed to update setting:', error);
        res.status(500).json({ error: 'Failed to update setting' });
    }
});

// Get current theme preference (public authenticated endpoint)
app.get('/api/settings/theme', requireAuth, (req, res) => {
    res.json({ theme: SYSTEM_SETTINGS.default_theme || 'auto' });
});

// ============================================================================
// USER THEME CUSTOMIZATION API ENDPOINTS
// ============================================================================

// Get user's custom theme preferences
app.get('/api/user/theme', requireAuth, (req, res) => {
    db.get(
        'SELECT * FROM user_theme_preferences WHERE user_id = ?',
        [req.user.id],
        (err, theme) => {
            if (err) {
                loggers.system.error('Failed to fetch user theme:', err);
                return res.status(500).json({ error: 'Failed to fetch theme preferences' });
            }
            
            // Return theme or null if no custom theme set
            if (theme && theme.gradient_stops) {
                try {
                    theme.gradient_stops = JSON.parse(theme.gradient_stops);
                } catch (e) {
                    theme.gradient_stops = [];
                }
            }
            
            res.json({ theme: theme || null });
        }
    );
});

// Save user's custom theme preferences
app.post('/api/user/theme', requireAuth, async (req, res) => {
    const {
        gradient_type,
        gradient_angle,
        gradient_stops,
        bg_primary,
        bg_secondary,
        bg_tertiary,
        text_primary,
        text_secondary,
        text_muted,
        border_color,
        accent_primary,
        accent_secondary,
        success_color,
        warning_color,
        error_color,
        info_color
    } = req.body;

    try {
        const gradient_stops_json = JSON.stringify(gradient_stops || []);

        // Use DAL for database operations
        await dal.run(
            `INSERT OR REPLACE INTO user_theme_preferences 
            (user_id, gradient_type, gradient_angle, gradient_stops, bg_primary, bg_secondary, bg_tertiary,
             text_primary, text_secondary, text_muted, border_color, accent_primary, accent_secondary,
             success_color, warning_color, error_color, info_color, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
            [
                req.user.id,
                gradient_type || 'linear',
                gradient_angle || 135,
                gradient_stops_json,
                bg_primary,
                bg_secondary,
                bg_tertiary,
                text_primary,
                text_secondary,
                text_muted,
                border_color,
                accent_primary,
                accent_secondary,
                success_color,
                warning_color,
                error_color,
                info_color
            ]
        );

        await logActivity(req.user.id, 'theme_customization', 'User updated theme preferences', req);
        res.json({ success: true, message: 'Theme preferences saved successfully' });
    } catch (error) {
        loggers.system.error('Failed to save user theme:', error);
        res.status(500).json({ error: 'Failed to save theme preferences' });
    }
});

// Reset user's theme to defaults
app.delete('/api/user/theme', requireAuth, async (req, res) => {
    try {
        // Use DAL for database operations
        await dal.run(
            'DELETE FROM user_theme_preferences WHERE user_id = ?',
            [req.user.id]
        );

        await logActivity(req.user.id, 'theme_customization', 'User reset theme to defaults', req);
        res.json({ success: true, message: 'Theme reset to defaults' });
    } catch (error) {
        loggers.system.error('Failed to reset user theme:', error);
        res.status(500).json({ error: 'Failed to reset theme' });
    }
});

// ============================================================================
// SESSION MANAGEMENT API ENDPOINTS
// ============================================================================

// Get all active sessions (admin only)
app.get('/api/admin/sessions', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Access denied' });
    }

    const query = `
        SELECT 
            s.id,
            s.user_id,
            s.session_token,
            s.ip_address,
            s.user_agent,
            s.created_at,
            s.last_activity,
            s.expires_at,
            u.username,
            u.role
        FROM user_sessions s
        LEFT JOIN users u ON s.user_id = u.id
        WHERE s.is_active = 1
        ORDER BY s.last_activity DESC
    `;

    db.all(query, [], (err, sessions) => {
        if (err) {
            loggers.system.error('Failed to fetch sessions:', err);
            return res.status(500).json({ error: 'Database error' });
        }

        // Don't send session tokens to client, and format timestamps
        const sanitizedSessions = sessions.map(s => ({
            id: s.id,
            user_id: s.user_id,
            username: s.username,
            role: s.role,
            ip_address: s.ip_address,
            user_agent: s.user_agent,
            created_at: s.created_at,
            last_activity: s.last_activity,
            expires_at: s.expires_at,
            created_at_formatted: formatSQLiteTimestamp(s.created_at),
            last_activity_formatted: formatSQLiteTimestamp(s.last_activity),
            expires_at_formatted: formatSQLiteTimestamp(s.expires_at)
        }));

        res.json(sanitizedSessions);
    });
});

// Terminate a specific session
app.delete('/api/admin/sessions/:id', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Access denied' });
    }

    const sessionId = req.params.id;

    db.run(
        'UPDATE user_sessions SET is_active = 0 WHERE id = ?',
        [sessionId],
        function(err) {
            if (err) {
                loggers.system.error('Failed to terminate session:', err);
                return res.status(500).json({ error: 'Database error' });
            }

            if (this.changes === 0) {
                return res.status(404).json({ error: 'Session not found' });
            }

            loggers.audit.info(`Session ${sessionId} terminated by ${req.user.username}`);
            logToDatabase(`Session terminated: ID ${sessionId}`, 'info', 'security', 'logging-server');

            res.json({ success: true, message: 'Session terminated' });
        }
    );
});

// Terminate all sessions except current
app.post('/api/admin/sessions/terminate-all', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Access denied' });
    }

    const currentToken = req.session.token;

    db.run(
        'UPDATE user_sessions SET is_active = 0 WHERE session_token != ?',
        [currentToken],
        function(err) {
            if (err) {
                loggers.system.error('Failed to terminate sessions:', err);
                return res.status(500).json({ error: 'Database error' });
            }

            loggers.audit.warn(`All sessions terminated by ${req.user.username} (${this.changes} sessions)`);
            logToDatabase(`All sessions terminated: ${this.changes} sessions`, 'warn', 'security', 'logging-server');

            res.json({ 
                success: true, 
                message: `${this.changes} sessions terminated`,
                count: this.changes
            });
        }
    );
});

// Restart server endpoint
app.post('/api/admin/restart', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Access denied' });
    }

    loggers.audit.warn(`Server restart initiated by ${req.user.username}`);
    logToDatabase(`Server restart initiated by ${req.user.username}`, 'warn', 'system', 'logging-server');

    res.json({ 
        success: true, 
        message: 'Server shutting down for restart...'
    });

    // Give time for the response to be sent, then exit
    setTimeout(() => {
        loggers.system.info('üîÑ Server shutting down for restart...');
        process.exit(0); // Exit cleanly - your PowerShell loop will restart it
    }, 1000);
});

// ============================================================================
// ALERT API ENDPOINTS
// ============================================================================

// Get all alerts with optional filtering
app.get('/api/alerts', requireAuth, (req, res) => {
    const { severity, status } = req.query;
    
    let query = `
        SELECT 
            a.id,
            a.rule_id,
            a.severity,
            a.message,
            a.source,
            a.details,
            a.is_resolved,
            a.created_at,
            a.resolved_at,
            a.resolved_by,
            u.username as resolved_by_username
        FROM system_alerts a
        LEFT JOIN users u ON a.resolved_by = u.id
        WHERE 1=1
    `;
    
    const params = [];
    
    if (severity && severity !== 'all') {
        query += ' AND a.severity = ?';
        params.push(severity);
    }
    
    if (status) {
        if (status === 'active') {
            query += ' AND a.is_resolved = 0';
        } else if (status === 'resolved') {
            query += ' AND a.is_resolved = 1';
        }
    }
    
    query += ' ORDER BY a.created_at DESC';
    
    db.all(query, params, (err, alerts) => {
        if (err) {
            loggers.system.error('Failed to fetch alerts:', err);
            return res.status(500).json({ error: 'Database error' });
        }
        
        // Parse details JSON and add formatted timestamps
        const processedAlerts = alerts.map(alert => ({
            ...alert,
            details: alert.details ? JSON.parse(alert.details) : null,
            created_at_formatted: formatSQLiteTimestamp(alert.created_at),
            resolved_at_formatted: formatSQLiteTimestamp(alert.resolved_at)
        }));
        
        res.json(processedAlerts);
    });
});

// Acknowledge an alert
app.post('/api/alerts/:id/acknowledge', requireAuth, (req, res) => {
    const alertId = req.params.id;
    
    db.run(
        'UPDATE system_alerts SET is_read = 1 WHERE id = ?',
        [alertId],
        function(err) {
            if (err) {
                loggers.system.error('Failed to acknowledge alert:', err);
                return res.status(500).json({ error: 'Database error' });
            }
            
            if (this.changes === 0) {
                return res.status(404).json({ error: 'Alert not found' });
            }
            
            loggers.audit.info(`Alert ${alertId} acknowledged by ${req.user.username}`);
            logToDatabase(`Alert acknowledged: ID ${alertId}`, 'info', 'system', 'logging-server');
            
            res.json({ success: true, message: 'Alert acknowledged' });
        }
    );
});

// Resolve an alert
app.post('/api/alerts/:id/resolve', requireAuth, (req, res) => {
    const alertId = req.params.id;
    const now = moment().tz(TIMEZONE).format('YYYY-MM-DD HH:mm:ss');
    
    db.run(
        'UPDATE system_alerts SET is_resolved = 1, resolved_at = ?, resolved_by = ? WHERE id = ?',
        [now, req.user.id, alertId],
        function(err) {
            if (err) {
                loggers.system.error('Failed to resolve alert:', err);
                return res.status(500).json({ error: 'Database error' });
            }
            
            if (this.changes === 0) {
                return res.status(404).json({ error: 'Alert not found' });
            }
            
            loggers.audit.info(`Alert ${alertId} resolved by ${req.user.username}`);
            logToDatabase(`Alert resolved: ID ${alertId}`, 'info', 'system', 'logging-server');
            
            res.json({ success: true, message: 'Alert resolved' });
        }
    );
});

// Delete an alert
app.delete('/api/alerts/:id', requireAuth, (req, res) => {
    const alertId = req.params.id;
    
    db.run(
        'DELETE FROM system_alerts WHERE id = ?',
        [alertId],
        function(err) {
            if (err) {
                loggers.system.error('Failed to delete alert:', err);
                return res.status(500).json({ error: 'Database error' });
            }
            
            if (this.changes === 0) {
                return res.status(404).json({ error: 'Alert not found' });
            }
            
            loggers.audit.info(`Alert ${alertId} deleted by ${req.user.username}`);
            logToDatabase(`Alert deleted: ID ${alertId}`, 'info', 'system', 'logging-server');
            
            res.json({ success: true, message: 'Alert deleted' });
        }
    );
});

// ============================================================================
// USER ACTIVITY API ENDPOINTS
// ============================================================================

// Get user activity with optional filtering
app.get('/api/activity', requireAuth, (req, res) => {
    const { user_id, action, limit = 500 } = req.query;
    
    let query = `
        SELECT 
            a.id,
            a.user_id,
            a.action,
            a.resource,
            a.details,
            a.ip_address,
            a.user_agent,
            a.timestamp,
            u.username,
            u.role
        FROM user_activity a
        LEFT JOIN users u ON a.user_id = u.id
        WHERE 1=1
    `;
    
    const params = [];
    
    if (user_id) {
        query += ' AND a.user_id = ?';
        params.push(user_id);
    }
    
    if (action) {
        query += ' AND a.action = ?';
        params.push(action);
    }
    
    query += ' ORDER BY a.timestamp DESC LIMIT ?';
    params.push(parseInt(limit));
    
    db.all(query, params, (err, activities) => {
        if (err) {
            loggers.system.error('Failed to fetch user activity:', err);
            return res.status(500).json({ error: 'Database error' });
        }
        
        // Add formatted timestamp in server timezone
        // Database stores UTC timestamps, so we need to parse as UTC first, then convert to local timezone
        const activitiesWithFormattedTime = activities.map(activity => ({
            ...activity,
            timestampFormatted: moment.utc(activity.timestamp).tz(TIMEZONE).format('MM/DD/YYYY, hh:mm:ss A')
        }));
        
        res.json(activitiesWithFormattedTime);
    });
});

// Track failed login attempts by IP for security monitoring
const failedLoginAttempts = new Map();

// Track failed login attempts (called from login endpoint)
function trackFailedLogin(ip, username) {
    if (!failedLoginAttempts.has(ip)) {
        failedLoginAttempts.set(ip, { count: 0, lastAttempt: Date.now(), username });
    }
    
    const data = failedLoginAttempts.get(ip);
    data.count++;
    data.lastAttempt = Date.now();
    
    // Alert on 5+ failed attempts in an hour
    if (data.count >= 5) {
        loggers.system.warn(`Security Alert: ${data.count} failed login attempts from IP ${ip} for user "${username}"`);
        
        // Log security event to database
        logToDatabase(
            `Security Alert: ${data.count} failed login attempts from IP ${ip} for user "${username}". Possible brute force attack.`,
            'warn',
            'security',
            'logging-server'
        );
    }
}

// Log activity helper function using DAL
async function logActivity(userId, action, resource = null, details = null, req = null) {
    if (!dal) return;
    
    try {
        const ipAddress = req?.ip || req?.connection?.remoteAddress || null;
        const userAgent = req?.headers?.['user-agent'] || null;
        await dal.logUserActivity(userId, action, resource, details, ipAddress, userAgent);
    } catch (error) {
        loggers.system.error('Failed to log user activity:', error);
    }
}

// Backup Management API endpoints
const BACKUPS_DIR = path.join(__dirname, 'data', 'backups');
const DB_PATH = path.join(__dirname, 'data', 'databases', 'enterprise_logs.db');

// Ensure backups directory exists
if (!fs.existsSync(BACKUPS_DIR)) {
    fs.mkdirSync(BACKUPS_DIR, { recursive: true });
}

// Get all backups
app.get('/api/backups', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    try {
        const files = fs.readdirSync(BACKUPS_DIR);
        const backups = [];
        let totalSize = 0;

        for (const file of files) {
            if (file.endsWith('.db')) {
                const filePath = path.join(BACKUPS_DIR, file);
                const stats = fs.statSync(filePath);
                backups.push({
                    filename: file,
                    size: stats.size,
                    created: stats.birthtime,
                    createdFormatted: moment.utc(stats.birthtime).tz(TIMEZONE).format('MM/DD/YYYY, hh:mm:ss A')
                });
                totalSize += stats.size;
            }
        }

        // Sort by creation date, newest first
        backups.sort((a, b) => new Date(b.created) - new Date(a.created));

        // Get current database size
        const dbStats = fs.statSync(DB_PATH);

        res.json({
            backups,
            totalSize,
            currentDbSize: dbStats.size
        });
    } catch (error) {
        loggers.system.error('Failed to list backups:', error);
        res.status(500).json({ error: 'Failed to list backups' });
    }
});

// Create new backup
app.post('/api/backups/create', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    try {
        const timestamp = new Date().toISOString().replace(/:/g, '-').replace(/\..+/, '').replace('T', '_');
        const backupFilename = `enterprise_logs_${timestamp}.db`;
        const backupPath = path.join(BACKUPS_DIR, backupFilename);

        // Copy database file
        fs.copyFileSync(DB_PATH, backupPath);

        const stats = fs.statSync(backupPath);

        loggers.system.info(`Backup created by ${req.user.username}: ${backupFilename}`);
        await logActivity(req.user.id, 'admin_action', '/api/backups/create', `Created backup: ${backupFilename}`, req);

        res.json({
            success: true,
            backup: {
                filename: backupFilename,
                size: stats.size,
                created: stats.birthtime
            }
        });
    } catch (error) {
        loggers.system.error('Failed to create backup:', error);
        res.status(500).json({ error: 'Failed to create backup' });
    }
});

// Download backup
app.get('/api/backups/:filename/download', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    try {
        const { filename } = req.params;
        const backupPath = path.join(BACKUPS_DIR, filename);

        // Security: Ensure file is within backups directory
        if (!backupPath.startsWith(BACKUPS_DIR)) {
            return res.status(403).json({ error: 'Invalid file path' });
        }

        if (!fs.existsSync(backupPath)) {
            return res.status(404).json({ error: 'Backup not found' });
        }

        loggers.system.info(`Backup downloaded by ${req.user.username}: ${filename}`);
        await logActivity(req.user.id, 'admin_action', `/api/backups/${filename}/download`, `Downloaded backup: ${filename}`, req);

        res.download(backupPath, filename);
    } catch (error) {
        loggers.system.error('Failed to download backup:', error);
        res.status(500).json({ error: 'Failed to download backup' });
    }
});

// Restore backup
app.post('/api/backups/:filename/restore', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    try {
        const { filename } = req.params;
        const backupPath = path.join(BACKUPS_DIR, filename);

        // Security: Ensure file is within backups directory
        if (!backupPath.startsWith(BACKUPS_DIR)) {
            return res.status(403).json({ error: 'Invalid file path' });
        }

        if (!fs.existsSync(backupPath)) {
            return res.status(404).json({ error: 'Backup not found' });
        }

        loggers.system.info(`Database restore initiated by ${req.user.username} from: ${filename}`);
        await logActivity(req.user.id, 'admin_action', `/api/backups/${filename}/restore`, `Restored backup: ${filename}`, req);

        // Close database connection
        db.close((err) => {
            if (err) {
                loggers.system.error('Error closing database:', err);
            }

            // Copy backup over current database
            fs.copyFileSync(backupPath, DB_PATH);

            loggers.system.info('Database restored successfully. Server will restart...');

            // Send response before exiting
            res.json({ success: true, message: 'Backup restored. Server restarting...' });

            // Restart the server after a short delay
            setTimeout(() => {
                process.exit(0); // PM2 or nodemon will restart the process
            }, 1000);
        });
    } catch (error) {
        loggers.system.error('Failed to restore backup:', error);
        res.status(500).json({ error: 'Failed to restore backup' });
    }
});

// Delete backup
app.delete('/api/backups/:filename', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    try {
        const { filename } = req.params;
        const backupPath = path.join(BACKUPS_DIR, filename);

        // Security: Ensure file is within backups directory
        if (!backupPath.startsWith(BACKUPS_DIR)) {
            return res.status(403).json({ error: 'Invalid file path' });
        }

        if (!fs.existsSync(backupPath)) {
            return res.status(404).json({ error: 'Backup not found' });
        }

        fs.unlinkSync(backupPath);

        loggers.system.info(`Backup deleted by ${req.user.username}: ${filename}`);
        await logActivity(req.user.id, 'admin_action', `/api/backups/${filename}`, `Deleted backup: ${filename}`, req);

        res.json({ success: true, message: 'Backup deleted successfully' });
    } catch (error) {
        loggers.system.error('Failed to delete backup:', error);
        res.status(500).json({ error: 'Failed to delete backup' });
    }
});

// ============================================================================
// WEBHOOK API ENDPOINTS
// ============================================================================

// Get all webhooks
app.get('/api/webhooks', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    db.all('SELECT * FROM webhooks ORDER BY created_at DESC', [], (err, webhooks) => {
        if (err) {
            loggers.system.error('Failed to fetch webhooks:', err);
            return res.status(500).json({ error: 'Database error' });
        }

        // Parse JSON fields and add formatted timestamps
        const processedWebhooks = webhooks.map(webhook => ({
            ...webhook,
            event_types: webhook.events ? JSON.parse(webhook.events) : ['all'],
            headers: webhook.headers ? JSON.parse(webhook.headers) : {},
            created_at_formatted: moment.utc(webhook.created_at).tz(TIMEZONE).format('MM/DD/YYYY, hh:mm:ss A'),
            last_triggered_formatted: webhook.last_triggered ? moment.utc(webhook.last_triggered).tz(TIMEZONE).format('MM/DD/YYYY, hh:mm:ss A') : null
        }));

        res.json(processedWebhooks);
    });
});

// Create new webhook
app.post('/api/webhooks', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    const { name, url, method, headers, event_types, secret, enabled } = req.body;

    if (!name || !url) {
        return res.status(400).json({ error: 'Name and URL are required' });
    }

    db.run(
        `INSERT INTO webhooks (name, url, method, headers, events, secret, active)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
            name,
            url,
            method || 'POST',
            headers ? JSON.stringify(headers) : null,
            event_types ? JSON.stringify(event_types) : JSON.stringify(['all']),
            secret || null,
            enabled !== undefined ? enabled : 1
        ],
        function(err) {
            if (err) {
                loggers.system.error('Failed to create webhook:', err);
                return res.status(500).json({ error: 'Database error' });
            }

            loggers.system.info(`Webhook created by ${req.user.username}: ${name}`);
            logActivity(req.user.id, 'admin_action', '/api/webhooks', `Created webhook: ${name}`, req);

            res.json({ success: true, id: this.lastID });
        }
    );
});

// Update webhook
app.put('/api/webhooks/:id', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    const { id } = req.params;
    const { name, url, method, headers, event_types, secret, enabled } = req.body;

    db.run(
        `UPDATE webhooks SET name = ?, url = ?, method = ?, headers = ?, events = ?, secret = ?, active = ?
         WHERE id = ?`,
        [
            name,
            url,
            method || 'POST',
            headers ? JSON.stringify(headers) : null,
            event_types ? JSON.stringify(event_types) : JSON.stringify(['all']),
            secret || null,
            enabled !== undefined ? enabled : 1,
            id
        ],
        function(err) {
            if (err) {
                loggers.system.error('Failed to update webhook:', err);
                return res.status(500).json({ error: 'Database error' });
            }

            if (this.changes === 0) {
                return res.status(404).json({ error: 'Webhook not found' });
            }

            loggers.system.info(`Webhook updated by ${req.user.username}: ${name}`);
            logActivity(req.user.id, 'admin_action', `/api/webhooks/${id}`, `Updated webhook: ${name}`, req);

            res.json({ success: true });
        }
    );
});

// Delete webhook
app.delete('/api/webhooks/:id', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    const { id } = req.params;

    db.run('DELETE FROM webhooks WHERE id = ?', [id], function(err) {
        if (err) {
            loggers.system.error('Failed to delete webhook:', err);
            return res.status(500).json({ error: 'Database error' });
        }

        if (this.changes === 0) {
            return res.status(404).json({ error: 'Webhook not found' });
        }

        loggers.system.info(`Webhook deleted by ${req.user.username}: ID ${id}`);
        logActivity(req.user.id, 'admin_action', `/api/webhooks/${id}`, `Deleted webhook ID: ${id}`, req);

        res.json({ success: true });
    });
});

// Test webhook
app.post('/api/webhooks/:id/test', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    const { id } = req.params;

    db.get('SELECT * FROM webhooks WHERE id = ?', [id], async (err, webhook) => {
        if (err) {
            loggers.system.error('Failed to fetch webhook:', err);
            return res.status(500).json({ error: 'Database error' });
        }

        if (!webhook) {
            return res.status(404).json({ error: 'Webhook not found' });
        }

        const testData = {
            test: true,
            message: 'This is a test webhook delivery',
            triggered_by: req.user.username,
            timestamp: new Date().toISOString()
        };

        const result = await webhookManager.deliverWebhook(webhook, 'test', testData);

        res.json({
            success: result.success,
            message: result.success ? 'Webhook test successful' : 'Webhook test failed',
            error: result.error || null
        });
    });
});

// Get webhook delivery history
app.get('/api/webhooks/:id/deliveries', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    const { id } = req.params;
    const limit = parseInt(req.query.limit) || 50;

    db.all(
        `SELECT * FROM webhook_deliveries WHERE webhook_id = ? ORDER BY attempted_at DESC LIMIT ?`,
        [id, limit],
        (err, deliveries) => {
            if (err) {
                loggers.system.error('Failed to fetch webhook deliveries:', err);
                return res.status(500).json({ error: 'Database error' });
            }

            // Add formatted timestamps
            const processedDeliveries = deliveries.map(delivery => ({
                ...delivery,
                attempted_at_formatted: moment.utc(delivery.attempted_at).tz(TIMEZONE).format('MM/DD/YYYY, hh:mm:ss A')
            }));

            res.json(processedDeliveries);
        }
    );
});

// Retry failed webhook delivery
app.post('/api/webhooks/deliveries/:id/retry', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    const { id } = req.params;

    db.get(
        `SELECT d.*, w.* FROM webhook_deliveries d 
         JOIN webhooks w ON d.webhook_id = w.id 
         WHERE d.id = ?`,
        [id],
        async (err, delivery) => {
            if (err) {
                loggers.system.error('Failed to fetch delivery:', err);
                return res.status(500).json({ error: 'Database error' });
            }

            if (!delivery) {
                return res.status(404).json({ error: 'Delivery not found' });
            }

            const payload = JSON.parse(delivery.payload);
            const result = await webhookManager.deliverWebhook(delivery, delivery.event_type, payload.data);

            res.json({
                success: result.success,
                message: result.success ? 'Webhook retry successful' : 'Webhook retry failed',
                error: result.error || null
            });
        }
    );
});

// ============================================================================
// INTEGRATION HEALTH API ENDPOINTS
// ============================================================================

// Get all integrations health status
app.get('/api/integrations/health', requireAuth, (req, res) => {
    db.all(
        'SELECT * FROM integration_health ORDER BY integration_name',
        [],
        (err, integrations) => {
            if (err) {
                loggers.system.error('Failed to fetch integration health:', err);
                return res.status(500).json({ error: 'Database error' });
            }

            // Add formatted timestamps
            const processedIntegrations = integrations.map(integration => ({
                ...integration,
                last_check_formatted: integration.last_check ? moment.utc(integration.last_check).tz(TIMEZONE).format('MM/DD/YYYY, hh:mm:ss A') : null,
                last_success_formatted: integration.last_success ? moment.utc(integration.last_success).tz(TIMEZONE).format('MM/DD/YYYY, hh:mm:ss A') : null,
                metadata: integration.metadata ? JSON.parse(integration.metadata) : null
            }));

            res.json(processedIntegrations);
        }
    );
});

// Test specific integration health
app.post('/api/integrations/:name/test', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    const { name } = req.params;
    const result = await integrationManager.checkIntegrationHealth(name);

    logActivity(req.user.id, 'admin_action', `/api/integrations/${name}/test`, `Tested integration: ${name}`, req);

    res.json(result);
});

// Get integration health history
app.get('/api/integrations/:name/history', requireAuth, (req, res) => {
    const { name } = req.params;
    const limit = parseInt(req.query.limit) || 100;

    db.all(
        `SELECT * FROM integration_metrics WHERE integration_name = ? ORDER BY timestamp DESC LIMIT ?`,
        [name, limit],
        (err, metrics) => {
            if (err) {
                loggers.system.error('Failed to fetch integration history:', err);
                return res.status(500).json({ error: 'Database error' });
            }

            // Add formatted timestamps
            const processedMetrics = metrics.map(metric => ({
                ...metric,
                timestamp_formatted: moment.utc(metric.timestamp).tz(TIMEZONE).format('MM/DD/YYYY, hh:mm:ss A')
            }));

            res.json(processedMetrics);
        }
    );
});

// Test all integrations
app.post('/api/integrations/test-all', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin privileges required' });
    }

    const results = await integrationManager.checkAllIntegrationsHealth();

    // Save integration health results to database - Fixed duplicate insertion bug
    if (results && typeof results === 'object') {
        Object.entries(results).forEach(([integrationName, status]) => {
            const healthStatus = status.connected ? 'online' : 'offline';
            const errorMessage = status.connected ? null : `Integration not connected`;
            
            // First check if record exists, then update or insert accordingly
            db.get('SELECT id, error_count, last_success FROM integration_health WHERE integration_name = ?', [integrationName], (err, existing) => {
                if (err) {
                    loggers.system.error(`Error checking existing integration health for ${integrationName}:`, err);
                    return;
                }
                
                if (existing) {
                    // Update existing record
                    const newErrorCount = healthStatus === 'online' ? 0 : (existing.error_count || 0) + 1;
                    const newLastSuccess = healthStatus === 'online' ? 'CURRENT_TIMESTAMP' : existing.last_success;
                    
                    db.run(`
                        UPDATE integration_health 
                        SET status = ?, last_check = CURRENT_TIMESTAMP, 
                            last_success = CASE WHEN ? = 'online' THEN CURRENT_TIMESTAMP ELSE last_success END,
                            error_count = ?, last_error = ?, metadata = ?, updated_at = CURRENT_TIMESTAMP
                        WHERE integration_name = ?
                    `, [healthStatus, healthStatus, newErrorCount, errorMessage, JSON.stringify(status), integrationName], (updateErr) => {
                        if (updateErr) {
                            loggers.system.error(`Failed to update ${integrationName} health status:`, updateErr);
                        }
                    });
                } else {
                    // Insert new record
                    db.run(`
                        INSERT INTO integration_health 
                        (integration_name, status, last_check, last_success, error_count, last_error, metadata)
                        VALUES (?, ?, CURRENT_TIMESTAMP, 
                                CASE WHEN ? = 'online' THEN CURRENT_TIMESTAMP ELSE NULL END,
                                CASE WHEN ? = 'online' THEN 0 ELSE 1 END,
                                ?, ?)
                    `, [
                        integrationName,
                        healthStatus,
                        healthStatus,
                        healthStatus,
                        errorMessage,
                        JSON.stringify(status)
                    ], (insertErr) => {
                        if (insertErr) {
                            loggers.system.error(`Failed to insert ${integrationName} health status:`, insertErr);
                        }
                    });
                }
            });
        });
    }

    logActivity(req.user.id, 'admin_action', '/api/integrations/test-all', 'Tested all integrations', req);

    res.json(results);
});

// Custom Integrations API endpoints
app.get('/api/integrations/custom', requireAuth, (req, res) => {
    db.all('SELECT * FROM custom_integrations ORDER BY created_at DESC', [], (err, rows) => {
        if (err) {
            loggers.access.error('Failed to fetch custom integrations:', err);
            return res.status(500).json({ success: false, error: 'Database error' });
        }
        
        // Parse auth_data back to object
        const integrations = rows.map(row => ({
            ...row,
            auth_data: row.auth_data ? JSON.parse(row.auth_data) : null
        }));
        
        res.json({ success: true, integrations });
    });
});

app.post('/api/integrations/custom', requireAdmin, (req, res) => {
    const { name, type, base_url, auth_type, auth_data, enabled, description, test_endpoint, icon, icon_color } = req.body;
    
    if (!name || !type) {
        return res.status(400).json({ success: false, error: 'Name and type are required' });
    }
    
    const authDataJson = auth_data ? JSON.stringify(auth_data) : null;
    
    db.run(
        `INSERT INTO custom_integrations (name, type, base_url, auth_type, auth_data, enabled, description, test_endpoint, icon, icon_color)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [name, type, base_url || null, auth_type || 'none', authDataJson, enabled !== false ? 1 : 0, description || null, test_endpoint || null, icon || 'puzzle-piece', icon_color || '#8b5cf6'],
        function(err) {
            if (err) {
                if (err.message.includes('UNIQUE constraint failed')) {
                    return res.status(400).json({ success: false, error: 'Integration name already exists' });
                }
                loggers.access.error('Failed to create custom integration:', err);
                return res.status(500).json({ success: false, error: 'Database error' });
            }
            
            loggers.security.info(`Custom integration created: ${name} by ${req.user.username}`);
            res.json({ success: true, id: this.lastID });
        }
    );
});

app.put('/api/integrations/custom/:id', requireAdmin, (req, res) => {
    const { id } = req.params;
    const { name, type, base_url, auth_type, auth_data, enabled, description, test_endpoint, icon, icon_color } = req.body;
    
    if (!name || !type) {
        return res.status(400).json({ success: false, error: 'Name and type are required' });
    }
    
    const authDataJson = auth_data ? JSON.stringify(auth_data) : null;
    
    db.run(
        `UPDATE custom_integrations 
         SET name = ?, type = ?, base_url = ?, auth_type = ?, auth_data = ?, 
             enabled = ?, description = ?, test_endpoint = ?, icon = ?, icon_color = ?, updated_at = CURRENT_TIMESTAMP
         WHERE id = ?`,
        [name, type, base_url || null, auth_type || 'none', authDataJson, enabled !== false ? 1 : 0, description || null, test_endpoint || null, icon || 'puzzle-piece', icon_color || '#8b5cf6', id],
        function(err) {
            if (err) {
                if (err.message.includes('UNIQUE constraint failed')) {
                    return res.status(400).json({ success: false, error: 'Integration name already exists' });
                }
                loggers.access.error('Failed to update custom integration:', err);
                return res.status(500).json({ success: false, error: 'Database error' });
            }
            
            if (this.changes === 0) {
                return res.status(404).json({ success: false, error: 'Integration not found' });
            }
            
            loggers.security.info(`Custom integration updated: ${name} by ${req.user.username}`);
            res.json({ success: true });
        }
    );
});

app.delete('/api/integrations/custom/:id', requireAdmin, (req, res) => {
    const { id } = req.params;
    
    // First get the integration name for logging
    db.get('SELECT name FROM custom_integrations WHERE id = ?', [id], (err, row) => {
        if (err || !row) {
            return res.status(404).json({ success: false, error: 'Integration not found' });
        }
        
        db.run('DELETE FROM custom_integrations WHERE id = ?', [id], function(err) {
            if (err) {
                loggers.access.error('Failed to delete custom integration:', err);
                return res.status(500).json({ success: false, error: 'Database error' });
            }
            
            loggers.security.info(`Custom integration deleted: ${row.name} by ${req.user.username}`);
            res.json({ success: true });
        });
    });
});

app.post('/api/integrations/custom/:id/test', requireAuth, async (req, res) => {
    const { id } = req.params;
    
    db.get('SELECT * FROM custom_integrations WHERE id = ?', [id], async (err, row) => {
        if (err || !row) {
            return res.status(404).json({ success: false, error: 'Integration not found' });
        }
        
        try {
            const testUrl = row.test_endpoint || row.base_url;
            if (!testUrl) {
                return res.json({ success: false, error: 'No test endpoint configured' });
            }
            
            const authData = row.auth_data ? JSON.parse(row.auth_data) : {};
            const headers = {};
            
            // Add authentication headers based on auth_type
            if (row.auth_type === 'api_key' && authData.api_key) {
                headers['Authorization'] = `Bearer ${authData.api_key}`;
            } else if (row.auth_type === 'basic' && authData.username && authData.password) {
                const basicAuth = Buffer.from(`${authData.username}:${authData.password}`).toString('base64');
                headers['Authorization'] = `Basic ${basicAuth}`;
            } else if (row.auth_type === 'header' && authData.header_name && authData.header_value) {
                headers[authData.header_name] = authData.header_value;
            }
            
            // Test connection with timeout
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 5000);
            
            const response = await fetch(testUrl, {
                method: 'GET',
                headers,
                signal: controller.signal
            });
            
            clearTimeout(timeout);
            
            const status = response.ok ? 'online' : 'error';
            
            // Update last_tested and status
            db.run(
                'UPDATE custom_integrations SET status = ?, last_tested = CURRENT_TIMESTAMP WHERE id = ?',
                [status, id]
            );
            
            res.json({
                success: true,
                status,
                statusCode: response.status,
                message: response.ok ? 'Connection successful' : `HTTP ${response.status}`
            });
            
        } catch (error) {
            db.run('UPDATE custom_integrations SET status = ?, last_tested = CURRENT_TIMESTAMP WHERE id = ?', ['offline', id]);
            
            res.json({
                success: false,
                status: 'offline',
                error: error.message
            });
        }
    });
});

// ========================================
// INTEGRATION CONFIGURATION API ENDPOINTS
// ========================================

// Get all integration configurations
app.get('/api/integrations/configs', requireAdmin, (req, res) => {
    db.all('SELECT * FROM integration_configs ORDER BY integration_name', (err, rows) => {
        if (err) {
            loggers.system.error('Error fetching integration configs:', err);
            return res.status(500).json({ error: 'Database error' });
        }
        res.json(rows);
    });
});

// Get specific integration configuration
app.get('/api/integrations/configs/:name', requireAdmin, (req, res) => {
    const { name } = req.params;
    
    db.get('SELECT * FROM integration_configs WHERE integration_name = ?', [name], (err, row) => {
        if (err) {
            loggers.system.error('Error fetching integration config:', err);
            return res.status(500).json({ error: 'Database error' });
        }
        res.json(row || null);
    });
});

// Save/update integration configuration
app.post('/api/integrations/configs', requireAdmin, (req, res) => {
    const { integration_name, integration_type, enabled, config_json } = req.body;
    
    if (!integration_name || !integration_type || !config_json) {
        return res.status(400).json({ error: 'Missing required fields' });
    }
    
    // Check if config exists
    db.get('SELECT id FROM integration_configs WHERE integration_name = ?', [integration_name], (err, row) => {
        if (err) {
            loggers.system.error('Error checking integration config:', err);
            return res.status(500).json({ error: 'Database error' });
        }
        
        if (row) {
            // Update existing
            db.run(
                `UPDATE integration_configs 
                 SET integration_type = ?, enabled = ?, config_json = ?, 
                     updated_at = CURRENT_TIMESTAMP, updated_by = ?
                 WHERE integration_name = ?`,
                [integration_type, enabled, config_json, req.user.id, integration_name],
                function(err) {
                    if (err) {
                        loggers.system.error('Error updating integration config:', err);
                        return res.status(500).json({ error: 'Database error' });
                    }
                    
                    loggers.system.info(`Integration ${integration_name} updated by ${req.user.username}`);
                    res.json({ success: true, id: row.id });
                }
            );
        } else {
            // Insert new
            db.run(
                `INSERT INTO integration_configs 
                 (integration_name, integration_type, enabled, config_json, updated_by)
                 VALUES (?, ?, ?, ?, ?)`,
                [integration_name, integration_type, enabled, config_json, req.user.id],
                function(err) {
                    if (err) {
                        loggers.system.error('Error inserting integration config:', err);
                        return res.status(500).json({ error: 'Database error' });
                    }
                    
                    loggers.system.info(`Integration ${integration_name} created by ${req.user.username}`);
                    res.json({ success: true, id: this.lastID });
                }
            );
        }
    });
});

// Delete integration configuration
app.delete('/api/integrations/configs/:name', requireAdmin, (req, res) => {
    const { name } = req.params;
    
    db.run('DELETE FROM integration_configs WHERE integration_name = ?', [name], function(err) {
        if (err) {
            loggers.system.error('Error deleting integration config:', err);
            return res.status(500).json({ error: 'Database error' });
        }
        
        loggers.system.info(`Integration ${name} deleted by ${req.user.username}`);
        res.json({ success: true, deleted: this.changes });
    });
});

// Dashboard
// Standardized page template function for consistency across ALL pages
function generateStandardPageHTML(pageTitle, pageIcon, activeNav, contentBody, req, additionalCSS = '', additionalJS = '') {
    const uptime = Math.floor(process.uptime());
    const memoryMB = Math.round(process.memoryUsage().heapUsed / 1024 / 1024);
    
    return `
        <!DOCTYPE html>
        <html lang="en" data-theme="auto">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>${pageTitle} | Enterprise Logging Platform</title>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
            <style>
                :root {
                    /* Light Theme Colors */
                    --bg-primary: #ffffff;
                    --bg-secondary: #f8fafc;
                    --bg-tertiary: #f1f5f9;
                    --text-primary: #1e293b;
                    --text-secondary: #475569;
                    --text-muted: #64748b;
                    --border-color: #e2e8f0;
                    --accent-primary: #3b82f6;
                    --accent-secondary: #1d4ed8;
                    --success-color: #10b981;
                    --warning-color: #f59e0b;
                    --error-color: #ef4444;
                    --shadow-light: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
                    --shadow-medium: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
                    --shadow-glow: 0 0 20px rgba(59, 130, 246, 0.3);
                    
                    /* Ocean Gradients */
                    --gradient-ocean: linear-gradient(135deg, #0ea5e9 0%, #3b82f6 50%, #6366f1 100%);
                    --gradient-deep-blue: linear-gradient(135deg, #1e40af 0%, #1e3a8a 50%, #312e81 100%);
                    --gradient-sky: linear-gradient(135deg, #7dd3fc 0%, #38bdf8 50%, #0ea5e9 100%);
                    --sidebar-bg: var(--gradient-ocean);
                }

                /* Dark Theme */
                [data-theme="dark"] {
                    --bg-primary: #1e293b;
                    --bg-secondary: #334155;
                    --bg-tertiary: #475569;
                    --text-primary: #f1f5f9;
                    --text-secondary: #cbd5e1;
                    --text-muted: #94a3b8;
                    --border-color: #475569;
                    --accent-primary: #60a5fa;
                    --accent-secondary: #3b82f6;
                    --shadow-light: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
                    --shadow-medium: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
                    --shadow-glow: 0 0 20px rgba(96, 165, 250, 0.4);
                    --gradient-ocean: linear-gradient(135deg, #1e40af 0%, #1e3a8a 50%, #312e81 100%);
                    --gradient-deep-blue: linear-gradient(135deg, #0c1e3f 0%, #1e293b 50%, #334155 100%);
                    --gradient-sky: linear-gradient(135deg, #1e40af 0%, #3730a3 50%, #4338ca 100%);
                    --sidebar-bg: var(--gradient-deep-blue);
                }

                /* Auto Theme - follows system preference */
                @media (prefers-color-scheme: dark) {
                    [data-theme="auto"] {
                        --bg-primary: #1e293b;
                        --bg-secondary: #334155;
                        --bg-tertiary: #475569;
                        --text-primary: #f1f5f9;
                        --text-secondary: #cbd5e1;
                        --text-muted: #94a3b8;
                        --border-color: #475569;
                        --accent-primary: #60a5fa;
                        --accent-secondary: #3b82f6;
                        --shadow-light: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
                        --shadow-medium: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
                        --shadow-glow: 0 0 20px rgba(96, 165, 250, 0.4);
                        --gradient-ocean: linear-gradient(135deg, #1e40af 0%, #1e3a8a 50%, #312e81 100%);
                        --gradient-deep-blue: linear-gradient(135deg, #0c1e3f 0%, #1e293b 50%, #334155 100%);
                        --gradient-sky: linear-gradient(135deg, #1e40af 0%, #3730a3 50%, #4338ca 100%);
                        --sidebar-bg: var(--gradient-deep-blue);
                    }
                }

                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
                }

                body {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                    background: var(--bg-secondary);
                    color: var(--text-primary);
                    line-height: 1.6;
                }

                .dashboard-container {
                    display: flex;
                    min-height: 100vh;
                }

                .sidebar {
                    width: 280px;
                    background: var(--sidebar-bg);
                    padding: 2rem 0;
                    display: flex;
                    flex-direction: column;
                    color: white;
                    position: relative;
                    overflow: hidden;
                }

                .sidebar::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
                    pointer-events: none;
                }

                .sidebar-header {
                    padding: 0 2rem 2rem;
                    border-bottom: 1px solid rgba(255,255,255,0.2);
                    margin-bottom: 2rem;
                    position: relative;
                    z-index: 1;
                }

                .sidebar-header h2 {
                    margin: 0 0 0.5rem 0;
                    font-size: 1.5rem;
                    font-weight: 700;
                }

                .sidebar-header p {
                    margin: 0;
                    opacity: 0.8;
                    font-size: 0.875rem;
                }

                .sidebar-nav {
                    list-style: none;
                    padding: 0;
                    margin: 0;
                    flex: 1;
                    position: relative;
                    z-index: 1;
                }

                .sidebar-nav li {
                    margin: 0;
                }

                .sidebar-nav a {
                    display: flex;
                    align-items: center;
                    gap: 1rem;
                    padding: 1rem 2rem;
                    color: rgba(255,255,255,0.9);
                    text-decoration: none;
                    transition: all 0.3s ease;
                    border-left: 3px solid transparent;
                    position: relative;
                }

                .sidebar-nav a:hover {
                    background: rgba(255,255,255,0.1);
                    color: white;
                    border-left-color: rgba(255,255,255,0.5);
                }

                .sidebar-nav a.active {
                    background: rgba(255,255,255,0.15);
                    color: white;
                    border-left-color: white;
                    font-weight: 600;
                }

                .sidebar-nav i {
                    width: 20px;
                    font-size: 1.1rem;
                }

                .sidebar-footer {
                    padding: 2rem;
                    border-top: 1px solid rgba(255,255,255,0.2);
                    margin-top: auto;
                    position: relative;
                    z-index: 1;
                }

                .user-info {
                    margin-bottom: 1rem;
                    padding: 1rem;
                    background: rgba(255,255,255,0.1);
                    border-radius: 12px;
                    text-align: center;
                }

                .user-info strong {
                    display: block;
                    margin-bottom: 0.25rem;
                    color: #0ea5e9;
                    font-size: 1.1rem;
                }

                .user-role {
                    font-size: 0.85rem;
                    color: #3b82f6;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                    font-weight: 600;
                }

                .btn-logout {
                    width: 100%;
                    background: rgba(239, 68, 68, 0.2);
                    border: 1px solid rgba(239, 68, 68, 0.4);
                    color: white;
                    padding: 0.75rem;
                    border-radius: 8px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    font-size: 0.9rem;
                }

                .btn-logout:hover {
                    background: rgba(239, 68, 68, 0.3);
                    border-color: rgba(239, 68, 68, 0.6);
                }

                .main-content {
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                }

                .content-header {
                    background: var(--bg-primary);
                    padding: 2rem;
                    border-bottom: 1px solid var(--border-color);
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    box-shadow: var(--shadow-light);
                }

                .content-header h1 {
                    margin: 0;
                    color: var(--text-primary);
                    font-size: 2rem;
                    font-weight: 700;
                }

                .header-actions {
                    display: flex;
                    align-items: center;
                    gap: 1.5rem;
                }

                .theme-toggle {
                    background: var(--bg-primary);
                    border: 2px solid var(--border-color);
                    color: var(--text-primary);
                    padding: 0.75rem;
                    border-radius: 50%;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    font-size: 1.2rem;
                    box-shadow: var(--shadow-light);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    width: 45px;
                    height: 45px;
                }

                .theme-toggle:hover {
                    transform: scale(1.1) rotate(15deg);
                    box-shadow: var(--shadow-medium);
                    border-color: var(--accent-primary);
                }

                .content-body {
                    flex: 1;
                    padding: 2rem;
                    overflow-y: auto;
                    background: var(--bg-secondary);
                }

                .timestamp {
                    font-size: 0.875rem;
                    color: var(--text-muted);
                    font-weight: 500;
                }

                .status-indicator {
                    display: flex;
                    align-items: center;
                    gap: 0.5rem;
                    font-size: 0.875rem;
                    font-weight: 600;
                }

                .status-indicator.online {
                    color: var(--success-color);
                }

                /* Universal Button Styles */
                .btn, button.btn, a.btn {
                    display: inline-flex;
                    align-items: center;
                    gap: 0.5rem;
                    padding: 0.75rem 1.5rem;
                    background: var(--gradient-ocean);
                    color: white;
                    border: none;
                    border-radius: 8px;
                    font-size: 0.95rem;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-decoration: none;
                    box-shadow: var(--shadow-light);
                }

                .btn:hover, button.btn:hover, a.btn:hover {
                    transform: translateY(-2px);
                    box-shadow: var(--shadow-medium);
                    filter: brightness(1.1);
                }

                .btn:active, button.btn:active, a.btn:active {
                    transform: translateY(0);
                }

                .btn-secondary, button.btn-secondary, a.btn-secondary {
                    background: var(--gradient-ocean);
                    color: white;
                    border: none;
                    box-shadow: var(--shadow-light);
                }

                .btn-secondary:hover, button.btn-secondary:hover, a.btn-secondary:hover {
                    background: var(--gradient-ocean);
                    border: none;
                    color: white;
                    transform: translateY(-2px);
                    box-shadow: var(--shadow-medium);
                    filter: brightness(1.1);
                }

                .btn-danger, button.btn-danger, a.btn-danger {
                    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
                    color: white;
                    border: none;
                }

                .btn-success, button.btn-success, a.btn-success {
                    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                    color: white;
                    border: none;
                }

                .btn-warning, button.btn-warning, a.btn-warning {
                    background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
                    color: white;
                    border: none;
                }

                .btn:disabled, button.btn:disabled, a.btn:disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                    transform: none;
                    pointer-events: none;
                }

                /* ========================================
                   UNIFIED PAGE COMPONENTS
                   ======================================== */

                /* Page Header Component */
                .page-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: flex-start;
                    margin-bottom: 2rem;
                    padding: 1rem;
                    background: var(--gradient-ocean);
                    border-radius: 12px;
                    border: 1px solid var(--border-color);
                    box-shadow: var(--shadow-light);
                    position: relative;
                    overflow: hidden;
                }

                .page-header::before {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
                    animation: headerShimmer 4s ease-in-out infinite;
                }

                @keyframes pageHeaderShimmer {
                    0%, 100% { transform: translateX(-100%); }
                    50% { transform: translateX(100%); }
                }

                .page-header h1 {
                    margin: 0 0 0.5rem 0;
                    font-size: 1.5rem;
                    color: white;
                    font-weight: 700;
                    display: flex;
                    align-items: center;
                    gap: 0.75rem;
                    position: relative;
                    z-index: 1;
                }

                .page-header h1 i {
                    color: rgba(255,255,255,0.9);
                    font-size: 1.25rem;
                }

                .page-header p {
                    margin: 0;
                    color: rgba(255,255,255,0.85);
                    font-size: 0.875rem;
                    position: relative;
                    z-index: 1;
                }

                /* Card Component */
                .card {
                    background: var(--bg-primary);
                    border-radius: 12px;
                    box-shadow: var(--shadow-light);
                    border: 1px solid var(--border-color);
                    margin-bottom: 1.5rem;
                    overflow: hidden;
                    transition: all 0.3s ease;
                }

                .card:hover {
                    box-shadow: var(--shadow-medium);
                    transform: translateY(-2px);
                }

                .card-header {
                    padding: 1.5rem;
                    border-bottom: 1px solid var(--border-color);
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    background: var(--bg-secondary);
                }

                .card-header h3 {
                    margin: 0;
                    font-size: 1.25rem;
                    color: var(--text-primary);
                    font-weight: 600;
                    display: flex;
                    align-items: center;
                    gap: 0.5rem;
                }

                .card-header h3 i {
                    color: var(--accent-primary);
                }

                .card-body {
                    padding: 1.5rem;
                }

                .card-footer {
                    padding: 1rem 1.5rem;
                    border-top: 1px solid var(--border-color);
                    background: var(--bg-secondary);
                    display: flex;
                    justify-content: flex-end;
                    gap: 1rem;
                }

                /* Data Table Component */
                .data-table {
                    width: 100%;
                    border-collapse: collapse;
                    background: var(--bg-primary);
                    border-radius: 8px;
                    overflow: hidden;
                }

                .data-table thead {
                    background: var(--bg-secondary);
                }

                .data-table thead th {
                    padding: 1rem;
                    text-align: left;
                    font-weight: 600;
                    color: var(--text-primary);
                    font-size: 0.875rem;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                    border-bottom: 2px solid var(--border-color);
                }

                .data-table tbody tr {
                    border-bottom: 1px solid var(--border-color);
                    transition: all 0.2s ease;
                }

                .data-table tbody tr:hover {
                    background: var(--bg-secondary);
                    transform: scale(1.01);
                }

                .data-table tbody tr:last-child {
                    border-bottom: none;
                }

                .data-table tbody td {
                    padding: 1rem;
                    color: var(--text-secondary);
                    font-size: 0.925rem;
                    vertical-align: middle;
                }

                .data-table tbody td:first-child {
                    font-weight: 500;
                    color: var(--text-primary);
                }

                /* Status Badges */
                .status-badge {
                    display: inline-flex;
                    align-items: center;
                    gap: 0.375rem;
                    padding: 0.375rem 0.75rem;
                    border-radius: 20px;
                    font-size: 0.8rem;
                    font-weight: 600;
                    letter-spacing: 0.3px;
                    text-transform: uppercase;
                    transition: all 0.2s ease;
                }

                .status-badge.online {
                    background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
                    color: #065f46;
                    border: 1px solid #6ee7b7;
                }

                [data-theme="dark"] .status-badge.online {
                    background: linear-gradient(135deg, #064e3b 0%, #065f46 100%);
                    color: #6ee7b7;
                    border: 1px solid #059669;
                }

                .status-badge.offline {
                    background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
                    color: #991b1b;
                    border: 1px solid #fca5a5;
                }

                [data-theme="dark"] .status-badge.offline {
                    background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
                    color: #fca5a5;
                    border: 1px solid #dc2626;
                }

                .status-badge.pending {
                    background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
                    color: #78350f;
                    border: 1px solid #fbbf24;
                }

                [data-theme="dark"] .status-badge.pending {
                    background: linear-gradient(135deg, #78350f 0%, #92400e 100%);
                    color: #fbbf24;
                    border: 1px solid #f59e0b;
                }

                .status-badge.degraded {
                    background: linear-gradient(135deg, #fed7aa 0%, #fdba74 100%);
                    color: #7c2d12;
                    border: 1px solid #fb923c;
                }

                [data-theme="dark"] .status-badge.degraded {
                    background: linear-gradient(135deg, #7c2d12 0%, #9a3412 100%);
                    color: #fb923c;
                    border: 1px solid #f97316;
                }

                /* Modal Component */
                .modal {
                    display: none !important;
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.6);
                    backdrop-filter: blur(4px);
                    z-index: 9999;
                    align-items: center;
                    justify-content: center;
                    animation: fadeIn 0.3s ease;
                }

                .modal.active {
                    display: flex !important;
                }

                @keyframes fadeIn {
                    from {
                        opacity: 0;
                    }
                    to {
                        opacity: 1;
                    }
                }

                .modal-content {
                    background: var(--bg-primary);
                    border-radius: 16px;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                    max-width: 600px;
                    width: 90%;
                    max-height: 90vh;
                    overflow-y: auto;
                    padding: 2rem;
                    position: relative;
                    animation: slideUp 0.3s ease;
                }

                @keyframes slideUp {
                    from {
                        transform: translateY(50px);
                        opacity: 0;
                    }
                    to {
                        transform: translateY(0);
                        opacity: 1;
                    }
                }

                .modal-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 1.5rem;
                    padding-bottom: 1rem;
                    border-bottom: 2px solid var(--border-color);
                }

                .modal-header h3 {
                    margin: 0;
                    color: var(--text-primary);
                    font-size: 1.5rem;
                    font-weight: 600;
                    display: flex;
                    align-items: center;
                    gap: 0.5rem;
                }

                .modal-header h3 i {
                    color: var(--accent-primary);
                }

                .modal-close {
                    background: transparent;
                    border: none;
                    font-size: 2.5rem;
                    line-height: 1;
                    cursor: pointer;
                    color: var(--text-secondary);
                    font-weight: 300;
                    padding: 0;
                    width: 48px;
                    height: 48px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border-radius: 8px;
                    transition: all 0.2s ease;
                    position: relative;
                    z-index: 10;
                    flex-shrink: 0;
                }

                .modal-close:hover {
                    background: rgba(239, 68, 68, 0.1);
                    color: var(--error-color);
                    transform: rotate(90deg);
                }

                .modal-close:active {
                    transform: rotate(90deg) scale(0.9);
                }

                .modal-body {
                    margin: 1.5rem 0;
                }

                .modal-footer {
                    display: flex;
                    justify-content: flex-end;
                    gap: 1rem;
                    padding-top: 1.5rem;
                    border-top: 2px solid var(--border-color);
                }

                /* Form Components */
                .form-group {
                    margin-bottom: 1.5rem;
                }

                .form-group label {
                    display: block;
                    font-weight: 600;
                    color: var(--text-primary);
                    margin-bottom: 0.5rem;
                    font-size: 0.95rem;
                }

                .form-group label i {
                    margin-right: 0.5rem;
                    color: var(--accent-primary);
                }

                .form-control {
                    width: 100%;
                    padding: 0.75rem;
                    border: 2px solid var(--border-color);
                    border-radius: 8px;
                    background: var(--bg-primary);
                    color: var(--text-primary);
                    font-size: 1rem;
                    transition: all 0.2s ease;
                    font-family: inherit;
                }

                .form-control:focus {
                    outline: none;
                    border-color: var(--accent-primary);
                    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
                    background: var(--bg-primary);
                }

                .form-control::placeholder {
                    color: var(--text-muted);
                    opacity: 0.7;
                }

                textarea.form-control {
                    resize: vertical;
                    min-height: 100px;
                    font-family: inherit;
                }

                select.form-control {
                    cursor: pointer;
                    appearance: none;
                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2364748b' d='M10.293 3.293L6 7.586 1.707 3.293A1 1 0 00.293 4.707l5 5a1 1 0 001.414 0l5-5a1 1 0 10-1.414-1.414z'/%3E%3C/svg%3E");
                    background-repeat: no-repeat;
                    background-position: right 0.75rem center;
                    padding-right: 2.5rem;
                }

                input[type="checkbox"] {
                    width: 20px;
                    height: 20px;
                    cursor: pointer;
                    accent-color: var(--accent-primary);
                }

                input[type="color"] {
                    height: 50px;
                    cursor: pointer;
                    padding: 0.25rem;
                }

                .form-group small {
                    display: block;
                    margin-top: 0.5rem;
                    font-size: 0.875rem;
                    color: var(--text-muted);
                }

                .form-row {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 1rem;
                }

                /* Grid Layouts */
                .grid {
                    display: grid;
                    gap: 1.5rem;
                    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                }

                .grid-2 {
                    grid-template-columns: repeat(2, 1fr);
                }

                .grid-3 {
                    grid-template-columns: repeat(3, 1fr);
                }

                .grid-4 {
                    grid-template-columns: repeat(4, 1fr);
                }

                @media (max-width: 1200px) {
                    .grid-4 {
                        grid-template-columns: repeat(2, 1fr);
                    }
                }

                @media (max-width: 768px) {
                    .grid,
                    .grid-2,
                    .grid-3,
                    .grid-4 {
                        grid-template-columns: 1fr;
                    }
                }

                /* Stats Cards */
                .stats-grid {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                    gap: 1.5rem;
                    margin-bottom: 2rem;
                }

                .stat-card {
                    background: var(--bg-primary);
                    padding: 1.5rem;
                    border-radius: 12px;
                    border: 1px solid var(--border-color);
                    box-shadow: var(--shadow-light);
                    transition: all 0.3s ease;
                }

                .stat-card:hover {
                    transform: translateY(-4px);
                    box-shadow: var(--shadow-medium);
                }

                .stat-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 1rem;
                }

                .stat-title {
                    font-size: 0.875rem;
                    color: var(--text-muted);
                    font-weight: 600;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                }

                .stat-icon {
                    width: 40px;
                    height: 40px;
                    border-radius: 10px;
                    background: var(--gradient-ocean);
                    color: white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                }

                .stat-value {
                    font-size: 2rem;
                    font-weight: 700;
                    color: var(--text-primary);
                    margin-bottom: 0.5rem;
                }

                .stat-label {
                    font-size: 0.875rem;
                    color: var(--text-muted);
                }

                /* Empty State */
                .empty-state {
                    text-align: center;
                    padding: 4rem 2rem;
                    color: var(--text-muted);
                }

                .empty-state i {
                    font-size: 4rem;
                    opacity: 0.3;
                    margin-bottom: 1rem;
                    display: block;
                    color: var(--accent-primary);
                }

                .empty-state h3 {
                    color: var(--text-primary);
                    margin-bottom: 0.5rem;
                    font-size: 1.5rem;
                }

                .empty-state p {
                    margin-bottom: 2rem;
                    font-size: 1rem;
                }

                /* Utility Classes */
                .text-center {
                    text-align: center;
                }

                .text-right {
                    text-align: right;
                }

                .text-muted {
                    color: var(--text-muted);
                }

                .text-primary {
                    color: var(--text-primary);
                }

                .text-success {
                    color: var(--success-color);
                }

                .text-warning {
                    color: var(--warning-color);
                }

                .text-error {
                    color: var(--error-color);
                }

                .mb-0 { margin-bottom: 0; }
                .mb-1 { margin-bottom: 0.5rem; }
                .mb-2 { margin-bottom: 1rem; }
                .mb-3 { margin-bottom: 1.5rem; }
                .mb-4 { margin-bottom: 2rem; }

                .mt-0 { margin-top: 0; }
                .mt-1 { margin-top: 0.5rem; }
                .mt-2 { margin-top: 1rem; }
                .mt-3 { margin-top: 1.5rem; }
                .mt-4 { margin-top: 2rem; }

                .flex {
                    display: flex;
                }

                .flex-between {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }

                .flex-center {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                }

                .gap-1 { gap: 0.5rem; }
                .gap-2 { gap: 1rem; }
                .gap-3 { gap: 1.5rem; }
                .gap-4 { gap: 2rem; }

                ${additionalCSS}
            </style>
        </head>
        <body data-theme="auto">
            <div class="dashboard-container">
                <!-- Sidebar -->
                <nav class="sidebar">
                    <div class="sidebar-header">
                        <h2><i class="fas fa-building"></i> Enterprise Logger</h2>
                        <p>Tom Nelson's Infrastructure</p>
                    </div>
                    <ul class="sidebar-nav">
                        <li><a href="/dashboard" ${activeNav === 'dashboard' ? 'class="active"' : ''}><i class="fas fa-tachometer-alt"></i> Dashboard</a></li>
                        <li><a href="/logs" ${activeNav === 'logs' ? 'class="active"' : ''}><i class="fas fa-file-alt"></i> Logs</a></li>
                        <li><a href="/search" ${activeNav === 'search' ? 'class="active"' : ''}><i class="fas fa-search"></i> Advanced Search</a></li>
                        <li><a href="/integrations" ${activeNav === 'integrations' ? 'class="active"' : ''}><i class="fas fa-plug"></i> Integrations</a></li>
                        <li><a href="/webhooks" ${activeNav === 'webhooks' ? 'class="active"' : ''}><i class="fas fa-link"></i> Webhooks</a></li>
                        <li><a href="/activity" ${activeNav === 'activity' ? 'class="active"' : ''}><i class="fas fa-history"></i> Activity</a></li>
                        <li><a href="/analytics-advanced" ${activeNav === 'analytics-advanced' ? 'class="active"' : ''}><i class="fas fa-chart-line"></i> Advanced Analytics</a></li>
                        <li><a href="/admin/ingestion" ${activeNav === 'ingestion' ? 'class="active"' : ''}><i class="fas fa-network-wired"></i> Multi-Protocol Ingestion</a></li>
                        <li><a href="/admin/tracing" ${activeNav === 'tracing' ? 'class="active"' : ''}><i class="fas fa-project-diagram"></i> Distributed Tracing</a></li>
                        <li><a href="/admin/dashboards" ${activeNav === 'dashboards' ? 'class="active"' : ''}><i class="fas fa-tachometer-alt"></i> Dashboard Builder</a></li>
                        <li><a href="/admin/security" ${activeNav === 'security' ? 'class="active"' : ''}><i class="fas fa-shield-alt"></i> Security & Audit</a></li>
                        <li><a href="/admin/users" ${activeNav === 'users' ? 'class="active"' : ''}><i class="fas fa-users"></i> Users</a></li>
                        <li><a href="/admin/settings" ${activeNav === 'settings' ? 'class="active"' : ''}><i class="fas fa-cog"></i> Settings</a></li>
                    </ul>
                    <div class="sidebar-footer">
                        <div class="user-info">
                            <strong><i class="fas fa-user-circle"></i> ${req.user.username}</strong>
                            <span class="user-role">${req.user.role}</span>
                        </div>
                        <button onclick="logout()" class="btn-logout">
                            <i class="fas fa-sign-out-alt"></i> Logout
                        </button>
                    </div>
                </nav>

                <!-- Main Content -->
                <main class="main-content">
                    <header class="content-header">
                        <h1><i class="${pageIcon}"></i> ${pageTitle}</h1>
                        <div class="header-actions">
                            <button onclick="toggleTheme()" class="theme-toggle" title="Auto Mode (Click for Light)">
                                <i id="theme-icon" class="fas fa-adjust"></i>
                            </button>
                            <span class="timestamp" id="current-time"></span>
                            <span class="status-indicator online">
                                <i class="fas fa-circle"></i> System Online
                            </span>
                        </div>
                    </header>

                    <div class="content-body">
                        ${contentBody}
                    </div>
                </main>
            </div>

            <script>
                // Standard theme system for ALL pages
                function updateTime() {
                    const now = new Date();
                    document.getElementById('current-time').textContent = now.toLocaleString('en-US', {
                        weekday: 'short',
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                }

                function initializeTheme() {
                    const savedTheme = localStorage.getItem('theme') || 'auto';
                    document.documentElement.setAttribute('data-theme', savedTheme);
                    updateThemeIcon(savedTheme);
                }

                function toggleTheme() {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    let newTheme;
                    
                    switch(currentTheme) {
                        case 'auto':
                            newTheme = 'light';
                            break;
                        case 'light':
                            newTheme = 'dark';
                            break;
                        case 'dark':
                            newTheme = 'auto';
                            break;
                        default:
                            newTheme = 'auto';
                    }
                    
                    document.documentElement.setAttribute('data-theme', newTheme);
                    localStorage.setItem('theme', newTheme);
                    updateThemeIcon(newTheme);
                }

                function updateThemeIcon(theme) {
                    const themeButton = document.querySelector('.theme-toggle i');
                    if (themeButton) {
                        switch(theme) {
                            case 'light':
                                themeButton.className = 'fas fa-sun';
                                themeButton.parentElement.title = 'Light Mode (Click for Dark)';
                                break;
                            case 'dark':
                                themeButton.className = 'fas fa-moon';
                                themeButton.parentElement.title = 'Dark Mode (Click for Auto)';
                                break;
                            case 'auto':
                            default:
                                themeButton.className = 'fas fa-adjust';
                                themeButton.parentElement.title = 'Auto Mode (Click for Light)';
                                break;
                        }
                    }
                }

                function logout() {
                    fetch('/api/auth/logout', { method: 'POST' })
                        .then(() => window.location.href = '/login')
                        .catch(() => window.location.href = '/login');
                }

                // Initialize
                document.addEventListener('DOMContentLoaded', function() {
                    initializeTheme();
                    updateTime();
                    setInterval(updateTime, 1000);
                    loadTimezoneSettings();
                });

                // Global timezone settings
                let userTimezone = 'America/Edmonton'; // Default Mountain Time (Canada)

                async function loadTimezoneSettings() {
                    try {
                        const response = await fetch('/api/timezone');
                        if (response.ok) {
                            const data = await response.json();
                            userTimezone = data.timezone;
                        }
                    } catch (error) {
                        console.error('Failed to load timezone:', error);
                    }
                }

                // Format timestamp with user's timezone using Intl.DateTimeFormat
                function formatTimestamp(timestamp, options = {}) {
                    try {
                        const date = new Date(timestamp);
                        const formatter = new Intl.DateTimeFormat('en-US', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit',
                            timeZone: userTimezone,
                            hour12: true,
                            ...options
                        });
                        return formatter.format(date);
                    } catch (error) {
                        console.error('Error formatting timestamp:', error, 'timestamp:', timestamp, 'timezone:', userTimezone);
                        return new Date(timestamp).toLocaleString();
                    }
                }

                ${additionalJS}
                
                // Load user's custom theme on page load
                (async function loadUserTheme() {
                    try {
                        const response = await fetch('/api/user/theme');
                        if (!response.ok) return; // No custom theme, use defaults
                        
                        const theme = await response.json();
                        if (!theme) return; // No custom theme saved
                        
                        // Apply colors
                        if (theme.bg_primary) document.documentElement.style.setProperty('--bg-primary', theme.bg_primary);
                        if (theme.bg_secondary) document.documentElement.style.setProperty('--bg-secondary', theme.bg_secondary);
                        if (theme.bg_tertiary) document.documentElement.style.setProperty('--bg-tertiary', theme.bg_tertiary);
                        if (theme.text_primary) document.documentElement.style.setProperty('--text-primary', theme.text_primary);
                        if (theme.text_secondary) document.documentElement.style.setProperty('--text-secondary', theme.text_secondary);
                        if (theme.text_muted) document.documentElement.style.setProperty('--text-muted', theme.text_muted);
                        if (theme.border_color) document.documentElement.style.setProperty('--border-color', theme.border_color);
                        if (theme.accent_primary) document.documentElement.style.setProperty('--accent-primary', theme.accent_primary);
                        if (theme.accent_secondary) document.documentElement.style.setProperty('--accent-secondary', theme.accent_secondary);
                        if (theme.success_color) document.documentElement.style.setProperty('--success-color', theme.success_color);
                        if (theme.warning_color) document.documentElement.style.setProperty('--warning-color', theme.warning_color);
                        if (theme.error_color) document.documentElement.style.setProperty('--error-color', theme.error_color);
                        if (theme.info_color) document.documentElement.style.setProperty('--info-color', theme.info_color);
                        
                        // Apply gradient
                        if (theme.gradient_type && theme.gradient_stops) {
                            const stops = theme.gradient_stops
                                .sort((a, b) => a.position - b.position)
                                .map(stop => \`\${stop.color} \${stop.position}%\`)
                                .join(', ');
                            
                            let gradient;
                            if (theme.gradient_type === 'linear') {
                                gradient = \`linear-gradient(\${theme.gradient_angle || 135}deg, \${stops})\`;
                            } else {
                                gradient = \`radial-gradient(circle, \${stops})\`;
                            }
                            
                            document.documentElement.style.setProperty('--gradient-ocean', gradient);
                        }
                    } catch (error) {
                        console.error('Error loading user theme:', error);
                        // Silently fail and use defaults
                    }
                })();
            </script>
        </body>
        </html>
    `;
}

// Old static dashboard (keeping for reference)
app.get('/dashboard/old', requireAuth, (req, res) => {
    const contentBody = `
        <!-- Chart.js is now loaded globally -->
        
        <!-- Dashboard Stats -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-header">
                    <span class="stat-title">System Uptime</span>
                    <div class="stat-icon">
                        <i class="fas fa-clock"></i>
                    </div>
                </div>
                <div class="stat-value">${Math.floor(process.uptime() / 3600)}h ${Math.floor((process.uptime() % 3600) / 60)}m</div>
                <div class="stat-label">Server running smoothly</div>
            </div>

            <div class="stat-card">
                <div class="stat-header">
                    <span class="stat-title">Memory Usage</span>
                    <div class="stat-icon">
                        <i class="fas fa-memory"></i>
                    </div>
                </div>
                <div class="stat-value">${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)} MB</div>
                <div class="stat-label">Heap memory allocated</div>
            </div>

            <div class="stat-card">
                <div class="stat-header">
                    <span class="stat-title">Active Sessions</span>
                    <div class="stat-icon">
                        <i class="fas fa-users"></i>
                    </div>
                </div>
                <div class="stat-value" id="active-sessions">-</div>
                <div class="stat-label">Users currently online</div>
            </div>

            <div class="stat-card">
                <div class="stat-header">
                    <span class="stat-title">Log Entries</span>
                    <div class="stat-icon">
                        <i class="fas fa-file-alt"></i>
                    </div>
                </div>
                <div class="stat-value" id="log-count">-</div>
                <div class="stat-label">Total entries today</div>
            </div>
        </div>

        <!-- System Health Card -->
        <div class="card" style="margin-bottom: 2rem;">
            <div class="card-header">
                <h3><i class="fas fa-heartbeat"></i> System Health</h3>
                <a href="/admin/health" class="btn" style="padding: 0.5rem 1rem; font-size: 0.875rem;">
                    <i class="fas fa-external-link-alt"></i> View Details
                </a>
            </div>
            <div class="card-body">
                <div id="system-health-overview" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                    <!-- Health indicators will be dynamically loaded here -->
                    <div style="text-align: center; padding: 2rem; color: var(--text-muted); grid-column: 1 / -1;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem;"></i>
                        <p style="margin-top: 0.5rem;">Loading system health...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Analytics Chart -->
        <div class="chart-container">
            <div class="chart-header">
                <h3 class="chart-title">Log Activity Trend</h3>
                <div class="time-filter">
                    <button class="time-btn" data-range="1h">1H</button>
                    <button class="time-btn" data-range="6h">6H</button>
                    <button class="time-btn active" data-range="24h">24H</button>
                    <button class="time-btn" data-range="7d">7D</button>
                </div>
            </div>
            <div style="padding: 1.5rem; height: 350px; position: relative;">
                <canvas id="activity-chart"></canvas>
            </div>
        </div>

        <!-- Recent Logs -->
        <div class="recent-logs">
            <div class="logs-header">
                <h3 class="logs-title">Recent Log Entries</h3>
                <div style="display: flex; gap: 1rem; align-items: center;">
                    <button onclick="createTestEvent()" class="btn" style="padding: 0.5rem 1rem; font-size: 0.875rem;">
                        <i class="fas fa-plus"></i> Create Test Event
                    </button>
                    <a href="/logs" class="view-all-btn">View All Logs ‚Üí</a>
                </div>
            </div>
            <div id="recent-logs-container">
                <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
                    <i class="fas fa-spinner fa-spin" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                    <p>Loading recent logs...</p>
                </div>
            </div>
        </div>
    `;

    const additionalCSS = `
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .stat-card {
            background: var(--bg-primary);
            padding: 2rem;
            border-radius: 16px;
            box-shadow: var(--shadow-light);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-medium);
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-ocean);
        }

        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .stat-title {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-icon {
            width: 48px;
            height: 48px;
            background: var(--gradient-ocean);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            line-height: 1;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .chart-container {
            background: var(--bg-primary);
            border-radius: 16px;
            padding: 2rem;
            box-shadow: var(--shadow-light);
            border: 1px solid var(--border-color);
            margin-bottom: 2rem;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .chart-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .time-filter {
            display: flex;
            gap: 0.5rem;
        }

        .time-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.875rem;
        }

        .time-btn.active,
        .time-btn:hover {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .recent-logs {
            background: var(--bg-primary);
            border-radius: 16px;
            padding: 2rem;
            box-shadow: var(--shadow-light);
            border: 1px solid var(--border-color);
        }

        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .logs-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .view-all-btn {
            color: var(--accent-primary);
            text-decoration: none;
            font-weight: 600;
            font-size: 0.875rem;
            transition: color 0.3s ease;
        }

        .view-all-btn:hover {
            color: var(--accent-secondary);
        }

        .log-entry {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.3s ease;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry:hover {
            background: var(--bg-secondary);
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .log-level {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .log-level.info {
            background: rgba(59, 130, 246, 0.1);
            color: var(--accent-primary);
        }

        .log-level.warn {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning-color);
        }

        .log-level.error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-color);
        }

        .log-time {
            font-size: 0.875rem;
            color: var(--text-muted);
        }

        .log-message {
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
        }
    `;

    const additionalJS = `
        // Chart.js loading helper
        function waitForChart(callback) {
            if (typeof Chart !== 'undefined') {
                callback();
            } else {
                setTimeout(() => waitForChart(callback), 50);
            }
        }

        // Load real dashboard stats
        let activityChart = null;
        let currentTimeRange = '24h';

        async function initActivityChart() {
            const ctx = document.getElementById('activity-chart');
            if (!ctx) return;

            waitForChart(() => {
                activityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Log Events',
                        data: [],
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#3b82f6',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#3b82f6',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                label: function(context) {
                                    return \`\${context.parsed.y} events\`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                color: 'var(--text-muted)',
                                font: {
                                    size: 11
                                },
                                maxRotation: 0,
                                autoSkipPadding: 20
                            }
                        },
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                color: 'var(--text-muted)',
                                font: {
                                    size: 11
                                },
                                precision: 0
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
            });

            loadChartData(currentTimeRange);
        }

        async function loadChartData(timeRange) {
            try {
                const response = await fetch(\`/api/analytics/activity?range=\${timeRange}\`);
                if (!response.ok) throw new Error('Failed to fetch chart data');
                
                const data = await response.json();
                
                // Check if there's any actual data
                const hasData = data.values && data.values.some(v => v > 0);
                
                if (activityChart) {
                    activityChart.data.labels = data.labels;
                    activityChart.data.datasets[0].data = data.values;
                    activityChart.update();
                    
                    // Show/hide empty state message
                    const chartContainer = document.getElementById('activity-chart').parentElement;
                    let emptyMessage = chartContainer.querySelector('.chart-empty-state');
                    
                    if (!hasData) {
                        if (!emptyMessage) {
                            emptyMessage = document.createElement('div');
                            emptyMessage.className = 'chart-empty-state';
                            emptyMessage.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: var(--text-muted); z-index: 10; pointer-events: none;';
                            emptyMessage.innerHTML = \`
                                <i class="fas fa-chart-line" style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;"></i>
                                <p style="font-size: 0.875rem;">No log activity in the selected time range</p>
                                <p style="font-size: 0.75rem; margin-top: 0.5rem;">Data will appear here once logs are received</p>
                            \`;
                            chartContainer.appendChild(emptyMessage);
                        }
                        emptyMessage.style.display = 'block';
                        document.getElementById('activity-chart').style.opacity = '0.2';
                    } else {
                        if (emptyMessage) {
                            emptyMessage.style.display = 'none';
                        }
                        document.getElementById('activity-chart').style.opacity = '1';
                    }
                }
            } catch (error) {
                console.error('Failed to load chart data:', error);
                // Show error state
                const chartContainer = document.getElementById('activity-chart').parentElement;
                let errorMessage = chartContainer.querySelector('.chart-error-state');
                if (!errorMessage) {
                    errorMessage = document.createElement('div');
                    errorMessage.className = 'chart-error-state';
                    errorMessage.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: var(--error-color); z-index: 10;';
                    errorMessage.innerHTML = \`
                        <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                        <p style="font-size: 0.875rem;">Failed to load chart data</p>
                    \`;
                    chartContainer.appendChild(errorMessage);
                }
            }
        }

        function setupTimeFilters() {
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentTimeRange = this.getAttribute('data-range');
                    loadChartData(currentTimeRange);
                });
            });
        }

        async function loadDashboardStats() {
            try {
                // Get today's log count (since midnight)
                const countData = await safeFetch('/api/logs/count/today');
                document.getElementById('log-count').textContent = (countData.count || 0).toLocaleString();
                
                // Get active users count
                const usersData = await safeFetch('/api/users');
                const activeUsers = usersData.users ? usersData.users.filter(u => u.last_login && u.is_active).length : 0;
                document.getElementById('active-sessions').textContent = activeUsers;
            } catch (error) {
                console.error('Failed to load dashboard stats:', error);
                document.getElementById('log-count').textContent = '0';
                document.getElementById('active-sessions').textContent = '0';
            }
        }

        async function loadSystemHealth() {
            try {
                const response = await fetch('/api/system/health-checks');
                if (!response.ok) throw new Error('Failed to fetch system health');
                
                const data = await response.json();
                const container = document.getElementById('system-health-overview');
                
                // Show only key health indicators on dashboard
                const keyChecks = data.checks.filter(check => 
                    ['System Memory', 'Node.js Heap', 'CPU Load', 'Database Size'].includes(check.name)
                );
                
                container.innerHTML = keyChecks.map(check => {
                    const statusColors = {
                        success: 'var(--success-color)',
                        warning: 'var(--warning-color)',
                        error: 'var(--error-color)'
                    };
                    const statusIcons = {
                        success: 'check-circle',
                        warning: 'exclamation-triangle',
                        error: 'times-circle'
                    };
                    
                    return '<div style="padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border-left: 3px solid ' + statusColors[check.status] + ';">' +
                        '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">' +
                            '<div style="font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">' + check.name + '</div>' +
                            '<i class="fas fa-' + statusIcons[check.status] + '" style="color: ' + statusColors[check.status] + ';"></i>' +
                        '</div>' +
                        '<div style="font-size: 1.25rem; font-weight: 700; color: var(--text-primary); margin-bottom: 0.25rem;">' + check.value + '</div>' +
                        '<div style="font-size: 0.75rem; color: var(--text-secondary);">' + check.message + '</div>' +
                        (check.percent !== undefined ? 
                            '<div style="width: 100%; height: 4px; background: var(--bg-tertiary); border-radius: 2px; margin-top: 0.5rem; overflow: hidden;">' +
                                '<div style="height: 100%; width: ' + check.percent + '%; background: ' + statusColors[check.status] + '; transition: width 0.3s;"></div>' +
                            '</div>'
                        : '') +
                    '</div>';
                }).join('');
            } catch (error) {
                console.error('Failed to load system health:', error);
                document.getElementById('system-health-overview').innerHTML = 
                    '<div style="text-align: center; padding: 2rem; color: var(--error-color); grid-column: 1 / -1;">' +
                        '<i class="fas fa-exclamation-triangle" style="font-size: 2rem;"></i>' +
                        '<p style="margin-top: 0.5rem;">Failed to load system health</p>' +
                    '</div>';
            }
        }
        
        // Load stats on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadDashboardStats();
            loadSystemHealth();
            loadRecentLogs();
            initActivityChart();
            setupTimeFilters();
            
            // Auto-refresh system health every 30 seconds
            setInterval(loadSystemHealth, 30000);
        });
        
        async function loadRecentLogs() {
            try {
                const logs = await safeFetch('/api/logs?limit=5');
                const container = document.getElementById('recent-logs-container');
                
                if (!logs || logs.length === 0) {
                    container.innerHTML = \`
                        <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
                            <i class="fas fa-inbox" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;"></i>
                            <p>No log entries yet</p>
                            <p style="font-size: 0.875rem; margin-top: 0.5rem;">Create a test event to get started</p>
                        </div>
                    \`;
                    return;
                }
                
                container.innerHTML = logs.map(log => {
                    const time = new Date(log.timestamp || log.created_at);
                    const now = new Date();
                    const diffMs = now - time;
                    const diffMins = Math.floor(diffMs / 60000);
                    const diffHours = Math.floor(diffMs / 3600000);
                    const diffDays = Math.floor(diffMs / 86400000);
                    
                    let timeAgo;
                    if (diffMins < 1) timeAgo = 'Just now';
                    else if (diffMins < 60) timeAgo = \`\${diffMins} minute\${diffMins !== 1 ? 's' : ''} ago\`;
                    else if (diffHours < 24) timeAgo = \`\${diffHours} hour\${diffHours !== 1 ? 's' : ''} ago\`;
                    else timeAgo = \`\${diffDays} day\${diffDays !== 1 ? 's' : ''} ago\`;
                    
                    const severity = (log.severity || 'info').toLowerCase();
                    const severityClass = severity === 'error' ? 'error' : severity === 'warn' ? 'warn' : 'info';
                    const severityLabel = severity.toUpperCase();
                    
                    return \`
                        <div class="log-entry">
                            <div class="log-header">
                                <span class="log-level \${severityClass}">\${severityLabel}</span>
                                <span class="log-time">\${timeAgo}</span>
                            </div>
                            <div class="log-message">\${log.message || 'No message'}</div>
                            \${log.zone_name ? \`<div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem;">Zone: \${log.zone_name}</div>\` : ''}
                        </div>
                    \`;
                }).join('');
            } catch (error) {
                console.error('Failed to load recent logs:', error);
                document.getElementById('recent-logs-container').innerHTML = \`
                    <div style="text-align: center; padding: 2rem; color: var(--error-color);">
                        <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                        <p>Failed to load recent logs</p>
                    </div>
                \`;
            }
        }
        
        async function createTestEvent() {
            try {
                const response = await fetch('/test-esp32', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    alert('‚úÖ Test event created successfully!\\n\\nYou can now view it in the Logs page.');
                    // Reload stats to show updated counts
                    loadDashboardStats();
                    setTimeout(() => location.reload(), 1000);
                } else {
                    const error = await response.json();
                    alert('‚ùå Failed to create test event: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                alert('‚ùå Error creating test event: ' + error.message);
            }
        }
    `;
    
    res.send(getPageTemplate({
        pageTitle: 'Dashboard',
        pageIcon: 'fas fa-tachometer-alt',
        activeNav: 'dashboard',
        contentBody: contentBody,
        additionalCSS: additionalCSS,
        additionalJS: additionalJS,
        req: req
    }));
});

// Dashboard with Widgets (Primary Dashboard)
app.get('/dashboard', requireAuth, (req, res) => {
    const contentBody = `
        <!-- Load React, React DOM, and React Grid Layout -->
        <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
        <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
        <script src="https://unpkg.com/react-grid-layout@1.4.4/dist/react-grid-layout.min.js"></script>
        <link rel="stylesheet" href="https://unpkg.com/react-grid-layout@1.4.4/css/styles.css" />
        <link rel="stylesheet" href="https://unpkg.com/react-resizable@3.0.5/css/styles.css" />
        
        <!-- Load Chart.js -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
        
        <!-- Dashboard Header -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
            <div>
                <h2 style="margin: 0; color: var(--text-primary);">
                    <i class="fas fa-tachometer-alt"></i> Customizable Dashboard
                </h2>
                <p style="margin: 0.5rem 0 0 0; color: var(--text-secondary); font-size: 0.875rem;">
                    Drag, resize, and customize your widgets - pixel-perfect control
                </p>
            </div>
            <div style="display: flex; gap: 1rem;">
                <button onclick="showWidgetGallery()" class="btn btn-primary">
                    <i class="fas fa-plus"></i> Add Widget
                </button>
                <button onclick="resetWidgetPositions()" class="btn" title="Reset widget positions to default layout">
                    <i class="fas fa-undo"></i> Reset Layout
                </button>
                <button onclick="deleteAllWidgets()" class="btn" style="background: var(--error-color); border-color: var(--error-color);" title="Delete all widgets">
                    <i class="fas fa-trash"></i> Delete All
                </button>
            </div>
        </div>
        
        <!-- Dashboard Container for React -->
        <div id="dashboard-root"></div>

        <!-- Empty State -->
        <div id="empty-state" style="display: none; text-align: center; padding: 4rem 2rem; background: var(--bg-secondary); border-radius: 16px; border: 2px dashed var(--border-color);">
            <i class="fas fa-th" style="font-size: 4rem; color: var(--text-muted); margin-bottom: 1rem;"></i>
            <h3 style="color: var(--text-primary); margin-bottom: 0.5rem;">Your dashboard is empty</h3>
            <p style="color: var(--text-secondary); margin-bottom: 2rem;">Add widgets to customize your dashboard</p>
            <button onclick="showWidgetGallery()" class="btn btn-primary">
                <i class="fas fa-plus"></i> Add Your First Widget
            </button>
        </div>

        <!-- Widget Gallery Modal -->
        <div id="widgetGalleryModal" class="modal" style="display: none;">
            <div class="modal-content widget-gallery-modal">
                <div class="modal-header">
                    <h3><i class="fas fa-th"></i> Widget Gallery</h3>
                    <button onclick="closeModal('widgetGalleryModal')" class="close-btn" title="Close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                        Choose a widget to add to your dashboard
                    </p>
                    <div class="widget-gallery-grid">
                        <div class="widget-card" onclick="addWidget('log_count')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                                <i class="fas fa-database"></i>
                            </div>
                            <h4>Total Logs</h4>
                            <p>Display total log count</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('today_count')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                                <i class="fas fa-calendar-day"></i>
                            </div>
                            <h4>Today's Logs</h4>
                            <p>Show logs from today</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('severity_breakdown')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                                <i class="fas fa-chart-pie"></i>
                            </div>
                            <h4>Severity Breakdown</h4>
                            <p>Pie chart of log levels</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('recent_logs')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);">
                                <i class="fas fa-list"></i>
                            </div>
                            <h4>Recent Logs</h4>
                            <p>Latest log entries</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('system_health')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                                <i class="fas fa-heartbeat"></i>
                            </div>
                            <h4>System Health</h4>
                            <p>Server health metrics</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('system_health_detailed')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #00d2ff 0%, #3a47d5 100%);">
                                <i class="fas fa-server"></i>
                            </div>
                            <h4>Detailed System Health</h4>
                            <p>CPU, memory, database metrics</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('source_stats')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #30cfd0 0%, #330867 100%);">
                                <i class="fas fa-chart-bar"></i>
                            </div>
                            <h4>Top Sources</h4>
                            <p>Most active log sources</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('hourly_trend')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);">
                                <i class="fas fa-chart-line"></i>
                            </div>
                            <h4>Hourly Trend</h4>
                            <p>Log activity by hour</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('error_rate')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);">
                                <i class="fas fa-exclamation-triangle"></i>
                            </div>
                            <h4>Error Rate</h4>
                            <p>Error percentage over time</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('api_keys_count')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);">
                                <i class="fas fa-key"></i>
                            </div>
                            <h4>Active API Keys</h4>
                            <p>Total API keys count</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('uptime_monitor')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #ff6e7f 0%, #bfe9ff 100%);">
                                <i class="fas fa-server"></i>
                            </div>
                            <h4>Uptime Monitor</h4>
                            <p>Server uptime stats</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('integration_status')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #0ea5e9 0%, #3b82f6 100%);">
                                <i class="fas fa-plug"></i>
                            </div>
                            <h4>Integration Status</h4>
                            <p>MQTT, Home Assistant, UniFi</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('error_rate_gauge')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #ef4444 0%, #f59e0b 100%);">
                                <i class="fas fa-tachometer-alt"></i>
                            </div>
                            <h4>Error Rate Gauge</h4>
                            <p>24hr error rate with thresholds</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('network_monitor')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                                <i class="fas fa-network-wired"></i>
                            </div>
                            <h4>Network Monitor</h4>
                            <p>Real-time network traffic & connections</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('quick_stats')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);">
                                <i class="fas fa-chart-area"></i>
                            </div>
                            <h4>Quick Stats</h4>
                            <p>Multiple metrics at a glance</p>
                        </div>

                        <div class="widget-card" onclick="addWidget('top_errors')">
                            <div class="widget-card-icon" style="background: linear-gradient(135deg, #fbc2eb 0%, #a6c1ee 100%);">
                                <i class="fas fa-bug"></i>
                            </div>
                            <h4>Top Errors</h4>
                            <p>Most frequent error messages</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;

    const additionalCSS = `
        /* React Grid Layout Container */
        .react-grid-layout {
            position: relative;
            transition: height 200ms ease;
        }
        
        .react-grid-item {
            transition: all 200ms ease;
            transition-property: left, top, width, height;
        }
        
        .react-grid-item.cssTransforms {
            transition-property: transform, width, height;
        }
        
        .react-grid-item.resizing {
            transition: none;
            z-index: 100;
        }
        
        .react-grid-item.react-draggable-dragging {
            transition: none;
            z-index: 100;
        }
        
        .react-grid-item.react-grid-placeholder {
            background: var(--primary-color);
            opacity: 0.2;
            transition-duration: 100ms;
            z-index: 2;
            border-radius: 8px;
        }
        
        .react-grid-item > .react-resizable-handle {
            position: absolute;
            width: 20px;
            height: 20px;
        }
        
        .react-grid-item > .react-resizable-handle::after {
            content: "";
            position: absolute;
            right: 3px;
            bottom: 3px;
            width: 5px;
            height: 5px;
            border-right: 2px solid rgba(255, 255, 255, 0.4);
            border-bottom: 2px solid rgba(255, 255, 255, 0.4);
        }
        
        /* Widget Card Styles */
        .widget-container {
            width: 100%;
            height: 100%;
        }
        
        .widget-card {
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        
        .widget-card:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
            border-color: rgba(255, 255, 255, 0.12);
        }

        /* Compact Widget Header - Unraid Style */
        .widget-header {
            padding: 0.5rem 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 36px;
        }

        .widget-title {
            font-size: clamp(0.7rem, 1.2vw, 0.8rem);
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.4rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.9;
        }
        
        .widget-drag-handle {
            cursor: move;
            cursor: grab;
            flex: 1;
        }
        
        .widget-drag-handle:active {
            cursor: grabbing;
        }

        .widget-title i {
            font-size: 0.85em;
            opacity: 0.7;
        }

        .widget-actions {
            display: flex;
            gap: 0.25rem;
        }

        .widget-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.2rem;
            border-radius: 4px;
            transition: all 0.2s;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .widget-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--accent-primary);
        }
        
        .widget-delete-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 6px;
            transition: all 0.2s;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            z-index: 10;  /* Ensure it's above drag handle */
        }
        
        .widget-delete-btn:hover {
            background: var(--error-color);
            color: white;
            transform: rotate(90deg);
        }

        .widget-body {
            padding: 1rem;
            flex: 1;
            overflow: auto;
            container-type: size;  /* Enable container queries for responsive text */
        }

        /* Compact Widget Gallery */
        /* Widget Gallery Modal */
        .widget-gallery-modal {
            max-width: 1000px !important;
            width: 95% !important;
        }
        
        .widget-gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1.25rem;
            max-height: 60vh;
            overflow-y: auto;
            padding: 0.5rem;
        }
        
        /* Responsive adjustments for widget gallery */
        @media (max-width: 768px) {
            .widget-gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 1rem;
            }
            
            .widget-gallery-modal {
                max-width: 95% !important;
            }
        }
        
        @media (max-width: 480px) {
            .widget-gallery-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
            }
        }

        .widget-card {
            background: var(--bg-secondary);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1.25rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .widget-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .widget-card:hover {
            border-color: var(--accent-primary);
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }
        
        .widget-card:hover::before {
            transform: scaleX(1);
        }
        
        .widget-card:active {
            transform: translateY(-2px);
        }

        .widget-card-icon {
            width: 56px;
            height: 56px;
            margin: 0 auto 1rem;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.75rem;
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .widget-card h4 {
            margin: 0 0 0.5rem 0;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-weight: 600;
            line-height: 1.3;
        }

        .widget-card p {
            margin: 0;
            color: var(--text-secondary);
            font-size: 0.8rem;
            line-height: 1.4;
        }

        /* Clean Stat Display - Now with container queries for better scaling */
        .stat-widget-value {
            font-size: clamp(1.5rem, 8cqw, 4rem);
            font-weight: 600;
            color: var(--accent-primary);
            text-align: center;
            margin: 1.5rem 0 0.5rem 0;
            line-height: 1;
        }

        .stat-widget-label {
            text-align: center;
            color: var(--text-secondary);
            font-size: clamp(0.65rem, 2.5cqw, 1.2rem);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.8;
        }

        /* Chart Widget Styles */
        .chart-widget-container {
            position: relative;
            height: 100%;
            min-height: 200px;
        }

        /* Compact List Widget */
        .widget-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .widget-list-item {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .widget-list-item:last-child {
            border-bottom: none;
        }

        .widget-list-item:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        /* Compact Health Grid */
        .health-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        .health-metric {
            text-align: center;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .health-metric-value {
            font-size: clamp(1.1rem, 2.5vw, 1.4rem);
            font-weight: 600;
            color: var(--accent-primary);
            line-height: 1.2;
        }

        .health-metric-label {
            font-size: clamp(0.65rem, 1.1vw, 0.7rem);
            color: var(--text-secondary);
            margin-top: 0.25rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.7;
        }

        /* Compact Log Level Badges */
        .log-level-badge {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .log-level-badge.info { background: rgba(59, 130, 246, 0.1); color: #3b82f6; }
        .log-level-badge.warn { background: rgba(245, 158, 11, 0.1); color: #f59e0b; }
        .log-level-badge.error { background: rgba(239, 68, 68, 0.1); color: #ef4444; }
        .log-level-badge.debug { background: rgba(156, 163, 175, 0.1); color: #9ca3af; }
    `;

    const additionalJS = `
        // Chart.js loading helper
        function waitForChart(callback) {
            if (typeof Chart !== 'undefined') {
                callback();
            } else {
                setTimeout(() => waitForChart(callback), 50);
            }
        }

        const { useState, useEffect, useRef } = React;
        const ReactGridLayout = window.ReactGridLayout;
        
        let widgetCharts = {};  // Store Chart.js instances
        
        // Main Dashboard Component
        function Dashboard() {
            const [widgets, setWidgets] = useState([]);
            const [layout, setLayout] = useState([]);
            
            // Load widgets from server
            useEffect(() => {
                loadDashboard();
            }, []);
            
            async function loadDashboard() {
                console.log('üîÑ Loading dashboard widgets...');
                try {
                    const response = await fetch('/api/dashboard/widgets');
                    const data = await response.json();
                    
                    if (data.widgets && data.widgets.length > 0) {
                        console.log('Found ' + data.widgets.length + ' widgets');
                        
                        setWidgets(data.widgets);
                        
                        // Convert database positions to React Grid Layout format
                        const layoutData = data.widgets.map(w => ({
                            i: w.id.toString(),
                            x: w.position_x,          // Direct column position (0-11)
                            y: w.position_y,          // Row position in grid units
                            w: w.width,               // Width in columns (1-12)
                            h: w.height,              // Height in row units
                            minW: 2,                  // Minimum 2 columns width
                            minH: 3                   // Minimum 3 rows height
                        }));
                        
                        setLayout(layoutData);
                        setPreviousLayout(layoutData);  // Initialize previous layout
                        document.getElementById('empty-state').style.display = 'none';
                        
                        // Load data for each widget
                        setTimeout(() => {
                            data.widgets.forEach(widget => {
                                loadWidgetData(widget.id, widget.widget_type);
                            });
                        }, 500);
                    } else {
                        console.log('‚ö†Ô∏è No widgets found');
                        document.getElementById('empty-state').style.display = 'block';
                    }
                } catch (error) {
                    console.error('‚ùå Failed to load dashboard:', error);
                    showToast('Failed to load dashboard', 'error');
                }
            }
            
            // Store previous layout for swap detection
            const [previousLayout, setPreviousLayout] = useState([]);
            const [isDragging, setIsDragging] = useState(false);
            const [hasSwappedThisDrag, setHasSwappedThisDrag] = useState(false);
            const [dragStartLayout, setDragStartLayout] = useState([]);
            
            // Handle layout change (drag/resize) with swap detection
            function onLayoutChange(newLayout) {
                // Only detect swaps when actively dragging AND haven't already swapped
                if (isDragging && !hasSwappedThisDrag && dragStartLayout.length > 0 && newLayout.length === dragStartLayout.length) {
                    // Find the widget being dragged
                    const draggedWidget = newLayout.find((item, idx) => {
                        const startItem = dragStartLayout[idx];
                        if (!startItem || startItem.i !== item.i) return false;
                        // Only consider it "dragged" if moved more than 1 full grid unit
                        return Math.abs(item.x - startItem.x) >= 1 || Math.abs(item.y - startItem.y) >= 1;
                    });
                    
                    if (draggedWidget) {
                        const swapped = detectAndHandleSwap(dragStartLayout, newLayout, draggedWidget);
                        if (swapped) {
                            console.log('‚ú® Widget swap detected and applied');
                            setLayout(swapped);
                            setPreviousLayout(swapped);
                            setDragStartLayout(swapped);
                            setHasSwappedThisDrag(true);  // Prevent additional swaps this drag
                            saveLayout(swapped);
                            return;
                        }
                    }
                }
                
                // Update layout for normal changes
                setLayout(newLayout);
                setPreviousLayout(newLayout);
            }
            
            // Detect if a widget was dragged onto another and swap them
            function detectAndHandleSwap(startLayout, currentLayout, draggedWidget) {
                const startItem = startLayout.find(item => item.i === draggedWidget.i);
                if (!startItem) return null;
                
                // Find if there's another widget at the position where dragged widget wants to go
                const targetWidget = startLayout.find(item => {
                    if (item.i === draggedWidget.i) return false; // Skip self
                    
                    // Check if dragged widget significantly overlaps target's START position
                    // This ensures we only swap when genuinely dropped on another widget
                    const centerX = draggedWidget.x + draggedWidget.w / 2;
                    const centerY = draggedWidget.y + draggedWidget.h / 2;
                    
                    const xInside = centerX >= item.x && centerX < item.x + item.w;
                    const yInside = centerY >= item.y && centerY < item.y + item.h;
                    
                    return xInside && yInside;
                });
                
                if (targetWidget) {
                    console.log(\`üîÑ Swapping widget \${draggedWidget.i} with \${targetWidget.i}\`);
                    
                    // Create swapped layout
                    const swappedLayout = currentLayout.map(item => {
                        if (item.i === draggedWidget.i) {
                            // Dragged widget takes target's START position
                            return {
                                ...item,
                                x: targetWidget.x,
                                y: targetWidget.y
                            };
                        } else if (item.i === targetWidget.i) {
                            // Target widget takes dragged widget's START position
                            return {
                                ...item,
                                x: startItem.x,
                                y: startItem.y
                            };
                        }
                        return item;
                    });
                    
                    return swappedLayout;
                }
                
                return null; // No swap detected
            }
            
            // Save layout to server
            async function saveLayout(layoutData) {
                try {
                    const updates = layoutData.map(item => {
                        const widget = widgets.find(w => w.id.toString() === item.i);
                        if (!widget) return null;
                        
                        return {
                            id: widget.id,
                            position_x: Math.round(item.x),  // Already in column units
                            position_y: Math.round(item.y),  // Already in row units
                            width: Math.round(item.w),       // Already in column units (1-12)
                            height: Math.round(item.h)       // Already in row units
                        };
                    }).filter(Boolean);
                    
                    await fetch('/api/dashboard/widgets/positions', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ widgets: updates })
                    });
                } catch (error) {
                    console.error('Failed to save layout:', error);
                }
            }
            
            return React.createElement(ReactGridLayout, {
                className: 'layout',
                layout: layout,
                onLayoutChange: onLayoutChange,
                onDragStart: () => {
                    console.log('üñ±Ô∏è Drag started');
                    setIsDragging(true);
                    setDragStartLayout(layout);  // Capture the starting layout
                    // DON'T reset hasSwappedThisDrag here - only on drag stop
                },
                onDragStop: () => {
                    console.log('üñ±Ô∏è Drag stopped');
                    setIsDragging(false);
                    setHasSwappedThisDrag(false);  // Reset swap flag for next drag
                    saveLayout(layout);  // Save final layout
                },
                cols: 12,
                rowHeight: 30,
                width: 1200,
                isDraggable: true,
                isResizable: true,
                compactType: null,        // Disable auto-compact for swap behavior
                preventCollision: false,  // Allow overlap detection for swap
                allowOverlap: false,      // Don't allow final overlap
                margin: [10, 10],
                containerPadding: [0, 0],
                draggableHandle: '.widget-drag-handle',  // Only drag by this handle
                verticalCompact: false,   // Disable vertical compaction for swap
                useCSSTransforms: true    // Smoother transitions
            }, 
                widgets.map(widget => 
                    React.createElement('div', {
                        key: widget.id.toString(),
                        className: 'widget-container',
                        'data-widget-id': widget.id
                    }, renderWidgetContent(widget))
                )
            );
        }
        
        // Render widget content (returns HTML string for React dangerouslySetInnerHTML)
        function renderWidgetContent(widget) {
            return React.createElement('div', {
                className: 'widget-card',
                dangerouslySetInnerHTML: {
                    __html: \`
                        <div class="widget-header">
                            <span class="widget-title widget-drag-handle">
                                <i class="\${getWidgetIcon(widget.widget_type)}"></i>
                                \${widget.title}
                            </span>
                            <button onclick="event.stopPropagation(); deleteWidget(\${widget.id})" class="widget-delete-btn" title="Delete widget">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="widget-body" id="widget-\${widget.id}">
                            <div class="widget-loading">
                                <i class="fas fa-spinner fa-spin"></i>
                                <p>Loading...</p>
                            </div>
                        </div>
                    \`
                }
            });
        }
        
        // Get widget icon
        function getWidgetIcon(type) {
            const icons = {
                log_count: 'fas fa-database',
                today_count: 'fas fa-calendar-day',
                log_level_distribution: 'fas fa-chart-pie',
                recent_logs: 'fas fa-list',
                system_health: 'fas fa-heartbeat',
                system_health_detailed: 'fas fa-heartbeat',
                source_stats: 'fas fa-chart-bar',
                hourly_trend: 'fas fa-chart-line',
                error_rate: 'fas fa-exclamation-triangle',
                api_keys_count: 'fas fa-key',
                uptime_monitor: 'fas fa-clock',
                quick_stats: 'fas fa-tachometer-alt',
                top_errors: 'fas fa-bug'
            };
            return icons[type] || 'fas fa-cube';
        }

        // Get widget title
        function getWidgetTitle(type) {
            const titles = {
                log_count: 'Total Logs',
                today_count: "Today's Logs",
                severity_breakdown: 'Severity Breakdown',
                log_level_distribution: 'Log Level Distribution',
                recent_logs: 'Recent Logs',
                system_health: 'System Health',
                system_health_detailed: 'Detailed System Health',
                source_stats: 'Top Sources',
                hourly_trend: 'Hourly Trend',
                error_rate: 'Error Rate',
                api_keys_count: 'Active API Keys',
                uptime_monitor: 'Uptime Monitor',
                quick_stats: 'Quick Stats',
                top_errors: 'Top Errors',
                integration_status: 'Integration Status',
                error_rate_gauge: 'Error Rate Gauge',
                network_monitor: 'Network Monitor'
            };
            return titles[type] || 'Widget';
        }

        // Load widget data from API
        async function loadWidgetData(widgetId, widgetType) {
            try {
                const response = await fetch(\`/api/dashboard/widget-data/\${widgetType}\`);
                const data = await response.json();
                
                const bodyEl = document.getElementById(\`widget-\${widgetId}\`);
                if (!bodyEl) {
                    console.warn(\`Widget body not found: widget-\${widgetId}\`);
                    return;
                }
                
                renderWidget(widgetId, widgetType, data, bodyEl);
            } catch (error) {
                console.error(\`Failed to load widget \${widgetId}:\`, error);
                const bodyEl = document.getElementById(\`widget-\${widgetId}\`);
                if (bodyEl) {
                    bodyEl.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i><p>Failed to load data</p></div>';
                }
            }
        }

        // Render widget based on type
        function renderWidget(widgetId, type, data, container) {
            switch(type) {
                case 'log_count':
                    container.innerHTML = \`
                        <div class="stat-widget-value">\${data.count.toLocaleString()}</div>
                        <div class="stat-widget-label">Total Log Entries</div>
                    \`;
                    break;
                    
                case 'today_count':
                    container.innerHTML = \`
                        <div class="stat-widget-value">\${data.count.toLocaleString()}</div>
                        <div class="stat-widget-label">Logs Today</div>
                    \`;
                    break;
                    
                case 'severity_breakdown':
                    renderPieChart(widgetId, data);
                    break;
                    
                case 'recent_logs':
                    renderRecentLogs(container, data);
                    break;
                    
                case 'system_health':
                    renderSystemHealth(container, data);
                    break;
                    
                case 'system_health_detailed':
                    renderSystemHealthDetailed(container, data);
                    break;
                    
                case 'source_stats':
                    renderBarChart(widgetId, data);
                    break;
                    
                case 'hourly_trend':
                    renderLineChart(widgetId, data);
                    break;
                    
                case 'error_rate':
                    renderErrorRateChart(widgetId, data);
                    break;
                    
                case 'api_keys_count':
                    container.innerHTML = \`
                        <div class="stat-widget-value">\${data.count}</div>
                        <div class="stat-widget-label">Active API Keys</div>
                    \`;
                    break;
                    
                case 'uptime_monitor':
                    container.innerHTML = \`
                        <div class="stat-widget-value">\${data.formatted}</div>
                        <div class="stat-widget-label">Server Uptime</div>
                    \`;
                    break;
                    
                case 'quick_stats':
                    renderQuickStats(container, data);
                    break;
                    
                case 'top_errors':
                    renderTopErrors(container, data);
                    break;
                    
                case 'integration_status':
                    renderIntegrationStatus(container, data);
                    break;
                    
                case 'error_rate_gauge':
                    renderErrorRateGauge(container, data);
                    break;
                    
                case 'network_monitor':
                    renderNetworkMonitor(container, data);
                    break;
            }
        }

        // Render pie chart for severity breakdown
        function renderPieChart(widgetId, data) {
            const container = document.getElementById(\`widget-\${widgetId}\`);
            
            if (!container) {
                console.warn('Pie chart container not found:', widgetId);
                return;
            }
            
            if (!data || data.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No severity data available</div>';
                return;
            }
            
            container.innerHTML = '<canvas id="chart-' + widgetId + '"></canvas>';
            
            const canvas = document.getElementById('chart-' + widgetId);
            const labels = data.map(item => item.severity || 'unknown');
            const values = data.map(item => item.count);
            const severityColors = {
                'debug': '#9ca3af',
                'info': '#3b82f6',
                'warning': '#f59e0b',
                'error': '#ef4444',
                'critical': '#dc2626'
            };
            const colors = labels.map(label => severityColors[label.toLowerCase()] || '#6b7280');
            
            waitForChart(() => {
                widgetCharts[widgetId] = new Chart(canvas, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: colors,
                        borderWidth: 2,
                        borderColor: 'var(--bg-primary)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: 'var(--text-primary)',
                                padding: 10,
                                font: { size: 11 }
                            }
                        }
                    }
                }
            });
            });
        }

        // Render bar chart for source stats
        function renderBarChart(widgetId, data) {
            const container = document.getElementById(\`widget-\${widgetId}\`);
            
            if (!container) {
                console.warn('Bar chart container not found:', widgetId);
                return;
            }
            
            if (!data || data.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No source data available</div>';
                return;
            }
            
            container.innerHTML = '<canvas id="chart-' + widgetId + '"></canvas>';
            
            const canvas = document.getElementById('chart-' + widgetId);
            const labels = data.map(item => item.source || 'unknown');
            const values = data.map(item => item.count);
            
            waitForChart(() => {
                widgetCharts[widgetId] = new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Log Count',
                        data: values,
                        backgroundColor: 'rgba(59, 130, 246, 0.7)',
                        borderColor: '#3b82f6',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { 
                                color: 'var(--text-muted)',
                                font: { size: 10 }
                            },
                            grid: { color: 'rgba(255,255,255,0.05)' }
                        },
                        x: {
                            ticks: { 
                                color: 'var(--text-muted)',
                                font: { size: 10 }
                            },
                            grid: { display: false }
                        }
                    }
                }
            });
            });
        }

        // Render recent logs list
        function renderRecentLogs(container, data) {
            // Handle both array and object with logs property
            const logs = Array.isArray(data) ? data : (data.logs || []);
            
            if (!logs || logs.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No recent logs</div>';
                return;
            }
            
            const html = \`
                <ul class="widget-list">
                    \${logs.map(log => \`
                        <li class="widget-list-item">
                            <div>
                                <span class="log-level-badge \${log.severity || log.level || 'info'}">\${log.severity || log.level || 'info'}</span>
                                <span style="margin-left: 0.5rem; font-size: 0.875rem;">\${(log.message || '').substring(0, 40)}...</span>
                            </div>
                            <span style="font-size: 0.75rem; color: var(--text-muted);">\${new Date(log.timestamp).toLocaleTimeString()}</span>
                        </li>
                    \`).join('')}
                </ul>
            \`;
            container.innerHTML = html;
        }

        // Render system health metrics
        function renderSystemHealth(container, data) {
            if (!data) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No health data available</div>';
                return;
            }
            
            const uptime = data.uptime || 0;
            const uptimeHours = Math.floor(uptime / 3600);
            const uptimeMinutes = Math.floor((uptime % 3600) / 60);
            const memory = data.memory || {};
            const memoryUsed = memory.used || 0;
            
            const html = \`
                <div class="health-grid">
                    <div class="health-metric">
                        <div class="health-metric-value">\${memoryUsed}MB</div>
                        <div class="health-metric-label">Memory</div>
                    </div>
                    <div class="health-metric">
                        <div class="health-metric-value">\${uptimeHours}h \${uptimeMinutes}m</div>
                        <div class="health-metric-label">Uptime</div>
                    </div>
                </div>
            \`;
            container.innerHTML = html;
        }

        // Render detailed system health with progress bars
        function renderSystemHealthDetailed(container, data) {
            if (!data) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No health data available</div>';
                return;
            }
            
            const uptimeHours = Math.floor(data.uptime / 3600);
            const uptimeMinutes = Math.floor((data.uptime % 3600) / 60);
            
            const getStatusColor = (percent) => {
                if (percent >= 90) return '#ef4444'; // Red
                if (percent >= 75) return '#f59e0b'; // Orange
                return '#10b981'; // Green
            };
            
            const html = \`
                <div style="display: flex; flex-direction: column; gap: 1rem;">
                    <!-- Node.js Heap Memory -->
                    <div style="padding: 0.75rem; background: rgba(0, 0, 0, 0.2); border-radius: 6px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <span style="font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary);">Node.js Heap</span>
                            <span style="font-size: 0.75rem; font-weight: 600; color: \${getStatusColor(data.heap.percent)};">\${data.heap.percent}%</span>
                        </div>
                        <div style="font-size: 0.9rem; font-weight: 700; color: var(--text-primary); margin-bottom: 0.5rem;">
                            \${data.heap.used} MB / \${data.heap.total} MB
                        </div>
                        <div style="width: 100%; height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden;">
                            <div style="height: 100%; width: \${data.heap.percent}%; background: \${getStatusColor(data.heap.percent)}; transition: width 0.3s;"></div>
                        </div>
                    </div>
                    
                    <!-- System Memory -->
                    <div style="padding: 0.75rem; background: rgba(0, 0, 0, 0.2); border-radius: 6px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <span style="font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary);">System Memory</span>
                            <span style="font-size: 0.75rem; font-weight: 600; color: \${getStatusColor(data.system.percent)};">\${data.system.percent}%</span>
                        </div>
                        <div style="font-size: 0.9rem; font-weight: 700; color: var(--text-primary); margin-bottom: 0.5rem;">
                            \${data.system.used} MB / \${data.system.total} MB
                        </div>
                        <div style="width: 100%; height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden;">
                            <div style="height: 100%; width: \${data.system.percent}%; background: \${getStatusColor(data.system.percent)}; transition: width 0.3s;"></div>
                        </div>
                    </div>
                    
                    <!-- Database & Uptime -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                        <div class="health-metric">
                            <div class="health-metric-value">\${data.database.size} MB</div>
                            <div class="health-metric-label">Database</div>
                        </div>
                        <div class="health-metric">
                            <div class="health-metric-value">\${uptimeHours}h \${uptimeMinutes}m</div>
                            <div class="health-metric-label">Uptime</div>
                        </div>
                    </div>
                </div>
            \`;
            container.innerHTML = html;
        }

        // Render line chart for hourly trend
        function renderLineChart(widgetId, data) {
            const container = document.getElementById(\`widget-\${widgetId}\`);
            
            if (!container) {
                console.warn('Line chart container not found:', widgetId);
                return;
            }
            
            if (!data || data.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No trend data available</div>';
                return;
            }
            
            container.innerHTML = '<canvas id="chart-' + widgetId + '"></canvas>';
            const canvas = document.getElementById('chart-' + widgetId);
            const labels = data.map(item => item.hour + ':00');
            const values = data.map(item => item.count);
            
            waitForChart(() => {
                widgetCharts[widgetId] = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Log Count',
                        data: values,
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { 
                                color: 'var(--text-muted)',
                                font: { size: 10 }
                            },
                            grid: { color: 'rgba(255,255,255,0.05)' }
                        },
                        x: {
                            ticks: { 
                                color: 'var(--text-muted)',
                                font: { size: 10 }
                            },
                            grid: { display: false }
                        }
                    }
                }
            });
            });
        }

        // Render error rate chart
        function renderErrorRateChart(widgetId, data) {
            const container = document.getElementById(\`widget-\${widgetId}\`);
            
            if (!container) {
                console.warn('Error rate chart container not found:', widgetId);
                return;
            }
            
            if (!data || data.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No error data available</div>';
                return;
            }
            
            container.innerHTML = '<canvas id="chart-' + widgetId + '"></canvas>';
            const canvas = document.getElementById('chart-' + widgetId);
            const labels = data.map(item => item.hour + ':00');
            const values = data.map(item => parseFloat(item.rate));
            
            waitForChart(() => {
                widgetCharts[widgetId] = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Error Rate %',
                        data: values,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: { 
                                color: 'var(--text-muted)',
                                font: { size: 10 },
                                callback: function(value) { return value + '%'; }
                            },
                            grid: { color: 'rgba(255,255,255,0.05)' }
                        },
                        x: {
                            ticks: { 
                                color: 'var(--text-muted)',
                                font: { size: 10 }
                            },
                            grid: { display: false }
                        }
                    }
                }
            });
            });
        }

        // Render quick stats grid
        function renderQuickStats(container, data) {
            if (!data) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No stats available</div>';
                return;
            }
            
            const html = \`
                <div class="health-grid" style="grid-template-columns: repeat(2, 1fr);">
                    <div class="health-metric">
                        <div class="health-metric-value">\${(data.total_logs || 0).toLocaleString()}</div>
                        <div class="health-metric-label">Total Logs</div>
                    </div>
                    <div class="health-metric">
                        <div class="health-metric-value">\${data.errors || 0}</div>
                        <div class="health-metric-label">Errors</div>
                    </div>
                    <div class="health-metric">
                        <div class="health-metric-value">\${data.last_hour || 0}</div>
                        <div class="health-metric-label">Last Hour</div>
                    </div>
                    <div class="health-metric">
                        <div class="health-metric-value">\${data.sources || 0}</div>
                        <div class="health-metric-label">Sources</div>
                    </div>
                </div>
            \`;
            container.innerHTML = html;
        }

        // Render top errors list
        function renderTopErrors(container, data) {
            if (!data || data.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No errors in last 24h</div>';
                return;
            }
            
            const html = \`
                <ul class="widget-list">
                    \${data.map(error => \`
                        <li class="widget-list-item">
                            <div style="flex: 1;">
                                <div style="font-size: 0.8rem; margin-bottom: 0.25rem;">\${(error.message || '').substring(0, 50)}...</div>
                                <div style="font-size: 0.7rem; color: var(--text-muted);">
                                    <span class="log-level-badge error" style="font-size: 0.6rem; padding: 0.1rem 0.3rem;">\${error.count}x</span>
                                    <span style="margin-left: 0.5rem;">\${new Date(error.last_seen).toLocaleString()}</span>
                                </div>
                            </div>
                        </li>
                    \`).join('')}
                </ul>
            \`;
            container.innerHTML = html;
        }

        // Render integration status widget
        function renderIntegrationStatus(container, data) {
            if (!data) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No integration data available</div>';
                return;
            }
            
            const getStatusIcon = (status) => status === 'online' ? 'check-circle' : 'times-circle';
            const getStatusColor = (status) => status === 'online' ? '#10b981' : '#ef4444';
            
            const integrations = [
                { name: 'MQTT', icon: 'comments', ...data.mqtt },
                { name: 'Home Assistant', icon: 'home', ...data.homeAssistant },
                { name: 'UniFi', icon: 'wifi', ...data.unifi },
                { name: 'WebSocket', icon: 'plug', ...data.websocket }
            ].filter(i => i.enabled);
            
            if (integrations.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);"><i class="fas fa-info-circle"></i><br/>No integrations enabled</div>';
                return;
            }
            
            const html = \`
                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    \${integrations.map(integration => \`
                        <div style="padding: 0.75rem; background: rgba(0, 0, 0, 0.2); border-radius: 6px; display: flex; align-items: center; justify-content: space-between;">
                            <div style="display: flex; align-items: center; gap: 0.75rem; flex: 1;">
                                <i class="fas fa-\${integration.icon}" style="font-size: 1.2rem; color: \${getStatusColor(integration.status)};"></i>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; font-size: 0.9rem; margin-bottom: 0.1rem;">\${integration.name}</div>
                                    <div style="font-size: 0.7rem; color: var(--text-muted);">
                                        \${integration.clients !== undefined ? \`\${integration.clients} clients\` : ''}
                                        \${integration.lastSeen ? \`Last: \${new Date(integration.lastSeen).toLocaleTimeString()}\` : ''}
                                    </div>
                                </div>
                            </div>
                            <i class="fas fa-\${getStatusIcon(integration.status)}" style="font-size: 1.5rem; color: \${getStatusColor(integration.status)};"></i>
                        </div>
                    \`).join('')}
                </div>
            \`;
            container.innerHTML = html;
        }

        // Render error rate gauge widget
        function renderErrorRateGauge(container, data) {
            if (!data) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No error rate data available</div>';
                return;
            }
            
            const { errorRate, errors, total, status, threshold } = data;
            const gaugeColor = status === 'good' ? '#10b981' : status === 'warning' ? '#f59e0b' : '#ef4444';
            const percentage = Math.min(errorRate, 100);
            
            const html = \`
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 1rem;">
                    <!-- Gauge Visualization -->
                    <div style="position: relative; width: 150px; height: 150px; margin-bottom: 1rem;">
                        <svg width="150" height="150" viewBox="0 0 150 150">
                            <!-- Background circle -->
                            <circle cx="75" cy="75" r="60" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="15"/>
                            <!-- Progress circle -->
                            <circle 
                                cx="75" 
                                cy="75" 
                                r="60" 
                                fill="none" 
                                stroke="\${gaugeColor}" 
                                stroke-width="15"
                                stroke-dasharray="\${(percentage / 100) * 377} 377"
                                stroke-dashoffset="0"
                                transform="rotate(-90 75 75)"
                                stroke-linecap="round"
                                style="transition: stroke-dasharray 0.5s ease;"
                            />
                        </svg>
                        <!-- Center value -->
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                            <div style="font-size: 2rem; font-weight: 700; color: \${gaugeColor};">\${errorRate.toFixed(1)}%</div>
                            <div style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">\${status}</div>
                        </div>
                    </div>
                    
                    <!-- Stats -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; width: 100%;">
                        <div style="text-align: center; padding: 0.5rem; background: rgba(0, 0, 0, 0.2); border-radius: 6px;">
                            <div style="font-size: 1.2rem; font-weight: 700; color: var(--error-color);">\${errors.toLocaleString()}</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">Errors</div>
                        </div>
                        <div style="text-align: center; padding: 0.5rem; background: rgba(0, 0, 0, 0.2); border-radius: 6px;">
                            <div style="font-size: 1.2rem; font-weight: 700; color: var(--text-primary);">\${total.toLocaleString()}</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">Total</div>
                        </div>
                    </div>
                    
                    <!-- Thresholds -->
                    <div style="margin-top: 0.75rem; font-size: 0.7rem; color: var(--text-muted); text-align: center;">
                        <span style="color: #10b981;">‚óè &lt;\${threshold.good}%</span>
                        <span style="margin: 0 0.5rem; color: #f59e0b;">‚óè &lt;\${threshold.warning}%</span>
                        <span style="color: #ef4444;">‚óè &gt;\${threshold.warning}%</span>
                    </div>
                </div>
            \`;
            container.innerHTML = html;
        }

        // Render network monitor widget
        function renderNetworkMonitor(container, data) {
            if (!data) {
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">No network data available</div>';
                return;
            }
            
            const { bytesIn, bytesOut, requestsIn, requestsOut, totalBytes, totalRequests, connections } = data;
            
            // Format bytes to human-readable
            function formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            // Connection type configurations
            const connectionTypes = [
                { key: 'nodeRed', icon: 'fa-project-diagram', label: 'Node-RED', color: '#8B0000' },
                { key: 'esp32', icon: 'fa-microchip', label: 'ESP32', color: '#00979C' },
                { key: 'api', icon: 'fa-code', label: 'API', color: '#6366f1' },
                { key: 'dashboard', icon: 'fa-tachometer-alt', label: 'Dashboard', color: '#3b82f6' }
            ];
            
            // Build connection status HTML
            let connectionsHtml = '';
            connectionTypes.forEach(type => {
                const conn = connections[type.key];
                if (conn && conn.count > 0) {
                    const statusColor = conn.active ? '#10b981' : '#6b7280';
                    const statusIcon = conn.active ? 'fa-circle' : 'fa-circle';
                    connectionsHtml += \`
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.4rem 0.5rem; background: rgba(0, 0, 0, 0.1); border-radius: 6px; border-left: 3px solid \${type.color};">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <i class="fas \${type.icon}" style="color: \${type.color}; font-size: 0.875rem;"></i>
                                <span style="font-size: 0.75rem; font-weight: 600; color: var(--text-primary);">\${type.label}</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <span style="font-size: 0.7rem; color: var(--text-muted);">\${conn.count} req</span>
                                <i class="fas \${statusIcon}" style="color: \${statusColor}; font-size: 0.5rem;"></i>
                            </div>
                        </div>
                    \`;
                }
            });
            
            if (!connectionsHtml) {
                connectionsHtml = '<div style="text-align: center; padding: 0.5rem; font-size: 0.7rem; color: var(--text-muted);">No connections yet</div>';
            }
            
            const html = \`
                <div style="display: flex; flex-direction: column; height: 100%; padding: 0.5rem; overflow-y: auto;">
                    <!-- Header Stats -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.75rem;">
                        <!-- Incoming -->
                        <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.05) 100%); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 0.75rem; text-align: center;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 0.25rem; margin-bottom: 0.25rem;">
                                <i class="fas fa-arrow-down" style="color: #10b981; font-size: 0.875rem;"></i>
                                <span style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Incoming</span>
                            </div>
                            <div style="font-size: 1.25rem; font-weight: 700; color: #10b981;">\${formatBytes(bytesIn)}</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">\${requestsIn.toLocaleString()} requests</div>
                        </div>
                        
                        <!-- Outgoing -->
                        <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(37, 99, 235, 0.05) 100%); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 0.75rem; text-align: center;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 0.25rem; margin-bottom: 0.25rem;">
                                <i class="fas fa-arrow-up" style="color: #3b82f6; font-size: 0.875rem;"></i>
                                <span style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">Outgoing</span>
                            </div>
                            <div style="font-size: 1.25rem; font-weight: 700; color: #3b82f6;">\${formatBytes(bytesOut)}</div>
                            <div style="font-size: 0.7rem; color: var(--text-muted);">\${requestsOut.toLocaleString()} responses</div>
                        </div>
                    </div>
                    
                    <!-- Connections Breakdown -->
                    <div style="margin-bottom: 0.75rem;">
                        <div style="font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem; font-weight: 600;">
                            <i class="fas fa-plug"></i> Active Connections
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 0.375rem;">
                            \${connectionsHtml}
                        </div>
                    </div>
                    
                    <!-- Total Stats -->
                    <div style="background: rgba(0, 0, 0, 0.2); border-radius: 8px; padding: 0.75rem; margin-bottom: 0.5rem;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; text-align: center;">
                            <div>
                                <div style="font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; margin-bottom: 0.25rem;">Total Data</div>
                                <div style="font-size: 1.1rem; font-weight: 700; color: var(--text-primary);">\${formatBytes(totalBytes)}</div>
                            </div>
                            <div>
                                <div style="font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; margin-bottom: 0.25rem;">Total Requests</div>
                                <div style="font-size: 1.1rem; font-weight: 700; color: var(--text-primary);">\${totalRequests.toLocaleString()}</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Info Note -->
                    <div style="text-align: center; font-size: 0.65rem; color: var(--text-muted); line-height: 1.3;">
                        <i class="fas fa-info-circle"></i> Port 10180 ‚Ä¢ <i class="fas fa-circle" style="color: #10b981; font-size: 0.5rem;"></i> Active
                    </div>
                </div>
            \`;
            container.innerHTML = html;
        }

        // Show widget gallery modal
        function showWidgetGallery() {
            document.getElementById('widgetGalleryModal').style.display = 'flex';
        }

        // Add widget to dashboard
        // Remove widget (now handled by window.deleteWidget)
        // This function kept for backwards compatibility but not used
        async function removeWidget(widgetId) {
            window.deleteWidget(widgetId);
        }

        // Refresh widget data
        async function refreshWidget(widgetId, widgetType) {
            const btn = event.target.closest('button');
            const icon = btn.querySelector('i');
            icon.classList.add('fa-spin');
            
            try {
                await loadWidgetData(widgetId, widgetType);
                showToast('Widget refreshed', 'success');
            } finally {
                icon.classList.remove('fa-spin');
            }
        }

        // Save layout to backend
        async function saveLayout() {
            const nodes = grid.engine.nodes;
            const widgets = nodes.map(node => ({
                id: parseInt(node.el.getAttribute('gs-id')),
                position_x: node.x,
                position_y: node.y,
                width: node.w,
                height: node.h
            }));
            
            try {
                await fetch('/api/dashboard/widgets/positions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ widgets })
                });
            } catch (error) {
                console.error('Failed to save layout:', error);
            }
        }

        // Reset dashboard to default
        // Reset widget positions to default layout
        async function resetWidgetPositions() {
            if (!confirm('Reset widget positions to default layout? This will rearrange your widgets but keep them.')) return;
            
            console.log('üîÑ Resetting widget positions...');
            
            try {
                const response = await fetch('/api/dashboard/widgets/reset-positions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                console.log('üì° Reset response status:', response.status);
                const data = await response.json();
                console.log('üì¶ Reset response data:', data);
                
                if (data.success) {
                    showToast('Widget positions reset - reloading page...', 'success');
                    // Force page reload to ensure fresh state
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);
                } else {
                    showToast(data.error || 'Failed to reset positions', 'error');
                }
            } catch (error) {
                console.error('‚ùå Failed to reset positions:', error);
                showToast('Failed to reset positions', 'error');
            }
        }

        // Delete all widgets from dashboard
        async function deleteAllWidgets() {
            if (!confirm('Delete ALL widgets from your dashboard? This action cannot be undone!')) return;
            
            try {
                // Get all widgets
                const response = await fetch('/api/dashboard/widgets');
                const data = await response.json();
                
                if (!data.widgets || data.widgets.length === 0) {
                    showToast('No widgets to delete', 'info');
                    return;
                }
                
                // Delete each widget
                let deleted = 0;
                for (const widget of data.widgets) {
                    const deleteResponse = await fetch(\`/api/dashboard/widgets/\${widget.id}\`, {
                        method: 'DELETE'
                    });
                    if (deleteResponse.ok) deleted++;
                }
                
                // Clear grid
                grid.removeAll();
                
                // Clear charts
                Object.values(widgetCharts).forEach(chart => chart.destroy());
                widgetCharts = {};
                
                // Show empty state
                document.getElementById('empty-state').style.display = 'block';
                
                showToast(\`Deleted \${deleted} widget(s)\`, 'success');
            } catch (error) {
                console.error('Failed to delete widgets:', error);
                showToast('Failed to delete widgets', 'error');
            }
        }

        // Close modal
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Initialize React Dashboard on page load
        document.addEventListener('DOMContentLoaded', () => {
            const root = ReactDOM.createRoot(document.getElementById('dashboard-root'));
            root.render(React.createElement(Dashboard));
        });
        
        // Global functions for button handlers
        window.showWidgetGallery = function() {
            document.getElementById('widgetGalleryModal').style.display = 'flex';
        };
        
        window.closeModal = function(modalId) {
            document.getElementById(modalId).style.display = 'none';
        };
        
        window.addWidget = async function(widgetType) {
            try {
                // Define smart default sizes
                let width, height;
                
                if (widgetType === 'recent_logs' || widgetType === 'top_errors') {
                    width = 6; height = 10;
                } else if (widgetType.includes('breakdown') || widgetType.includes('trend') || widgetType.includes('rate') || widgetType === 'source_stats') {
                    width = 4; height = 8;
                } else if (widgetType === 'quick_stats' || widgetType === 'system_health_detailed') {
                    width = 4; height = 6;
                } else {
                    width = 3; height = 4;
                }
                
                const response = await fetch('/api/dashboard/widgets', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        widget_type: widgetType,
                        title: getWidgetTitle(widgetType),
                        width: width,
                        height: height
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    closeModal('widgetGalleryModal');
                    showToast('Widget added successfully', 'success');
                    window.location.reload();  // Reload to refresh React
                } else {
                    showToast(data.error || 'Failed to add widget', 'error');
                }
            } catch (error) {
                console.error('Failed to add widget:', error);
                showToast('Failed to add widget', 'error');
            }
        };
        
        window.deleteWidget = async function(widgetId) {
            if (!confirm('Delete this widget?')) return;
            
            try {
                await fetch(\`/api/dashboard/widgets/\${widgetId}\`, { method: 'DELETE' });
                window.location.reload();
            } catch (error) {
                console.error('Failed to delete widget:', error);
                showToast('Failed to delete widget', 'error');
            }
        };
        
        window.resetWidgetPositions = async function() {
            if (!confirm('Reset all widget positions to default layout?')) return;
            
            try {
                await fetch('/api/dashboard/widgets/reset-positions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                window.location.reload();
            } catch (error) {
                console.error('Failed to reset positions:', error);
                showToast('Failed to reset layout', 'error');
            }
        };
        
        window.deleteAllWidgets = async function() {
            if (!confirm('Delete ALL widgets? This cannot be undone!')) return;
            
            try {
                await fetch('/api/dashboard/widgets', { method: 'DELETE' });
                window.location.reload();
            } catch (error) {
                console.error('Failed to delete widgets:', error);
                showToast('Failed to delete widgets', 'error');
            }
        };
    `;

    res.send(getPageTemplate({
        pageTitle: 'Dashboard',
        pageIcon: 'fas fa-tachometer-alt',
        activeNav: 'dashboard',
        contentBody: contentBody,
        additionalCSS: additionalCSS,
        additionalJS: additionalJS,
        req: req
    }));
});

// Logs page
app.get('/logs', requireAuth, (req, res) => {
    const additionalCSS = `
        .tab-button.active {
            color: var(--accent-primary) !important;
            border-bottom-color: var(--accent-primary) !important;
        }
        .tab-button:hover {
            color: var(--accent-primary);
            background: var(--bg-secondary);
        }
        .tab-content {
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .log-table { 
            width: 100%; 
            background: var(--bg-primary); 
            border-radius: 12px; 
            overflow: hidden; 
            box-shadow: var(--shadow-light);
            border: 1px solid var(--border-color);
        }
        .log-table th, .log-table td { 
            padding: 1rem; 
            text-align: left; 
            border-bottom: 1px solid var(--border-color); 
        }
        .log-table th { 
            background: var(--gradient-sky); 
            font-weight: 600; 
            color: var(--text-primary);
        }
        .log-table td { 
            color: var(--text-secondary); 
            transition: background-color 0.3s ease;
        }
        .log-table tr:hover td {
            background: var(--bg-secondary);
        }
        .severity-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        .severity-info { background: #3182ce; color: #ffffff; }
        .severity-warn { background: #d69e2e; color: #ffffff; }
        .severity-error { background: #e53e3e; color: #ffffff; }
        .severity-success { background: #38a169; color: #ffffff; }
    `;

    const contentBody = `
        <!-- Tab Navigation -->
        <div style="background: var(--bg-primary); border-radius: 12px; padding: 1rem; margin-bottom: 1.5rem; box-shadow: var(--shadow-light); border: 1px solid var(--border-color);">
            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                <button onclick="switchTab('logs')" id="tab-logs" class="tab-btn active" style="padding: 0.75rem 1.5rem; border: none; background: var(--gradient-ocean); color: white; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-file-alt"></i> System Logs
                </button>
                <button onclick="switchTab('analytics')" id="tab-analytics" class="tab-btn" style="padding: 0.75rem 1.5rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-chart-bar"></i> Analytics
                </button>
                <button onclick="switchTab('advanced')" id="tab-advanced" class="tab-btn" style="padding: 0.75rem 1.5rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-search-plus"></i> Advanced Logs
                </button>
            </div>
        </div>

        <!-- Logs Tab Content -->
        <div id="content-logs" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-file-alt"></i> System Logs</h3>
                    <button onclick="loadLogs()" class="btn">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                </div>
                <div class="card-body" style="padding: 0;">
                    <table class="log-table">
                        <thead>
                            <tr>
                                <th>Timestamp</th>
                                <th>Category</th>
                                <th>Source</th>
                                <th>Event Type</th>
                                <th>Message</th>
                                <th>Severity</th>
                            </tr>
                        </thead>
                        <tbody id="logs-tbody">
                            <tr><td colspan="6" style="text-align: center; padding: 2rem;">Loading logs...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Analytics Tab Content -->
        <div id="content-analytics" class="tab-content" style="display: none;">
            <!-- Date Range Filter -->
            <div style="display: flex; justify-content: flex-end; margin-bottom: 1.5rem; gap: 0.5rem;">
                <select id="analytics-date-range" onchange="loadAnalytics()" style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary);">
                    <option value="today">Today</option>
                    <option value="yesterday">Yesterday</option>
                    <option value="7days" selected>Last 7 Days</option>
                    <option value="30days">Last 30 Days</option>
                </select>
                <button onclick="loadAnalytics()" class="btn">
                    <i class="fas fa-sync-alt"></i> Refresh
                </button>
                <button onclick="exportAnalytics()" class="btn">
                    <i class="fas fa-download"></i> Export
                </button>
            </div>

            <!-- Stats Grid -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                <div class="card" style="text-align: center; padding: 1.5rem;">
                    <div style="font-size: 2rem; color: var(--accent-primary); margin-bottom: 0.5rem;">
                        <i class="fas fa-database"></i>
                    </div>
                    <div id="analytics-total-logs" style="font-size: 2rem; font-weight: 700; color: var(--text-primary);">--</div>
                    <div style="color: var(--text-muted); font-size: 0.875rem; margin-top: 0.25rem;">Total Logs</div>
                    <div id="analytics-total-trend" style="font-size: 0.75rem; margin-top: 0.5rem;"></div>
                </div>
                
                <div class="card" style="text-align: center; padding: 1.5rem;">
                    <div style="font-size: 2rem; color: #ef4444; margin-bottom: 0.5rem;">
                        <i class="fas fa-exclamation-triangle"></i>
                    </div>
                    <div id="analytics-error-logs" style="font-size: 2rem; font-weight: 700; color: var(--text-primary);">--</div>
                    <div style="color: var(--text-muted); font-size: 0.875rem; margin-top: 0.25rem;">Errors & Warnings</div>
                    <div id="analytics-error-trend" style="font-size: 0.75rem; margin-top: 0.5rem;"></div>
                </div>
                
                <div class="card" style="text-align: center; padding: 1.5rem;">
                    <div style="font-size: 2rem; color: #10b981; margin-bottom: 0.5rem;">
                        <i class="fas fa-chart-line"></i>
                    </div>
                    <div id="analytics-avg-per-hour" style="font-size: 2rem; font-weight: 700; color: var(--text-primary);">--</div>
                    <div style="color: var(--text-muted); font-size: 0.875rem; margin-top: 0.25rem;">Avg per Hour</div>
                    <div id="analytics-hourly-trend" style="font-size: 0.75rem; margin-top: 0.5rem;"></div>
                </div>
                
                <div class="card" style="text-align: center; padding: 1.5rem;">
                    <div style="font-size: 2rem; color: #f59e0b; margin-bottom: 0.5rem;">
                        <i class="fas fa-fire"></i>
                    </div>
                    <div id="analytics-peak-hour" style="font-size: 2rem; font-weight: 700; color: var(--text-primary);">--</div>
                    <div style="color: var(--text-muted); font-size: 0.875rem; margin-top: 0.25rem;">Peak Hour</div>
                    <div id="analytics-peak-count" style="font-size: 0.75rem; margin-top: 0.5rem;"></div>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 1.25rem; margin-bottom: 1.25rem;">
                <!-- Hourly Trend Chart -->
                <div class="card">
                    <div class="card-header">
                        <h3><i class="fas fa-chart-area"></i> Hourly Trend Analysis</h3>
                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem;">Events per hour with pattern detection</div>
                    </div>
                    <div style="padding: 1.5rem;">
                        <canvas id="analytics-hourly-chart" height="80"></canvas>
                    </div>
                </div>

                <!-- Top Sources -->
                <div class="card">
                    <div class="card-header">
                        <h3><i class="fas fa-server"></i> Top Sources</h3>
                    </div>
                    <div id="analytics-top-sources" style="padding: 1.5rem; max-height: 350px; overflow-y: auto;">
                        <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
                            <i class="fas fa-spinner fa-spin"></i>
                        </div>
                    </div>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.25rem;">
                <!-- Category Distribution -->
                <div class="card">
                    <div class="card-header">
                        <h3><i class="fas fa-chart-pie"></i> Category Distribution</h3>
                    </div>
                    <div style="padding: 1.5rem;">
                        <canvas id="analytics-category-chart" height="120"></canvas>
                    </div>
                </div>

                <!-- Severity Levels -->
                <div class="card">
                    <div class="card-header">
                        <h3><i class="fas fa-layer-group"></i> Severity Levels</h3>
                    </div>
                    <div style="padding: 1.5rem;">
                        <canvas id="analytics-severity-chart" height="120"></canvas>
                    </div>
                </div>
            </div>

            <!-- Pattern Detection Alerts -->
            <div class="card" style="margin-top: 1.25rem;">
                <div class="card-header">
                    <h3><i class="fas fa-brain"></i> Pattern Detection & Insights</h3>
                </div>
                <div id="analytics-patterns" style="padding: 1.5rem;">
                    <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
                        <i class="fas fa-spinner fa-spin"></i> Analyzing patterns...
                    </div>
                </div>
            </div>
        </div>

        <!-- Advanced Logs Tab Content -->
        <div id="content-advanced" class="tab-content" style="display: none;">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-search-plus"></i> Advanced Log Viewer</h3>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <input type="text" id="advanced-search" placeholder="Search logs..." autocomplete="off"
                               style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); width: 300px;"
                               oninput="filterAdvancedLogs()">
                        <select id="advanced-severity-filter" onchange="filterAdvancedLogs()"
                                style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary);">
                            <option value="">All Severities</option>
                            <option value="critical">Critical</option>
                            <option value="error">Error</option>
                            <option value="warning">Warning</option>
                            <option value="info">Info</option>
                            <option value="debug">Debug</option>
                        </select>
                        <select id="advanced-category-filter" onchange="filterAdvancedLogs()"
                                style="padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary);">
                            <option value="">All Categories</option>
                            <option value="system">System</option>
                            <option value="security">Security</option>
                            <option value="automation">Automation</option>
                            <option value="device">Device</option>
                            <option value="service">Service</option>
                        </select>
                        <button onclick="loadAdvancedLogs()" class="btn">
                            <i class="fas fa-sync-alt"></i> Refresh
                        </button>
                    </div>
                </div>
                <div class="card-body" style="padding: 0;">
                    <div id="advanced-logs-container" style="max-height: 800px; overflow-y: auto;">
                        <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
                            <i class="fas fa-spinner fa-spin"></i> Loading logs...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;

    const additionalJS = `
        <script>
        // Chart.js loading helper
        function waitForChart(callback) {
            if (typeof Chart !== 'undefined') {
                callback();
            } else {
                setTimeout(() => waitForChart(callback), 50);
            }
        }

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.style.display = 'none');
            document.querySelectorAll('.tab-btn').forEach(btn => { 
                btn.classList.remove('active'); 
                btn.style.background = 'var(--bg-secondary)'; 
                btn.style.color = 'var(--text-primary)'; 
            });
            
            document.getElementById('content-' + tabName).style.display = 'block';
            const activeBtn = document.getElementById('tab-' + tabName);
            activeBtn.classList.add('active');
            activeBtn.style.background = 'var(--gradient-ocean)';
            activeBtn.style.color = 'white';
            
            if (tabName === 'logs') {
                loadLogs();
            } else if (tabName === 'analytics') {
                refreshAnalytics();
            } else if (tabName === 'advanced') {
                loadAdvancedLogs();
            }
        }

        function refreshAnalytics() {
            loadAnalytics();
        }

        // Analytics variables
        let hourlyChart, categoryChart, severityChart;
        let allLogs = [];

        async function loadAnalytics() {
            try {
                const range = document.getElementById('analytics-date-range').value;
                
                // Fetch pre-aggregated data from new API endpoints (100x faster!)
                const statsPromise = fetch('/api/analytics/stats?range=' + range);
                const sourcesPromise = fetch('/api/analytics/top-sources?range=' + range);
                const categoriesPromise = fetch('/api/analytics/categories?range=' + range);
                const severitiesPromise = fetch('/api/analytics/severities?range=' + range);
                const activityRange = range === 'today' ? '24h' : range === '7days' ? '7d' : '7d';
                const activityPromise = fetch('/api/analytics/activity?range=' + activityRange);
                
                const [statsRes, sourcesRes, categoriesRes, severitiesRes, activityRes] = await Promise.all([
                    statsPromise, sourcesPromise, categoriesPromise, severitiesPromise, activityPromise
                ]);
                
                if (!statsRes.ok) {
                    throw new Error('Failed to fetch analytics stats');
                }
                
                const stats = await statsRes.json();
                const sources = await sourcesRes.json();
                const categories = await categoriesRes.json();
                const severities = await severitiesRes.json();
                const activity = await activityRes.json();
                
                // Update stats display
                document.getElementById('analytics-total-logs').textContent = stats.total.toLocaleString();
                document.getElementById('analytics-error-logs').textContent = stats.errors.toLocaleString();
                document.getElementById('analytics-avg-per-hour').textContent = stats.avg_per_hour.toLocaleString();
                document.getElementById('analytics-peak-hour').textContent = formatHour(stats.peak_hour);
                document.getElementById('analytics-peak-count').textContent = stats.peak_count + ' events';
                
                const errorColor = stats.error_rate > 5 ? '#ef4444' : '#10b981';
                document.getElementById('analytics-error-trend').innerHTML = 
                    '<span style="color: ' + errorColor + '">' + stats.error_rate + '% error rate</span>';
                
                // Update top sources
                if (sources.length === 0) {
                    document.getElementById('analytics-top-sources').innerHTML = 
                        '<p style="text-align: center; padding: 2rem; color: var(--text-muted);"><i class="fas fa-inbox"></i><br>No sources found</p>';
                } else {
                    const maxCount = sources[0].count;
                    let sourcesHtml = '';
                    for (let i = 0; i < sources.length; i++) {
                        const src = sources[i];
                        const percent = Math.round((src.count / maxCount) * 100);
                        sourcesHtml += '<div style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--border-color);">';
                        sourcesHtml += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">';
                        sourcesHtml += '<span style="font-weight: 600;">#' + (i + 1) + ' ' + src.source + '</span>';
                        sourcesHtml += '<span style="font-weight: 700; color: var(--accent-primary);">' + src.count + '</span>';
                        sourcesHtml += '</div>';
                        sourcesHtml += '<div style="background: var(--bg-secondary); height: 6px; border-radius: 3px; overflow: hidden;">';
                        sourcesHtml += '<div style="background: var(--gradient-ocean); height: 100%; width: ' + percent + '%;"></div>';
                        sourcesHtml += '</div></div>';
                    }
                    document.getElementById('analytics-top-sources').innerHTML = sourcesHtml;
                }
                
                // Update hourly chart
                const ctx1 = document.getElementById('analytics-hourly-chart');
                if (hourlyChart) {
                    hourlyChart.destroy();
                    hourlyChart = null;
                }
                waitForChart(() => {
                    hourlyChart = new Chart(ctx1, {
                    type: 'line',
                    data: {
                        labels: activity.labels || [],
                        datasets: [{
                            label: 'Events',
                            data: activity.values || [],
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { beginAtZero: true, grid: { color: 'rgba(0,0,0,0.05)' } },
                            x: { grid: { display: false } }
                        }
                    }
                });
                });
                
                // Update category chart
                const ctx2 = document.getElementById('analytics-category-chart');
                if (categoryChart) {
                    categoryChart.destroy();
                    categoryChart = null;
                }
                if (categories.length > 0) {
                    const catLabels = categories.map(function(c) { 
                        return c.category.charAt(0).toUpperCase() + c.category.slice(1); 
                    });
                    const catData = categories.map(function(c) { return c.count; });
                    waitForChart(() => {
                        categoryChart = new Chart(ctx2, {
                        type: 'doughnut',
                        data: {
                            labels: catLabels,
                            datasets: [{
                                data: catData,
                                backgroundColor: ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            plugins: { legend: { position: 'right' } }
                        }
                    });
                    });
                }
                
                // Update severity chart
                const ctx3 = document.getElementById('analytics-severity-chart');
                if (severityChart) {
                    severityChart.destroy();
                    severityChart = null;
                }
                if (severities.length > 0) {
                    const sevLabels = severities.map(function(s) { return s.severity.toUpperCase(); });
                    const sevData = severities.map(function(s) { return s.count; });
                    waitForChart(() => {
                        severityChart = new Chart(ctx3, {
                        type: 'bar',
                        data: {
                            labels: sevLabels,
                            datasets: [{
                                label: 'Count',
                                data: sevData,
                                backgroundColor: ['#ef4444', '#f59e0b', '#3b82f6', '#10b981']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            plugins: { legend: { display: false } },
                            scales: {
                                y: { beginAtZero: true }
                            }
                        }
                    });
                    });
                }
                
                // Generate pattern insights
                generatePatternInsights(stats, activity);
                
            } catch (error) {
                console.error('Failed to load analytics:', error);
                
                // Reset UI to error state
                document.getElementById('analytics-total-logs').textContent = '0';
                document.getElementById('analytics-error-logs').textContent = '0';
                document.getElementById('analytics-avg-per-hour').textContent = '0';
                document.getElementById('analytics-peak-hour').textContent = 'N/A';
                document.getElementById('analytics-peak-count').textContent = '0 events';
                document.getElementById('analytics-top-sources').innerHTML = 
                    '<p style="text-align: center; padding: 2rem; color: var(--text-muted);"><i class="fas fa-exclamation-triangle"></i><br>Failed to load sources</p>';
                document.getElementById('analytics-patterns').innerHTML = 
                    '<p style="text-align: center; padding: 2rem; color: var(--text-muted);"><i class="fas fa-exclamation-triangle"></i><br>Failed to analyze patterns</p>';
                
                showToast('Failed to load analytics: ' + error.message, 'error');
            }
        }

        function updateStats() {
            const total = allLogs.length;
            const errors = allLogs.filter(l => l.severity === 'error' || l.severity === 'warn' || l.severity === 'warning' || l.severity === 'critical' || l.level === 'error' || l.level === 'warn').length;
            
            // Calculate hourly average
            const range = document.getElementById('analytics-date-range').value;
            let hours = 24;
            if (range === '7days') hours = 24 * 7;
            if (range === '30days') hours = 24 * 30;
            const avgPerHour = Math.round(total / hours);
            
            // Find peak hour
            const hourlyData = getHourlyData();
            const peakHourData = hourlyData.reduce((max, curr) => curr.count > max.count ? curr : max, { count: 0, hour: 0 });
            
            document.getElementById('analytics-total-logs').textContent = total.toLocaleString();
            document.getElementById('analytics-error-logs').textContent = errors.toLocaleString();
            document.getElementById('analytics-avg-per-hour').textContent = avgPerHour.toLocaleString();
            document.getElementById('analytics-peak-hour').textContent = formatHour(peakHourData.hour);
            document.getElementById('analytics-peak-count').textContent = \`\${peakHourData.count} events\`;
            
            // Calculate trends (compare to previous period)
            const errorRate = total > 0 ? ((errors / total) * 100).toFixed(1) : 0;
            document.getElementById('analytics-error-trend').innerHTML = \`<span style="color: \${errorRate > 5 ? '#ef4444' : '#10b981'}">\${errorRate}% error rate</span>\`;
        }

        function getHourlyData() {
            const hourly = {};
            allLogs.forEach(log => {
                const date = new Date(log.timestamp);
                const hour = date.getHours();
                hourly[hour] = (hourly[hour] || 0) + 1;
            });
            
            return Array.from({ length: 24 }, (_, i) => ({
                hour: i,
                count: hourly[i] || 0
            }));
        }

        function updateCharts() {
            const hourlyData = getHourlyData();
            
            // Hourly Trend Chart
            const ctx1 = document.getElementById('analytics-hourly-chart');
            if (hourlyChart) hourlyChart.destroy();
            waitForChart(() => {
                hourlyChart = new Chart(ctx1, {
                type: 'line',
                data: {
                    labels: hourlyData.map(d => formatHour(d.hour)),
                    datasets: [{
                        label: 'Events per Hour',
                        data: hourlyData.map(d => d.count),
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, grid: { color: 'rgba(0,0,0,0.05)' } },
                        x: { grid: { display: false } }
                    }
                }
            });
            });
            
            // Category Distribution
            const categories = {};
            allLogs.forEach(log => {
                const cat = log.category || 'other';
                categories[cat] = (categories[cat] || 0) + 1;
            });
            
            const ctx2 = document.getElementById('analytics-category-chart');
            if (categoryChart) categoryChart.destroy();
            waitForChart(() => {
                categoryChart = new Chart(ctx2, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(categories).map(c => c.charAt(0).toUpperCase() + c.slice(1)),
                    datasets: [{
                        data: Object.values(categories),
                        backgroundColor: ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { position: 'right' }
                    }
                }
            });
            });
            
            // Severity Levels
            const severities = {};
            allLogs.forEach(log => {
                const sev = log.level || log.severity || 'info';
                severities[sev] = (severities[sev] || 0) + 1;
            });
            
            const ctx3 = document.getElementById('analytics-severity-chart');
            if (severityChart) severityChart.destroy();
            waitForChart(() => {
                severityChart = new Chart(ctx3, {
                type: 'bar',
                data: {
                    labels: Object.keys(severities).map(s => s.toUpperCase()),
                    datasets: [{
                        label: 'Count',
                        data: Object.values(severities),
                        backgroundColor: ['#ef4444', '#f59e0b', '#3b82f6', '#10b981']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true }
                    }
                }
            });
            });
        }

        function updateTopSources() {
            const sources = {};
            allLogs.forEach(log => {
                const src = log.source || 'unknown';
                sources[src] = (sources[src] || 0) + 1;
            });
            
            const sorted = Object.entries(sources)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const html = sorted.map(([source, count], i) => \`
                <div style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--border-color);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <span style="font-weight: 600;">#\${i + 1} \${source}</span>
                        <span style="font-weight: 700; color: var(--accent-primary);">\${count}</span>
                    </div>
                    <div style="background: var(--bg-secondary); height: 6px; border-radius: 3px; overflow: hidden;">
                        <div style="background: var(--gradient-ocean); height: 100%; width: \${(count / sorted[0][1]) * 100}%;"></div>
                    </div>
                </div>
            \`).join('');
            
            document.getElementById('analytics-top-sources').innerHTML = html || '<p style="text-align: center; color: var(--text-muted);">No data</p>';
        }

        function generatePatternInsights(stats, activity) {
            const patterns = [];
            
            // Detect spikes (> 2x average)
            if (activity.values && activity.values.length > 0) {
                const values = activity.values;
                const avg = values.reduce(function(sum, v) { return sum + v; }, 0) / values.length;
                const maxValue = Math.max.apply(null, values);
                
                if (maxValue > avg * 2 && avg > 0) {
                    const spikeIndex = values.indexOf(maxValue);
                    const spikeLabel = activity.labels ? activity.labels[spikeIndex] : 'Unknown';
                    patterns.push({
                        type: 'spike',
                        severity: 'warning',
                        message: 'üî• Activity spike detected at ' + spikeLabel,
                        detail: 'Volume exceeded average by ' + Math.round((maxValue / avg - 1) * 100) + '%'
                    });
                }
                
                // Detect unusual quiet periods
                const quietThreshold = avg * 0.3;
                const quiet = values.filter(function(v) { return v < quietThreshold && v > 0; });
                if (quiet.length >= 3 && avg > 0) {
                    patterns.push({
                        type: 'quiet',
                        severity: 'info',
                        message: 'üò¥ Unusual quiet periods detected',
                        detail: quiet.length + ' periods with significantly reduced activity'
                    });
                }
            }
            
            // Detect error rate anomalies
            const errorRate = parseFloat(stats.error_rate) || 0;
            if (errorRate > 10) {
                patterns.push({
                    type: 'errors',
                    severity: 'error',
                    message: '‚ö†Ô∏è High error rate detected: ' + errorRate.toFixed(1) + '%',
                    detail: stats.errors + ' errors/warnings out of ' + stats.total + ' total events'
                });
            } else if (errorRate > 5) {
                patterns.push({
                    type: 'errors',
                    severity: 'warning',
                    message: '‚ö° Elevated error rate: ' + errorRate.toFixed(1) + '%',
                    detail: 'Monitor for potential issues'
                });
            } else {
                patterns.push({
                    type: 'healthy',
                    severity: 'success',
                    message: '‚úÖ System health looks good',
                    detail: 'Error rate: ' + errorRate.toFixed(1) + '% (within normal range)'
                });
            }
            
            const colors = {
                error: '#ef4444',
                warning: '#f59e0b',
                info: '#3b82f6',
                success: '#10b981'
            };
            
            let html = '';
            for (let i = 0; i < patterns.length; i++) {
                const p = patterns[i];
                html += '<div style="padding: 1rem; background: ' + colors[p.severity] + '15; border-left: 4px solid ' + colors[p.severity] + '; border-radius: 6px; margin-bottom: 1rem;">';
                html += '<div style="font-weight: 600; margin-bottom: 0.5rem;">' + p.message + '</div>';
                html += '<div style="font-size: 0.875rem; color: var(--text-muted);">' + p.detail + '</div>';
                html += '</div>';
            }
            
            document.getElementById('analytics-patterns').innerHTML = html;
        }

        function formatHour(hour) {
            const hourStr = hour.toString();
            const padded = hourStr.length === 1 ? '0' + hourStr : hourStr;
            return padded + ':00';
        }

        function exportAnalytics() {
            const range = document.getElementById('analytics-date-range').value;
            const csv = 'Timestamp,Level,Category,Source,Message\\n' +
                allLogs.map(l => \`"\${l.timestamp}","\${l.level || l.severity || 'info'}","\${l.category || ''}","\${l.source || ''}","\${l.message}"\`).join('\\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = \`analytics-\${range}-\${new Date().toISOString().split('T')[0]}.csv\`;
            a.click();
        }

        // Advanced Logs functionality
        let advancedLogsData = [];
        let filteredAdvancedLogs = [];

        async function loadAdvancedLogs() {
            try {
                const container = document.getElementById('advanced-logs-container');
                container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);"><i class="fas fa-spinner fa-spin"></i> Loading logs...</div>';
                
                const response = await fetch('/api/logs?limit=200');
                if (!response.ok) {
                    throw new Error('HTTP error! status: ' + response.status);
                }
                
                advancedLogsData = await response.json();
                filteredAdvancedLogs = advancedLogsData;
                renderAdvancedLogs();
            } catch (error) {
                console.error('Error loading advanced logs:', error);
                document.getElementById('advanced-logs-container').innerHTML = 
                    '<div style="text-align: center; padding: 2rem; color: #ef4444;"><i class="fas fa-exclamation-triangle"></i> Failed to load logs: ' + error.message + '</div>';
            }
        }

        function filterAdvancedLogs() {
            const searchText = document.getElementById('advanced-search').value.toLowerCase();
            const severityFilter = document.getElementById('advanced-severity-filter').value;
            const categoryFilter = document.getElementById('advanced-category-filter').value;

            filteredAdvancedLogs = advancedLogsData.filter(log => {
                const matchesSearch = !searchText || 
                    (log.message && log.message.toLowerCase().includes(searchText)) ||
                    (log.source && log.source.toLowerCase().includes(searchText)) ||
                    (log.device_id && log.device_id.toLowerCase().includes(searchText)) ||
                    (log.entity_id && log.entity_id.toLowerCase().includes(searchText));
                
                const matchesSeverity = !severityFilter || log.severity === severityFilter;
                const matchesCategory = !categoryFilter || log.category === categoryFilter;

                return matchesSearch && matchesSeverity && matchesCategory;
            });

            renderAdvancedLogs();
        }

        function renderAdvancedLogs() {
            const container = document.getElementById('advanced-logs-container');
            
            if (!filteredAdvancedLogs || filteredAdvancedLogs.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--text-muted);"><i class="fas fa-inbox" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5;"></i><p style="font-size: 1.1rem; margin: 0;">No logs match your filters</p></div>';
                return;
            }

            container.innerHTML = filteredAdvancedLogs.map((log, index) => {
                const severityClass = 'severity-' + (log.severity || 'info');
                const logId = 'log-' + (log.id || index);
                
                // Parse metadata if it's a string
                let metadata = {};
                try {
                    if (typeof log.metadata === 'string') {
                        metadata = JSON.parse(log.metadata);
                    } else if (log.metadata) {
                        metadata = log.metadata;
                    }
                } catch (e) {
                    metadata = { raw: log.metadata };
                }

                // Collect all additional data
                const detailsData = {
                    id: log.id,
                    timestamp: log.timestamp,
                    severity: log.severity,
                    category: log.category,
                    source: log.source,
                    event_type: log.event_type,
                    message: log.message,
                    device_id: log.device_id,
                    entity_id: log.entity_id,
                    metadata: metadata,
                    service_data: log.service_data
                };

                return \`
                    <div class="advanced-log-entry" style="border-bottom: 1px solid var(--border-color); transition: background 0.2s ease;">
                        <div onclick="toggleLogDetails('\${logId}')" style="padding: 1rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center; hover: background-color: var(--bg-hover);"
                             onmouseover="this.style.background='var(--bg-hover)'" onmouseout="this.style.background='transparent'">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                                    <span class="severity-badge \${severityClass}" style="font-size: 0.75rem;">\${log.severity || 'info'}</span>
                                    <span style="color: var(--text-muted); font-size: 0.875rem;">\${new Date(log.timestamp).toLocaleString()}</span>
                                    <span style="color: var(--accent-secondary); font-weight: 600; font-size: 0.875rem;">\${log.category || 'N/A'}</span>
                                    <span style="color: var(--text-muted); font-size: 0.875rem;">\${log.source || 'N/A'}</span>
                                </div>
                                <div style="color: var(--text-primary); font-size: 0.95rem;">\${log.message || 'N/A'}</div>
                                \${log.device_id ? '<div style="color: var(--text-muted); font-size: 0.875rem; margin-top: 0.25rem;"><i class="fas fa-microchip"></i> ' + log.device_id + '</div>' : ''}
                            </div>
                            <i id="\${logId}-icon" class="fas fa-chevron-down" style="color: var(--text-muted); transition: transform 0.3s ease;"></i>
                        </div>
                        <div id="\${logId}-details" style="display: none; padding: 0 1rem 1rem 1rem; background: var(--bg-secondary); border-top: 1px solid var(--border-color);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                <h4 style="margin: 0.5rem 0; color: var(--text-primary);"><i class="fas fa-info-circle"></i> Log Details</h4>
                                <button onclick="copyLogDetails('\${logId}')" class="btn" style="padding: 0.4rem 0.8rem; font-size: 0.875rem;">
                                    <i class="fas fa-copy"></i> Copy JSON
                                </button>
                            </div>
                            <pre id="\${logId}-json" style="background: var(--bg-primary); padding: 1rem; border-radius: 6px; overflow-x: auto; margin: 0; font-size: 0.875rem; line-height: 1.5; color: var(--text-primary);"><code>\${JSON.stringify(detailsData, null, 2)}</code></pre>
                        </div>
                    </div>
                \`;
            }).join('');
        }

        function toggleLogDetails(logId) {
            const details = document.getElementById(logId + '-details');
            const icon = document.getElementById(logId + '-icon');
            
            if (details.style.display === 'none') {
                details.style.display = 'block';
                icon.style.transform = 'rotate(180deg)';
            } else {
                details.style.display = 'none';
                icon.style.transform = 'rotate(0deg)';
            }
        }

        function copyLogDetails(logId) {
            const jsonElement = document.getElementById(logId + '-json');
            const text = jsonElement.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                // Show temporary success message
                const btn = event.target.closest('button');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                btn.style.background = '#10b981';
                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.style.background = '';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            });
        }


        async function loadLogs() {
            try {
                const response = await fetch('/api/logs?limit=50');
                if (!response.ok) {
                    throw new Error('HTTP error! status: ' + response.status);
                }
                const logs = await response.json();
                console.log('Loaded logs:', logs);
                const tbody = document.getElementById('logs-tbody');
                
                if (!logs || !Array.isArray(logs) || logs.length === 0) {
                    tbody.innerHTML = \`
                        <tr><td colspan="6" style="text-align: center; padding: 3rem;">
                            <div style="color: var(--text-muted);">
                                <i class="fas fa-inbox" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                                <p style="font-size: 1.1rem; margin: 0;">No logs found</p>
                                <p style="font-size: 0.9rem; margin-top: 0.5rem;">Create a test event on the Dashboard to see logs appear here.</p>
                            </div>
                        </td></tr>
                    \`;
                    return;
                }
                
                tbody.innerHTML = logs.map(log => {
                    const severityClass = 'severity-' + (log.severity || 'info');
                    return \`
                        <tr>
                            <td>\${new Date(log.timestamp).toLocaleString()}</td>
                            <td>\${log.category || 'N/A'}</td>
                            <td>\${log.source || 'N/A'}</td>
                            <td>\${log.event_type || 'N/A'}</td>
                            <td>\${log.message || 'N/A'}</td>
                            <td><span class="severity-badge \${severityClass}">\${log.severity || 'info'}</span></td>
                        </tr>
                    \`;
                }).join('');
            } catch (error) {
                console.error('Error loading logs:', error);
                document.getElementById('logs-tbody').innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 2rem; color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i> Failed to load logs: ' + error.message + '</td></tr>';
            }
        }
        
        // Auto-load logs
        loadLogs();
        setInterval(loadLogs, 30000); // Refresh every 30 seconds
        </script>
    `;

    res.send(getPageTemplate({
        pageTitle: 'Log Viewer',
        pageIcon: 'fas fa-file-alt',
        activeNav: 'logs',
        contentBody: contentBody,
        additionalCSS: additionalCSS,
        additionalJS: additionalJS,
        req: req
    }));
});

// ================================================================================
// ADVANCED ANALYTICS PAGE - Histograms, Heatmaps, Anomalies
// ================================================================================
app.get('/analytics-advanced', requireAuth, (req, res) => {
    const additionalCSS = `
        <style>
            .analytics-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
                gap: 2rem;
                margin-bottom: 2rem;
            }
            
            .analytics-card {
                background: var(--bg-primary);
                border-radius: 12px;
                padding: 1.5rem;
                box-shadow: var(--shadow-light);
                border: 1px solid var(--border-color);
            }
            
            .analytics-card h3 {
                margin-top: 0;
                color: var(--text-primary);
                font-size: 1.2rem;
                margin-bottom: 1rem;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }
            
            .analytics-card h3 i {
                background: var(--gradient-ocean);
                color: white;
                width: 32px;
                height: 32px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 8px;
                font-size: 0.9rem;
            }
            
            .chart-container {
                position: relative;
                height: 350px;
                margin-top: 1rem;
            }
            
            .chart-container.heatmap {
                height: 400px;
            }
            
            .filters-bar {
                background: var(--bg-secondary);
                border-radius: 12px;
                padding: 1.5rem;
                margin-bottom: 2rem;
                display: flex;
                gap: 1rem;
                flex-wrap: wrap;
                align-items: center;
                box-shadow: var(--shadow-light);
            }
            
            .filter-group {
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
                flex: 1;
                min-width: 150px;
            }
            
            .filter-group label {
                color: var(--text-secondary);
                font-size: 0.9rem;
                font-weight: 500;
            }
            
            .filter-group select {
                padding: 0.6rem;
                border-radius: 8px;
                border: 1px solid var(--border-color);
                background: var(--bg-primary);
                color: var(--text-primary);
                font-size: 0.95rem;
                cursor: pointer;
                transition: border-color 0.2s;
            }
            
            .filter-group select:hover {
                border-color: var(--accent-primary);
            }
            
            .filter-actions {
                display: flex;
                gap: 0.5rem;
                align-items: flex-end;
            }
            
            .anomalies-section {
                margin-top: 2rem;
            }
            
            .anomalies-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 1rem;
                margin-top: 1rem;
            }
            
            .anomaly-card {
                background: var(--bg-secondary);
                border-radius: 8px;
                padding: 1rem;
                border-left: 4px solid var(--warning-color);
            }
            
            .anomaly-card.critical {
                border-left-color: var(--error-color);
            }
            
            .anomaly-time {
                font-weight: 600;
                color: var(--text-primary);
                margin-bottom: 0.5rem;
            }
            
            .anomaly-stats {
                display: flex;
                gap: 1rem;
                font-size: 0.9rem;
                color: var(--text-secondary);
            }
            
            .anomaly-deviation {
                color: var(--warning-color);
                font-weight: 600;
            }
            
            .anomaly-card.critical .anomaly-deviation {
                color: var(--error-color);
            }
            
            .stats-summary {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 1rem;
                margin-top: 1rem;
            }
            
            .stat-item {
                background: var(--bg-tertiary);
                padding: 1rem;
                border-radius: 8px;
                text-align: center;
            }
            
            .stat-value {
                font-size: 1.8rem;
                font-weight: 700;
                color: var(--accent-primary);
                margin-bottom: 0.25rem;
            }
            
            .stat-label {
                font-size: 0.85rem;
                color: var(--text-secondary);
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .loading-overlay {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.05);
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 8px;
                z-index: 10;
            }
            
            .no-data-message {
                text-align: center;
                padding: 2rem;
                color: var(--text-muted);
                font-style: italic;
            }
        </style>
    `;

    const contentBody = `
        <div class="filters-bar">
            <div class="filter-group">
                <label for="timeRange">Time Range</label>
                <select id="timeRange">
                    <option value="today">Today</option>
                    <option value="7days" selected>Last 7 Days</option>
                    <option value="30days">Last 30 Days</option>
                    <option value="90days">Last 90 Days</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="categoryFilter">Category</label>
                <select id="categoryFilter">
                    <option value="">All Categories</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="severityFilter">Severity</label>
                <select id="severityFilter">
                    <option value="">All Severities</option>
                    <option value="debug">Debug</option>
                    <option value="info">Info</option>
                    <option value="warn">Warning</option>
                    <option value="error">Error</option>
                    <option value="critical">Critical</option>
                </select>
            </div>
            <div class="filter-actions">
                <button class="btn btn-primary" onclick="loadAllCharts()">
                    <i class="fas fa-sync-alt"></i> Refresh
                </button>
            </div>
        </div>

        <div class="analytics-grid">
            <div class="analytics-card">
                <h3><i class="fas fa-clock"></i> Hourly Distribution</h3>
                <div class="chart-container">
                    <canvas id="hourly-chart"></canvas>
                </div>
                <div class="stats-summary" id="hourly-stats"></div>
            </div>

            <div class="analytics-card">
                <h3><i class="fas fa-calendar-week"></i> Daily Distribution</h3>
                <div class="chart-container">
                    <canvas id="daily-chart"></canvas>
                </div>
                <div class="stats-summary" id="daily-stats"></div>
            </div>

            <div class="analytics-card" style="grid-column: 1 / -1;">
                <h3><i class="fas fa-th"></i> Time √ó Severity Heatmap</h3>
                <div class="chart-container heatmap">
                    <canvas id="heatmap-chart"></canvas>
                </div>
            </div>

            <div class="analytics-card" style="grid-column: 1 / -1;">
                <h3><i class="fas fa-list-ol"></i> Top Message Patterns</h3>
                <div class="chart-container">
                    <canvas id="messages-chart"></canvas>
                </div>
                <div class="stats-summary" id="messages-stats"></div>
            </div>
        </div>

        <div class="anomalies-section">
            <div class="analytics-card">
                <h3><i class="fas fa-exclamation-triangle"></i> Detected Anomalies</h3>
                <div id="anomalies-container">
                    <div class="loading-overlay">
                        <i class="fas fa-spinner fa-spin fa-2x"></i>
                    </div>
                </div>
            </div>
        </div>
    `;

    const additionalJS = `
        <script>
            // Chart.js loading helper
            function waitForChart(callback) {
                if (typeof Chart !== 'undefined') {
                    callback();
                } else {
                    setTimeout(() => waitForChart(callback), 50);
                }
            }

            let hourlyChart, dailyChart, heatmapChart, messagesChart;

            // Chart color scheme matching Ocean Blue theme
            const chartColors = {
                primary: '#3b82f6',
                success: '#10b981',
                warning: '#f59e0b',
                error: '#ef4444',
                info: '#06b6d4',
                debug: '#6366f1',
                critical: '#dc2626'
            };

            // Load categories for filter
            async function loadCategories() {
                try {
                    const response = await fetch('/api/analytics/categories?range=90days');
                    const data = await response.json();
                    const select = document.getElementById('categoryFilter');
                    data.categories.forEach(cat => {
                        const option = document.createElement('option');
                        option.value = cat.category;
                        option.textContent = cat.category + ' (' + cat.count + ')';
                        select.appendChild(option);
                    });
                } catch (error) {
                    console.error('Error loading categories:', error);
                }
            }

            // Build query params from filters
            function getFilterParams() {
                const params = new URLSearchParams();
                const timeRange = document.getElementById('timeRange').value;
                const category = document.getElementById('categoryFilter').value;
                const severity = document.getElementById('severityFilter').value;
                
                params.set('range', timeRange);
                if (category) params.set('category', category);
                if (severity) params.set('severity', severity);
                
                return params.toString();
            }

            // Load hourly distribution chart
            async function loadHourlyChart() {
                try {
                    const response = await fetch('/api/analytics/histogram/hourly?' + getFilterParams());
                    const data = await response.json();

                    const ctx = document.getElementById('hourly-chart').getContext('2d');
                    
                    if (hourlyChart) hourlyChart.destroy();
                    
                    waitForChart(() => {
                        hourlyChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: data.hours.map(h => h.hour + ':00'),
                            datasets: [{
                                label: 'Events',
                                data: data.hours.map(h => h.count),
                                backgroundColor: chartColors.primary,
                                borderColor: chartColors.primary,
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            onClick: (evt, elements) => {
                                if (elements.length > 0) {
                                    const hour = elements[0].index;
                                    window.location.href = '/logs?hour=' + hour;
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: (context) => 'Events: ' + context.parsed.y.toLocaleString()
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    grid: { color: 'rgba(0,0,0,0.05)' },
                                    ticks: { color: 'var(--text-secondary)' }
                                },
                                x: {
                                    grid: { display: false },
                                    ticks: { color: 'var(--text-secondary)' }
                                }
                            }
                        }
                    });
                    });

                    // Update stats
                    const statsDiv = document.getElementById('hourly-stats');
                    statsDiv.innerHTML = \`
                        <div class="stat-item">
                            <div class="stat-value">\${data.stats.total.toLocaleString()}</div>
                            <div class="stat-label">Total Events</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">\${data.stats.avg.toFixed(0)}</div>
                            <div class="stat-label">Avg per Hour</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">\${data.stats.peak_hour}:00</div>
                            <div class="stat-label">Peak Hour</div>
                        </div>
                    \`;
                } catch (error) {
                    console.error('Error loading hourly chart:', error);
                }
            }

            // Load daily distribution chart
            async function loadDailyChart() {
                try {
                    const response = await fetch('/api/analytics/histogram/daily?' + getFilterParams());
                    const data = await response.json();

                    const ctx = document.getElementById('daily-chart').getContext('2d');
                    
                    if (dailyChart) dailyChart.destroy();
                    
                    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                    
                    dailyChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: data.days.map(d => days[d.day_of_week]),
                            datasets: [{
                                label: 'Events',
                                data: data.days.map(d => d.count),
                                backgroundColor: chartColors.success,
                                borderColor: chartColors.success,
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: (context) => 'Events: ' + context.parsed.y.toLocaleString()
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    grid: { color: 'rgba(0,0,0,0.05)' },
                                    ticks: { color: 'var(--text-secondary)' }
                                },
                                x: {
                                    grid: { display: false },
                                    ticks: { color: 'var(--text-secondary)' }
                                }
                            }
                        }
                    });

                    // Update stats
                    const statsDiv = document.getElementById('daily-stats');
                    statsDiv.innerHTML = \`
                        <div class="stat-item">
                            <div class="stat-value">\${data.stats.total.toLocaleString()}</div>
                            <div class="stat-label">Total Events</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">\${data.stats.avg_per_day.toFixed(0)}</div>
                            <div class="stat-label">Avg per Day</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">\${days[data.stats.peak_day]}</div>
                            <div class="stat-label">Peak Day</div>
                        </div>
                    \`;
                } catch (error) {
                    console.error('Error loading daily chart:', error);
                }
            }

            // Load heatmap chart
            async function loadHeatmapChart() {
                try {
                    const response = await fetch('/api/analytics/heatmap/severity-time?' + getFilterParams());
                    const data = await response.json();

                    const ctx = document.getElementById('heatmap-chart').getContext('2d');
                    
                    if (heatmapChart) heatmapChart.destroy();

                    const severities = ['debug', 'info', 'warn', 'error', 'critical'];
                    const severityColors = {
                        'debug': chartColors.debug,
                        'info': chartColors.info,
                        'warn': chartColors.warning,
                        'error': chartColors.error,
                        'critical': chartColors.critical
                    };
                    
                    heatmapChart = new Chart(ctx, {
                        type: 'matrix',
                        data: {
                            datasets: [{
                                label: 'Event Count',
                                data: data.chart_data,
                                backgroundColor: (context) => {
                                    const value = context.dataset.data[context.dataIndex].v;
                                    const severity = severities[context.dataset.data[context.dataIndex].y];
                                    const alpha = Math.min(value / (data.max_count * 0.5), 1);
                                    const color = severityColors[severity];
                                    return color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                                },
                                borderWidth: 1,
                                borderColor: 'rgba(0,0,0,0.1)',
                                width: ({chart}) => (chart.chartArea || {}).width / 24 - 1,
                                height: ({chart}) => (chart.chartArea || {}).height / 5 - 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            onClick: (evt, elements) => {
                                if (elements.length > 0) {
                                    const dataPoint = heatmapChart.data.datasets[0].data[elements[0].index];
                                    const hour = dataPoint.x;
                                    const severity = severities[dataPoint.y];
                                    window.location.href = '/logs?hour=' + hour + '&severity=' + severity;
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        title: (items) => {
                                            const item = items[0];
                                            const hour = item.raw.x;
                                            const severity = severities[item.raw.y];
                                            return hour + ':00 - ' + severity.toUpperCase();
                                        },
                                        label: (context) => 'Events: ' + context.raw.v.toLocaleString()
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    type: 'linear',
                                    offset: true,
                                    min: -0.5,
                                    max: 23.5,
                                    ticks: {
                                        stepSize: 1,
                                        callback: (value) => value + ':00',
                                        color: 'var(--text-secondary)'
                                    },
                                    grid: { display: false }
                                },
                                y: {
                                    type: 'linear',
                                    offset: true,
                                    min: -0.5,
                                    max: 4.5,
                                    ticks: {
                                        stepSize: 1,
                                        callback: (value) => severities[value]?.toUpperCase() || '',
                                        color: 'var(--text-secondary)'
                                    },
                                    grid: { display: false }
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('Error loading heatmap:', error);
                }
            }

            // Load message patterns chart
            async function loadMessagesChart() {
                try {
                    const response = await fetch('/api/analytics/histogram/messages?' + getFilterParams());
                    const data = await response.json();

                    const ctx = document.getElementById('messages-chart').getContext('2d');
                    
                    if (messagesChart) messagesChart.destroy();
                    
                    messagesChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: data.messages.map(m => m.message),
                            datasets: [{
                                label: 'Occurrences',
                                data: data.messages.map(m => m.count),
                                backgroundColor: chartColors.warning,
                                borderColor: chartColors.warning,
                                borderWidth: 1
                            }]
                        },
                        options: {
                            indexAxis: 'y',
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: (context) => 'Count: ' + context.parsed.x.toLocaleString()
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    grid: { color: 'rgba(0,0,0,0.05)' },
                                    ticks: { color: 'var(--text-secondary)' }
                                },
                                y: {
                                    grid: { display: false },
                                    ticks: { 
                                        color: 'var(--text-secondary)',
                                        autoSkip: false
                                    }
                                }
                            }
                        }
                    });

                    // Update stats
                    const statsDiv = document.getElementById('messages-stats');
                    statsDiv.innerHTML = \`
                        <div class="stat-item">
                            <div class="stat-value">\${data.stats.total.toLocaleString()}</div>
                            <div class="stat-label">Total Messages</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">\${data.stats.unique}</div>
                            <div class="stat-label">Unique Patterns</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">\${data.stats.top_message_percent.toFixed(1)}%</div>
                            <div class="stat-label">Top Pattern</div>
                        </div>
                    \`;
                } catch (error) {
                    console.error('Error loading messages chart:', error);
                }
            }

            // Load anomalies
            async function loadAnomalies() {
                try {
                    const response = await fetch('/api/analytics/anomalies?' + getFilterParams());
                    const data = await response.json();

                    const container = document.getElementById('anomalies-container');
                    
                    if (data.anomalies.length === 0) {
                        container.innerHTML = '<div class="no-data-message">No anomalies detected in this time range.</div>';
                        return;
                    }

                    container.innerHTML = '<div class="anomalies-grid">' + data.anomalies.map(anomaly => \`
                        <div class="anomaly-card \${anomaly.severity}">
                            <div class="anomaly-time">\${anomaly.formatted_time}</div>
                            <div class="anomaly-stats">
                                <span>Events: <strong>\${anomaly.count}</strong></span>
                                <span class="anomaly-deviation">+\${anomaly.deviation_percent}%</span>
                            </div>
                        </div>
                    \`).join('') + '</div>';
                } catch (error) {
                    console.error('Error loading anomalies:', error);
                    document.getElementById('anomalies-container').innerHTML = 
                        '<div class="no-data-message">Error loading anomalies.</div>';
                }
            }

            // Load all charts
            async function loadAllCharts() {
                await Promise.all([
                    loadHourlyChart(),
                    loadDailyChart(),
                    loadHeatmapChart(),
                    loadMessagesChart(),
                    loadAnomalies()
                ]);
            }

            // Initialize on page load
            document.addEventListener('DOMContentLoaded', () => {
                loadCategories();
                loadAllCharts();
                
                // Add change listeners to filters
                document.getElementById('timeRange').addEventListener('change', loadAllCharts);
                document.getElementById('categoryFilter').addEventListener('change', loadAllCharts);
                document.getElementById('severityFilter').addEventListener('change', loadAllCharts);
            });
        </script>
    `;

    res.send(getPageTemplate({
        pageTitle: 'Advanced Analytics',
        pageIcon: 'fas fa-chart-line',
        activeNav: 'analytics-advanced',
        contentBody: contentBody,
        additionalCSS: additionalCSS,
        additionalJS: additionalJS,
        req: req
    }));
});

// Admin Users page
app.get('/admin/users', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).send(getPageTemplate({
            pageTitle: 'Access Denied',
            pageIcon: 'fas fa-ban',
            activeNav: '',
            contentBody: '<div class="card"><div class="card-body"><h2 style="color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i> Access Denied</h2><p>Admin privileges required to access this page.</p><a href="/dashboard" class="btn"><i class="fas fa-arrow-left"></i> Return to Dashboard</a></div></div>',
            additionalCSS: '',
            additionalJS: '',
            req: req
        }));
    }
    
    const additionalCSS = `
        .tab-button.active {
            color: var(--accent-primary) !important;
            border-bottom-color: var(--accent-primary) !important;
        }
        .tab-button:hover {
            color: var(--accent-primary);
            background: var(--bg-secondary);
        }
        .tab-content {
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .user-table {
            width: 100%;
            border-collapse: collapse;
        }
        .user-table th,
        .user-table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        .user-table th {
            background: var(--gradient-sky);
            color: var(--text-primary);
            font-weight: 600;
        }
        .user-table tr:hover td {
            background: var(--bg-secondary);
        }
        .role-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        .role-admin { background: #e53e3e; color: #ffffff; }
        .role-user { background: #3182ce; color: #ffffff; }
        .status-active { background: #38a169; color: #ffffff; }
        .status-inactive { background: #e53e3e; color: #ffffff; }
        .modal {
            display: none !important;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.active {
            display: flex !important;
        }
        .modal-content {
            background: var(--bg-primary);
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow-medium);
            max-height: 90vh;
            overflow-y: auto;
        }
        
        /* Responsive breakpoints for user modals */
        @media (max-width: 640px) {
            .modal-content {
                width: 95%;
                max-width: 95%;
                padding: 1.5rem;
                max-height: 95vh;
                border-radius: 8px;
            }
        }
        
        @media (min-width: 641px) and (max-width: 1024px) {
            .modal-content {
                width: 80%;
                max-width: 600px;
            }
        }
        
        @media (min-width: 1025px) {
            .modal-content {
                width: 70%;
                max-width: 700px;
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .modal-header h2,
        .modal-header h3 {
            margin: 0;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .close-btn {
            background: var(--bg-secondary);
            border: 1px solid rgba(255, 255, 255, 0.08);
            font-size: 1.25rem;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        .close-btn:hover {
            background: var(--error-color);
            color: white;
            border-color: var(--error-color);
            transform: rotate(90deg);
        }
        .form-group {
            margin-bottom: 1.5rem;
        }
        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-primary);
        }
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 1rem;
        }
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        .form-group small {
            display: block;
            margin-top: 0.25rem;
            color: var(--text-muted);
            font-size: 0.875rem;
        }
        .btn-group {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        /* Use universal button styles - no overrides needed */
        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }
    `;

    const contentBody = `
        <!-- Tab Navigation -->
        <div style="background: var(--bg-primary); border-radius: 12px; padding: 1rem; margin-bottom: 1.5rem; box-shadow: var(--shadow-light); border: 1px solid var(--border-color);">
            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                <button onclick="switchTab('users')" id="tab-users" class="tab-btn active" style="padding: 0.75rem 1.5rem; border: none; background: var(--gradient-ocean); color: white; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-users"></i> Users
                </button>
                <button onclick="switchTab('sessions')" id="tab-sessions" class="tab-btn" style="padding: 0.75rem 1.5rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-user-clock"></i> Sessions
                </button>
            </div>
        </div>

        <!-- Users Tab Content -->
        <div id="content-users" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-users"></i> User Management</h3>
                    <button onclick="showAddUserModal()" class="btn">
                        <i class="fas fa-user-plus"></i> Add User
                    </button>
                </div>
                <div class="card-body" style="padding: 0; overflow-x: auto;">
                    <table class="user-table">
                        <thead>
                            <tr>
                                <th>Username</th>
                                <th>Email</th>
                                <th>Role</th>
                                <th>Status</th>
                                <th>Created</th>
                                <th>Last Login</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="users-tbody">
                            <tr><td colspan="7" style="text-align: center; padding: 2rem;">Loading users...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Sessions Tab Content -->
        <div id="content-sessions" class="tab-content" style="display: none;">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-user-clock"></i> Active Sessions</h3>
                    <button onclick="refreshSessions()" class="btn">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                </div>
                <div class="card-body" style="padding: 0; overflow-x: auto;">
                    <table class="user-table">
                        <thead>
                            <tr>
                                <th>Username</th>
                                <th>IP Address</th>
                                <th>User Agent</th>
                                <th>Login Time</th>
                                <th>Last Activity</th>
                                <th>Duration</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="sessions-tbody">
                            <tr><td colspan="7" style="text-align: center; padding: 2rem;">Loading sessions...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Add User Modal -->
        <div id="addUserModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2><i class="fas fa-user-plus"></i> Add New User</h2>
                    <button onclick="hideAddUserModal()" class="close-btn">&times;</button>
                </div>
                <form id="addUserForm">
                    <div class="form-group">
                        <label for="newUsername">Username *</label>
                        <input type="text" id="newUsername" name="username" autocomplete="username" required minlength="3">
                        <small>Minimum 3 characters</small>
                    </div>
                    <div class="form-group">
                        <label for="newEmail">Email</label>
                        <input type="email" id="newEmail" name="email" autocomplete="email">
                    </div>
                    <div class="form-group">
                        <label for="newPassword">Password *</label>
                        <input type="password" id="newPassword" name="password" autocomplete="new-password" required minlength="8">
                        <small>Minimum 8 characters</small>
                    </div>
                    <div class="form-group">
                        <label for="newRole">Role *</label>
                        <select id="newRole" name="role" required>
                            <option value="user">Standard User (View Only)</option>
                            <option value="admin">Administrator (Full Access)</option>
                        </select>
                    </div>
                    <div class="btn-group">
                        <button type="button" onclick="hideAddUserModal()" class="btn btn-secondary">Cancel</button>
                        <button type="submit" class="btn"><i class="fas fa-save"></i> Create User</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Edit User Modal -->
        <div id="editUserModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2><i class="fas fa-user-edit"></i> Edit User</h2>
                    <button onclick="hideEditUserModal()" class="close-btn">&times;</button>
                </div>
                <form id="editUserForm">
                    <input type="hidden" id="editUserId" name="userId">
                    <div class="form-group">
                        <label for="editUsername">Username</label>
                        <input type="text" id="editUsername" name="username" autocomplete="username" readonly style="opacity: 0.7; cursor: not-allowed;">
                        <small>Username cannot be changed</small>
                    </div>
                    <div class="form-group">
                        <label for="editEmail">Email</label>
                        <input type="email" id="editEmail" name="email" autocomplete="email">
                    </div>
                    <div class="form-group">
                        <label for="editPassword">New Password</label>
                        <input type="password" id="editPassword" name="password" autocomplete="new-password" minlength="8">
                        <small>Leave empty to keep current password</small>
                    </div>
                    <div class="form-group">
                        <label for="editRole">Role *</label>
                        <select id="editRole" name="role" required>
                            <option value="user">Standard User (View Only)</option>
                            <option value="admin">Administrator (Full Access)</option>
                        </select>
                    </div>
                    <div class="btn-group">
                        <button type="button" onclick="hideEditUserModal()" class="btn btn-secondary">Cancel</button>
                        <button type="submit" class="btn"><i class="fas fa-save"></i> Update User</button>
                    </div>
                </form>
            </div>
        </div>
    `;

    const additionalJS = `
        let allUsers = [];
        let allSessions = [];

        // Tab switching
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => tab.style.display = 'none');
            document.querySelectorAll('.tab-btn').forEach(btn => { 
                btn.classList.remove('active'); 
                btn.style.background = 'var(--bg-secondary)'; 
                btn.style.color = 'var(--text-primary)'; 
            });
            
            // Show selected tab
            document.getElementById('content-' + tabName).style.display = 'block';
            const activeBtn = document.getElementById('tab-' + tabName);
            activeBtn.classList.add('active');
            activeBtn.style.background = 'var(--gradient-ocean)';
            activeBtn.style.color = 'white';
            
            // Load data for the selected tab
            if (tabName === 'sessions') {
                loadSessions();
            }
        }

        async function loadSessions() {
            try {
                const response = await fetch('/api/admin/sessions');
                if (!response.ok) throw new Error('Failed to fetch sessions');
                
                const data = await response.json();
                allSessions = data.sessions || data;
                const tbody = document.getElementById('sessions-tbody');
                
                if (!allSessions || allSessions.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 2rem; color: var(--text-muted);">No active sessions</td></tr>';
                    return;
                }
                
                tbody.innerHTML = allSessions.map(session => {
                    // Parse UTC timestamps correctly and calculate duration
                    const loginTime = new Date(session.created_at + ' UTC');
                    const lastActivity = new Date(session.last_activity + ' UTC');
                    const now = new Date();
                    const durationMs = now.getTime() - loginTime.getTime();
                    const duration = Math.floor(durationMs / 1000 / 60); // minutes
                    
                    return \`
                        <tr>
                            <td>
                                <i class="fas fa-user-circle" style="margin-right: 0.5rem; color: var(--accent-primary);"></i>
                                <strong>\${session.username}</strong>
                            </td>
                            <td>\${session.ip_address || 'Unknown'}</td>
                            <td style="max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="\${session.user_agent || 'Unknown'}">
                                \${session.user_agent || 'Unknown'}
                            </td>
                            <td>\${session.created_at_formatted || 'N/A'}</td>
                            <td>\${session.last_activity_formatted || 'N/A'}</td>
                            <td>\${duration < 60 ? duration + ' min' : Math.floor(duration / 60) + 'h ' + (duration % 60) + 'm'}</td>
                            <td>
                                <button onclick="terminateSession('\${session.id}')" class="btn-small btn-danger" title="Terminate Session">
                                    <i class="fas fa-sign-out-alt"></i> Terminate
                                </button>
                            </td>
                        </tr>
                    \`;
                }).join('');
            } catch (error) {
                console.error('Error loading sessions:', error);
                document.getElementById('sessions-tbody').innerHTML = 
                    '<tr><td colspan="7" style="text-align: center; padding: 2rem; color: var(--error-color);">Failed to load sessions</td></tr>';
            }
        }

        async function terminateSession(sessionToken) {
            if (!confirm('Are you sure you want to terminate this session?')) return;
            
            try {
                const response = await fetch(\`/api/admin/sessions/\${sessionToken}\`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    showNotification('Session terminated successfully', 'success');
                    loadSessions();
                } else {
                    throw new Error('Failed to terminate session');
                }
            } catch (error) {
                console.error('Error terminating session:', error);
                showNotification('Failed to terminate session', 'error');
            }
        }

        function refreshSessions() {
            loadSessions();
        }

        async function loadUsers() {
            try {
                const response = await fetch('/api/users');
                if (!response.ok) throw new Error('Failed to fetch users');
                
                const data = await response.json();
                allUsers = data.users || data; // Handle both {users: []} and direct array
                const tbody = document.getElementById('users-tbody');
                
                if (!allUsers || allUsers.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 2rem; color: var(--text-muted);">No users found</td></tr>';
                    return;
                }
                
                tbody.innerHTML = allUsers.map(user => \`
                    <tr>
                        <td>
                            <i class="fas fa-user-circle" style="margin-right: 0.5rem; color: var(--accent-primary);"></i>
                            <strong>\${user.username}</strong>
                        </td>
                        <td>\${user.email || '<em style="color: var(--text-muted);">Not set</em>'}</td>
                        <td><span class="role-badge role-\${user.role}">\${user.role}</span></td>
                        <td><span class="role-badge status-\${user.is_active ? 'active' : 'inactive'}">\${user.is_active ? 'Active' : 'Inactive'}</span></td>
                        <td>\${user.created_at_formatted || 'N/A'}</td>
                        <td>\${user.last_login_formatted || '<em style="color: var(--text-muted);">Never</em>'}</td>
                        <td>
                            <button onclick="editUser(\${user.id})" class="btn btn-small" style="margin-right: 0.5rem;">
                                <i class="fas fa-edit"></i> Edit
                            </button>
                            \${user.username !== 'admin' ? \`
                            <button onclick="deleteUser(\${user.id}, '\${user.username}')" class="btn btn-danger btn-small">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                            \` : ''}
                        </td>
                    </tr>
                \`).join('');
            } catch (error) {
                console.error('Error loading users:', error);
                document.getElementById('users-tbody').innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 2rem; color: var(--error-color);">Failed to load users</td></tr>';
            }
        }

        function showAddUserModal() {
            document.getElementById('addUserModal').classList.add('active');
        }

        function hideAddUserModal() {
            document.getElementById('addUserModal').classList.remove('active');
            document.getElementById('addUserForm').reset();
        }

        function showEditUserModal() {
            document.getElementById('editUserModal').classList.add('active');
        }

        function hideEditUserModal() {
            document.getElementById('editUserModal').classList.remove('active');
            document.getElementById('editUserForm').reset();
        }

        function editUser(userId) {
            const user = allUsers.find(u => u.id === userId);
            if (user) {
                document.getElementById('editUserId').value = user.id;
                document.getElementById('editUsername').value = user.username;
                document.getElementById('editEmail').value = user.email || '';
                document.getElementById('editRole').value = user.role;
                showEditUserModal();
            }
        }

        async function deleteUser(userId, username) {
            if (!confirm(\`Are you sure you want to delete user "\${username}"?\\n\\nThis action cannot be undone.\`)) return;
            
            try {
                const response = await fetch(\`/api/users/\${userId}\`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    alert(\`User "\${username}" deleted successfully\`);
                    loadUsers();
                } else {
                    const error = await response.json();
                    alert('Failed to delete user: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Error deleting user: ' + error.message);
            }
        }

        document.getElementById('addUserForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            const data = Object.fromEntries(formData);
            
            try {
                const response = await fetch('/api/users', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                if (response.ok) {
                    alert(\`User "\${data.username}" created successfully\`);
                    hideAddUserModal();
                    loadUsers();
                } else {
                    const error = await response.json();
                    alert('Failed to create user: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Error creating user: ' + error.message);
            }
        });

        document.getElementById('editUserForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            const data = Object.fromEntries(formData);
            const userId = data.userId;
            delete data.userId;
            delete data.username; // Don't send username
            
            // Remove password if empty
            if (!data.password) {
                delete data.password;
            }
            
            try {
                const response = await fetch(\`/api/users/\${userId}\`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                
                if (response.ok) {
                    alert('User updated successfully');
                    hideEditUserModal();
                    loadUsers();
                } else {
                    const error = await response.json();
                    alert('Failed to update user: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Error updating user: ' + error.message);
            }
        });

        // Close modals when clicking outside
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });

        // Load users on page load
        loadUsers();
    `;

    res.send(getPageTemplate({
        pageTitle: 'User Management',
        pageIcon: 'fas fa-users',
        activeNav: 'users',
        contentBody: contentBody,
        additionalCSS: additionalCSS,
        additionalJS: additionalJS,
        req: req
    }));
});

// ============================================================================
// USER ACTIVITY TIMELINE PAGE
// ============================================================================
app.get('/activity', requireAuth, (req, res) => {
    const pageContent = `
        <!-- Tab Navigation -->
        <div style="background: var(--bg-primary); border-radius: 12px; padding: 1rem; margin-bottom: 1.5rem; box-shadow: var(--shadow-light); border: 1px solid var(--border-color);">
            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                <button onclick="switchTab('alerts')" id="tab-alerts" class="tab-btn active" style="padding: 0.75rem 1.5rem; border: none; background: var(--gradient-ocean); color: white; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-exclamation-triangle"></i> Alerts
                </button>
                <button onclick="switchTab('activity')" id="tab-activity" class="tab-btn" style="padding: 0.75rem 1.5rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-history"></i> Activity Timeline
                </button>
            </div>
        </div>

        <!-- Alerts Tab Content -->
        <div id="content-alerts" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-exclamation-triangle"></i> System Alerts</h3>
                    <button onclick="refreshAlerts()" class="btn">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                </div>
                <div class="card-body" style="padding: 0;">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Message</th>
                                <th>Source</th>
                                <th>Timestamp</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="alerts-tbody">
                            <tr><td colspan="6" style="text-align: center; padding: 2rem;">Loading alerts...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Activity Tab Content -->
        <div id="content-activity" class="tab-content" style="display: none;">
            <div class="page-header">
                <div>
                    <h2><i class="fas fa-history"></i> User Activity Timeline</h2>
                    <p>Track user actions and system events</p>
                </div>
                <div class="header-actions">
                    <button onclick="refreshActivity()" class="btn">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                    <button onclick="exportActivity()" class="btn">
                        <i class="fas fa-download"></i> Export
                    </button>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 280px 1fr; gap: 1.25rem;">
                <!-- Filters -->
                <div class="card">
                    <div class="card-header">
                        <h3><i class="fas fa-filter"></i> Filters</h3>
                    </div>
                    <div style="padding: 1.5rem;">
                        <!-- User Filter -->
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; font-size: 0.875rem; color: var(--text-primary);">User</label>
                            <select id="user-filter" onchange="filterActivity()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                                <option value="all">All Users</option>
                            </select>
                        </div>

                        <!-- Action Filter -->
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; font-size: 0.875rem; color: var(--text-primary);">Action Type</label>
                            <select id="action-filter" onchange="filterActivity()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                                <option value="all">All Actions</option>
                                <option value="login">Login</option>
                                <option value="logout">Logout</option>
                                <option value="page_visit">Page Visit</option>
                                <option value="api_call">API Call</option>
                                <option value="admin_action">Admin Action</option>
                                <option value="security">Security Event</option>
                            </select>
                        </div>

                        <!-- Time Range -->
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; font-size: 0.875rem; color: var(--text-primary);">Time Range</label>
                            <select id="time-filter" onchange="filterActivity()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                                <option value="today" selected>Today</option>
                                <option value="week">Last 7 Days</option>
                                <option value="month">Last 30 Days</option>
                                <option value="all">All Time</option>
                            </select>
                        </div>

                        <!-- Stats -->
                        <div style="border-top: 1px solid var(--border-color); padding-top: 1rem; margin-top: 1rem;">
                            <div style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; font-size: 0.875rem;">
                                <span style="color: var(--text-muted);">Total Actions</span>
                                <span id="total-actions" style="font-weight: 600;">--</span>
                            </div>
                            <div style="margin-bottom: 0.75rem; display: flex; justify-content: space-between; font-size: 0.875rem;">
                                <span style="color: var(--text-muted);">Active Users</span>
                                <span id="active-users" style="font-weight: 600;">--</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; font-size: 0.875rem;">
                                <span style="color: var(--text-muted);">Today</span>
                                <span id="today-actions" style="font-weight: 600;">--</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Activity Timeline -->
                <div class="card">
                    <div class="card-header">
                        <h3><i class="fas fa-stream"></i> Activity Stream</h3>
                        <input type="text" id="activity-search" placeholder="Search activity..." autocomplete="off"
                               onkeyup="filterActivity()"
                               style="padding: 0.5rem 1rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); width: 250px; font-size: 0.875rem;">
                    </div>
                    <div id="activity-container" style="padding: 1.5rem; max-height: 70vh; overflow-y: auto;">
                        <div style="text-align: center; padding: 2rem;">
                            <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--accent-primary);"></i>
                            <p style="margin-top: 1rem; color: var(--text-muted);">Loading activity...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;

    const additionalCSS = `
        .tab-button.active {
            color: var(--accent-primary) !important;
            border-bottom-color: var(--accent-primary) !important;
        }
        .tab-button:hover {
            color: var(--accent-primary);
            background: var(--bg-secondary);
        }
        .tab-content {
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    `;

    const additionalJS = `
        let allActivity = [];
        let allUsers = [];
        let allAlerts = [];

        // Tab switching
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => tab.style.display = 'none');
            document.querySelectorAll('.tab-btn').forEach(btn => { 
                btn.classList.remove('active'); 
                btn.style.background = 'var(--bg-secondary)'; 
                btn.style.color = 'var(--text-primary)'; 
            });
            
            // Show selected tab
            document.getElementById('content-' + tabName).style.display = 'block';
            const activeBtn = document.getElementById('tab-' + tabName);
            activeBtn.classList.add('active');
            activeBtn.style.background = 'var(--gradient-ocean)';
            activeBtn.style.color = 'white';
            
            // Load data for the selected tab
            if (tabName === 'activity') {
                loadActivity();
            } else if (tabName === 'alerts') {
                loadAlerts();
            }
        }

        async function loadAlerts() {
            try {
                const response = await fetch('/api/alerts');
                if (!response.ok) throw new Error('Failed to fetch alerts');
                
                const data = await response.json();
                allAlerts = data.alerts || data;
                const tbody = document.getElementById('alerts-tbody');
                
                if (!allAlerts || allAlerts.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 2rem; color: var(--text-muted);">No alerts found</td></tr>';
                    return;
                }
                
                tbody.innerHTML = allAlerts.map(alert => {
                    const severityColors = {
                        critical: '#9b2c2c',
                        error: '#c05621',
                        warning: '#d69e2e',
                        info: '#2c5282'
                    };
                    const severityBgColors = {
                        critical: '#fed7d7',
                        error: '#feebc8',
                        warning: '#fefcbf',
                        info: '#bee3f8'
                    };
                    
                    return \`
                        <tr>
                            <td>
                                <span style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.75rem; font-weight: 600; text-transform: uppercase; background: \${severityBgColors[alert.severity]}; color: \${severityColors[alert.severity]};">
                                    \${alert.severity}
                                </span>
                            </td>
                            <td><strong>\${alert.message}</strong></td>
                            <td>\${alert.source || 'System'}</td>
                            <td>\${alert.created_at_formatted || 'N/A'}</td>
                            <td>
                                <span class="status-badge \${alert.is_read ? 'status-inactive' : 'status-active'}">
                                    \${alert.is_read ? 'Acknowledged' : 'Active'}
                                </span>
                            </td>
                            <td>
                                \${!alert.is_read ? \`
                                    <button onclick="acknowledgeAlert(\${alert.id})" class="btn btn-success btn-small">
                                        <i class="fas fa-check"></i> Acknowledge
                                    </button>
                                \` : \`
                                    <button onclick="deleteAlert(\${alert.id})" class="btn btn-danger btn-small">
                                        <i class="fas fa-trash"></i> Delete
                                    </button>
                                \`}
                            </td>
                        </tr>
                    \`;
                }).join('');
            } catch (error) {
                console.error('Error loading alerts:', error);
                document.getElementById('alerts-tbody').innerHTML = 
                    '<tr><td colspan="6" style="text-align: center; padding: 2rem; color: var(--error-color);">Failed to load alerts</td></tr>';
            }
        }

        async function acknowledgeAlert(alertId) {
            try {
                const response = await fetch(\`/api/alerts/\${alertId}/acknowledge\`, {
                    method: 'POST'
                });
                
                if (response.ok) {
                    showNotification('Alert acknowledged', 'success');
                    loadAlerts();
                } else {
                    throw new Error('Failed to acknowledge alert');
                }
            } catch (error) {
                console.error('Error acknowledging alert:', error);
                showNotification('Failed to acknowledge alert', 'error');
            }
        }

        async function deleteAlert(alertId) {
            if (!confirm('Are you sure you want to delete this alert?')) return;
            
            try {
                const response = await fetch(\`/api/alerts/\${alertId}\`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    showNotification('Alert deleted', 'success');
                    loadAlerts();
                } else {
                    throw new Error('Failed to delete alert');
                }
            } catch (error) {
                console.error('Error deleting alert:', error);
                showNotification('Failed to delete alert', 'error');
            }
        }

        function refreshAlerts() {
            loadAlerts();
        }

        // Load timezone settings before rendering timestamps
        async function loadTimezoneSettings() {
            try {
                const response = await fetch('/api/timezone');
                if (response.ok) {
                    const data = await response.json();
                    userTimezone = data.timezone;
                }
            } catch (error) {
                console.error('Failed to load timezone:', error);
            }
        }

        async function loadActivity() {
            try {
                const [activityRes, usersRes] = await Promise.all([
                    fetch('/api/activity'),
                    fetch('/api/users')
                ]);
                
                if (!activityRes.ok || !usersRes.ok) throw new Error('Failed to fetch data');
                
                allActivity = await activityRes.json();
                const usersData = await usersRes.json();
                allUsers = usersData.users || usersData; // Handle both formats
                
                // Populate user filter
                const userFilter = document.getElementById('user-filter');
                const currentValue = userFilter.value;
                userFilter.innerHTML = '<option value="all">All Users</option>' +
                    allUsers.map(u => \`<option value="\${u.id}">\${u.username}</option>\`).join('');
                userFilter.value = currentValue;
                
                updateStats();
                filterActivity();
            } catch (error) {
                console.error('Error loading activity:', error);
                document.getElementById('activity-container').innerHTML = 
                    '<div style="text-align: center; padding: 2rem; color: var(--error-color);"><i class="fas fa-exclamation-circle" style="font-size: 2rem;"></i><p style="margin-top: 1rem;">Failed to load activity</p></div>';
            }
        }

        function updateStats() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todayActivity = allActivity.filter(a => new Date(a.timestamp) >= today);
            const uniqueUsers = new Set(allActivity.map(a => a.user_id)).size;
            
            document.getElementById('total-actions').textContent = allActivity.length;
            document.getElementById('active-users').textContent = uniqueUsers;
            document.getElementById('today-actions').textContent = todayActivity.length;
        }

        function filterActivity() {
            const userFilter = document.getElementById('user-filter').value;
            const actionFilter = document.getElementById('action-filter').value;
            const timeFilter = document.getElementById('time-filter').value;
            const searchTerm = document.getElementById('activity-search').value.toLowerCase();

            let filtered = allActivity.filter(activity => {
                // User filter
                if (userFilter !== 'all' && activity.user_id !== parseInt(userFilter)) return false;
                
                // Action filter
                if (actionFilter !== 'all' && activity.action !== actionFilter) return false;
                
                // Time filter
                const activityDate = new Date(activity.timestamp);
                const now = new Date();
                if (timeFilter === 'today') {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    if (activityDate < today) return false;
                } else if (timeFilter === 'week') {
                    const weekAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);
                    if (activityDate < weekAgo) return false;
                } else if (timeFilter === 'month') {
                    const monthAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
                    if (activityDate < monthAgo) return false;
                }
                
                // Search filter
                if (searchTerm && !activity.action.toLowerCase().includes(searchTerm) && 
                    !activity.username.toLowerCase().includes(searchTerm) &&
                    !(activity.resource && activity.resource.toLowerCase().includes(searchTerm)) &&
                    !(activity.details && activity.details.toLowerCase().includes(searchTerm))) return false;

                return true;
            });

            renderActivity(filtered);
        }

        function renderActivity(activities) {
            const container = document.getElementById('activity-container');
            
            if (activities.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--text-muted);"><i class="fas fa-inbox" style="font-size: 3rem; opacity: 0.3;"></i><p style="margin-top: 1rem; font-size: 1.1rem;">No activity found</p></div>';
                return;
            }

            const actionIcons = {
                login: 'fa-sign-in-alt',
                logout: 'fa-sign-out-alt',
                page_visit: 'fa-file-alt',
                api_call: 'fa-plug',
                admin_action: 'fa-user-shield',
                security: 'fa-shield-alt',
                create: 'fa-plus-circle',
                update: 'fa-edit',
                delete: 'fa-trash-alt'
            };

            const actionColors = {
                login: '#10b981',
                logout: '#6b7280',
                page_visit: '#3b82f6',
                api_call: '#8b5cf6',
                admin_action: '#f59e0b',
                security: '#ef4444',
                create: '#10b981',
                update: '#3b82f6',
                delete: '#ef4444'
            };

            container.innerHTML = activities.map((activity, index) => {
                const timestamp = new Date(activity.timestamp);
                const timeAgo = getTimeAgo(timestamp);
                const icon = actionIcons[activity.action] || 'fa-circle';
                const color = actionColors[activity.action] || '#6b7280';
                const isFirst = index === 0;

                return \`
                    <div style="display: flex; gap: 1rem; margin-bottom: \${isFirst ? '1.5rem' : '1rem'}; position: relative;">
                        <!-- Timeline connector -->
                        \${!isFirst ? '<div style="position: absolute; left: 15px; top: -1rem; bottom: 0; width: 2px; background: var(--border-color);"></div>' : ''}
                        
                        <!-- Icon -->
                        <div style="flex-shrink: 0; width: 32px; height: 32px; border-radius: 50%; background: \${color}15; display: flex; align-items: center; justify-content: center; position: relative; z-index: 1;">
                            <i class="fas \${icon}" style="color: \${color}; font-size: 0.875rem;"></i>
                        </div>
                        
                        <!-- Content -->
                        <div style="flex: 1; padding-bottom: 1rem; border-bottom: 1px solid var(--border-color);">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;">
                                <div>
                                    <span style="font-weight: 600; color: var(--text-primary);">\${activity.username}</span>
                                    <span style="color: var(--text-muted); margin: 0 0.5rem;">‚Ä¢</span>
                                    <span style="color: \${color}; font-weight: 500; text-transform: capitalize;">\${activity.action.replace('_', ' ')}</span>
                                </div>
                                <div style="text-align: right;">
                                    <span class="time-ago" data-timestamp="\${activity.timestamp}" style="font-size: 0.75rem; color: var(--text-muted); display: block;">\${timeAgo}</span>
                                    <span style="font-size: 0.65rem; color: var(--text-muted); opacity: 0.7;">\${activity.timestampFormatted || formatTimestamp(activity.timestamp)}</span>
                                </div>
                            </div>
                            \${activity.resource ? \`
                                <div style="font-size: 0.875rem; color: var(--text-primary); margin-bottom: 0.25rem;">
                                    <i class="fas fa-link" style="opacity: 0.5; margin-right: 0.5rem;"></i>\${activity.resource}
                                </div>
                            \` : ''}
                            \${activity.details ? \`
                                <div style="font-size: 0.875rem; color: var(--text-muted);">\${activity.details}</div>
                            \` : ''}
                            <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">
                                <i class="fas fa-network-wired" style="opacity: 0.5;"></i> \${activity.ip_address || 'Unknown IP'}
                            </div>
                        </div>
                    </div>
                \`;
            }).join('');
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffSecs = Math.floor(diffMs / 1000);
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffSecs < 5) return 'Just now';
            if (diffSecs < 60) return \`\${diffSecs}s ago\`;
            if (diffMins < 60) return \`\${diffMins}min ago\`;
            if (diffHours < 24) return \`\${diffHours}h ago\`;
            return \`\${diffDays}d ago\`;
        }

        function refreshActivity() {
            loadActivity();
        }

        function exportActivity() {
            const filtered = allActivity; // Could filter this based on current filters
            const csv = 'Username,Action,Resource,Details,IP,Timestamp\\n' +
                filtered.map(a => \`"\${a.username}","\${a.action}","\${a.resource || ''}","\${a.details || ''}","\${a.ip_address || ''}","\${a.timestamp}"\`).join('\\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = \`activity-\${new Date().toISOString().split('T')[0]}.csv\`;
            a.click();
        }

        // Update all time-ago displays every 10 seconds
        function updateTimeDisplays() {
            document.querySelectorAll('.time-ago').forEach(element => {
                const timestamp = new Date(element.getAttribute('data-timestamp'));
                element.textContent = getTimeAgo(timestamp);
            });
        }

        document.addEventListener('DOMContentLoaded', async () => {
            // Load timezone settings first, then load alerts (default tab)
            await loadTimezoneSettings();
            await loadAlerts();
            setInterval(() => {
                // Auto-refresh based on active tab
                const alertsTab = document.getElementById('content-alerts');
                const activityTab = document.getElementById('content-activity');
                if (alertsTab.style.display !== 'none') {
                    loadAlerts();
                } else if (activityTab.style.display !== 'none') {
                    loadActivity();
                    updateTimeDisplays();
                }
            }, 60000); // Refresh every minute
        });
    `;

    res.send(getPageTemplate({
        pageTitle: 'User Activity',
        pageIcon: 'fas fa-history',
        activeNav: 'activity',
        contentBody: pageContent,
        additionalCSS: additionalCSS,
        additionalJS: additionalJS,
        req: req
    }));
});

// Webhooks Management page
app.get('/webhooks', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).send(getPageTemplate({
            pageTitle: 'Access Denied',
            pageIcon: 'fas fa-ban',
            activeNav: '',
            contentBody: '<div class="card"><div class="card-body"><h2 style="color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i> Access Denied</h2><p>Admin privileges required to access this page.</p><a href="/dashboard" class="btn"><i class="fas fa-arrow-left"></i> Return to Dashboard</a></div></div>',
            additionalCSS: '',
            additionalJS: '',
            req: req
        }));
    }

    const pageContent = `
        <div class="page-header">
            <div>
                <h1><i class="fas fa-webhook"></i> Webhook Management</h1>
                <p>Configure and manage webhooks for event notifications</p>
            </div>
            <div>
                <a href="/webhooks/add" class="btn">
                    <i class="fas fa-plus"></i> Add Webhook
                </a>
            </div>
        </div>

        <div class="grid" style="grid-template-columns: 1fr;">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-list"></i> Webhooks</h3>
                </div>
                <div class="card-body" style="padding: 0;">
                    <div id="webhooks-container" style="min-height: 200px;">
                        <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                            <i class="fas fa-spinner fa-spin" style="font-size: 2rem;"></i>
                            <p>Loading webhooks...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Delivery History Modal -->
        <div id="delivery-modal" class="modal">
            <div class="modal-content" style="max-width: 800px;">
                <div class="modal-header">
                    <h3><i class="fas fa-history"></i> Delivery History</h3>
                    <button type="button" class="modal-close" id="close-delivery-modal-btn">&times;</button>
                </div>
                <div class="modal-body">
                    <div id="deliveries-container" style="max-height: 400px; overflow-y: auto;"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" onclick="closeDeliveryModal()" class="btn">
                        <i class="fas fa-times"></i> Close
                    </button>
                </div>
            </div>
        </div>
    `;

    const additionalJS = `
        let webhooks = [];

        async function loadWebhooks() {
            try {
                const response = await fetch('/api/webhooks');
                webhooks = await response.json();
                renderWebhooks();
            } catch (error) {
                console.error('Failed to load webhooks:', error);
                showToast('Failed to load webhooks', 'error');
            }
        }

        function renderWebhooks() {
            const container = document.getElementById('webhooks-container');
            
            if (webhooks.length === 0) {
                container.innerHTML = \`
                    <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                        <i class="fas fa-webhook" style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;"></i>
                        <p>No webhooks available at this time</p>
                    </div>
                \`;
                return;
            }

            container.innerHTML = \`
                <table class="data-table">
                    <thead>
                        <tr>
                            <th style="width: 180px;">Name</th>
                            <th style="width: 280px;">URL</th>
                            <th style="width: 180px;">Events</th>
                            <th style="width: 120px; text-align: center;">Status</th>
                            <th style="width: 150px; text-align: center;">Success / Fail</th>
                            <th style="width: 180px;">Last Triggered</th>
                            <th style="width: 180px; text-align: center;">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        \${webhooks.map(webhook => \`
                            <tr>
                                <td>
                                    <div style="font-weight: 600; color: var(--text-primary);">\${webhook.name}</div>
                                    <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem;">
                                        <i class="fas fa-\${webhook.method === 'POST' ? 'paper-plane' : webhook.method === 'GET' ? 'download' : webhook.method === 'PUT' ? 'upload' : webhook.method === 'DELETE' ? 'trash' : 'exchange-alt'}"></i> 
                                        \${webhook.method}
                                    </div>
                                </td>
                                <td>
                                    <div style="font-size: 0.875rem; max-width: 280px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-family: 'Courier New', monospace; color: var(--accent-primary);" title="\${webhook.url}">
                                        \${webhook.url}
                                    </div>
                                </td>
                                <td>
                                    <div style="font-size: 0.875rem; color: var(--text-secondary);">
                                        \${webhook.event_types.length > 0 ? webhook.event_types.slice(0, 2).map(e => e.replace('_', ' ')).join(', ') : 'All events'}
                                        \${webhook.event_types.length > 2 ? \`<br><span style="color: var(--text-muted); font-size: 0.75rem;">+\${webhook.event_types.length - 2} more</span>\` : ''}
                                    </div>
                                </td>
                                <td style="text-align: center;">
                                    <span class="status-badge \${webhook.enabled ? 'online' : 'offline'}" style="padding: 0.4rem 0.8rem; border-radius: 20px; font-size: 0.75rem; font-weight: 600;">
                                        <i class="fas fa-\${webhook.enabled ? 'check-circle' : 'times-circle'}"></i> \${webhook.enabled ? 'Enabled' : 'Disabled'}
                                    </span>
                                </td>
                                <td style="text-align: center;">
                                    <div style="display: flex; gap: 1rem; justify-content: center; align-items: center; font-size: 0.875rem;">
                                        <span style="color: #10b981; font-weight: 600; display: flex; align-items: center; gap: 0.25rem;">
                                            <i class="fas fa-check-circle"></i> \${webhook.success_count}
                                        </span>
                                        <span style="color: #ef4444; font-weight: 600; display: flex; align-items: center; gap: 0.25rem;">
                                            <i class="fas fa-times-circle"></i> \${webhook.failure_count}
                                        </span>
                                    </div>
                                </td>
                                <td>
                                    <div style="font-size: 0.875rem; color: var(--text-secondary);">
                                        \${webhook.last_triggered_formatted ? \`<i class="fas fa-clock"></i> \${webhook.last_triggered_formatted}\` : '<span style="color: var(--text-muted);">Never</span>'}
                                    </div>
                                </td>
                                <td>
                                    <div style="display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap;">
                                        <button onclick="testWebhook(\${webhook.id})" class="btn-secondary" style="padding: 0.5rem 0.75rem; font-size: 0.85rem; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; border: none; transition: all 0.2s;" title="Test Webhook">
                                            <i class="fas fa-vial"></i> Test
                                        </button>
                                        <button onclick="viewDeliveries(\${webhook.id})" class="btn-secondary" style="padding: 0.5rem 0.75rem; font-size: 0.85rem; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; border: none; transition: all 0.2s;" title="View History">
                                            <i class="fas fa-history"></i> History
                                        </button>
                                        <a href="/webhooks/edit/\${webhook.id}" class="btn-secondary" style="padding: 0.5rem 0.75rem; font-size: 0.85rem; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; transition: all 0.2s; text-decoration: none; display: inline-flex; align-items: center; gap: 0.5rem;" title="Edit Webhook">
                                            <i class="fas fa-edit"></i> Edit
                                        </a>
                                        <button onclick="deleteWebhook(\${webhook.id}, '\${webhook.name}')" class="btn-secondary" style="padding: 0.5rem 0.75rem; font-size: 0.85rem; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; border: none; transition: all 0.2s;" title="Delete Webhook">
                                            <i class="fas fa-trash"></i> Delete
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        \`).join('')}
                    </tbody>
                </table>
            \`;
        }

        async function deleteWebhook(id, name) {
            if (!confirm(\`Are you sure you want to delete webhook "\${name}"?\`)) return;

            try {
                const response = await fetch(\`/api/webhooks/\${id}\`, { method: 'DELETE' });
                if (response.ok) {
                    showToast('Webhook deleted successfully', 'success');
                    loadWebhooks();
                } else {
                    showToast('Failed to delete webhook', 'error');
                }
            } catch (error) {
                console.error('Failed to delete webhook:', error);
                showToast('Failed to delete webhook', 'error');
            }
        }

        async function testWebhook(id) {
            try {
                const response = await fetch(\`/api/webhooks/\${id}/test\`, { method: 'POST' });
                const result = await response.json();
                showToast(result.message, result.success ? 'success' : 'error');
            } catch (error) {
                console.error('Failed to test webhook:', error);
                showToast('Failed to test webhook', 'error');
            }
        }

        async function viewDeliveries(id) {
            try {
                const response = await fetch(\`/api/webhooks/\${id}/deliveries\`);
                const deliveries = await response.json();
                
                const container = document.getElementById('deliveries-container');
                
                if (deliveries.length === 0) {
                    container.innerHTML = '<p style="text-align: center; padding: 2rem; color: var(--text-muted);">No delivery history</p>';
                } else {
                    container.innerHTML = deliveries.map(d => \`
                        <div style="padding: 1rem; border-bottom: 1px solid var(--border-color);">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;">
                                <div>
                                    <span class="status-badge" style="background: \${d.status === 'success' ? 'var(--success-color)' : 'var(--error-color)'};">
                                        <i class="fas fa-\${d.status === 'success' ? 'check' : 'times'}"></i> \${d.status}
                                    </span>
                                    <span style="margin-left: 0.5rem; font-weight: 600;">\${d.event_type}</span>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-size: 0.875rem;">\${d.attempted_at_formatted}</div>
                                    \${d.response_code ? \`<div style="font-size: 0.75rem; color: var(--text-muted);">HTTP \${d.response_code}</div>\` : ''}
                                </div>
                            </div>
                            \${d.error_message ? \`<div style="font-size: 0.875rem; color: var(--error-color); margin-top: 0.5rem;"><i class="fas fa-exclamation-circle"></i> \${d.error_message}</div>\` : ''}
                            \${d.status === 'failed' ? \`
                                <button onclick="retryDelivery(\${d.id})" class="btn" style="margin-top: 0.5rem; padding: 0.4rem 0.8rem; font-size: 0.8rem;">
                                    <i class="fas fa-redo"></i> Retry
                                </button>
                            \` : ''}
                        </div>
                    \`).join('');
                }

                document.getElementById('delivery-modal').classList.add('active');
            } catch (error) {
                console.error('Failed to load deliveries:', error);
                showToast('Failed to load deliveries', 'error');
            }
        }

        function closeDeliveryModal() {
            const modal = document.getElementById('delivery-modal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        async function retryDelivery(id) {
            try {
                const response = await fetch(\`/api/webhooks/deliveries/\${id}/retry\`, { method: 'POST' });
                const result = await response.json();
                showToast(result.message, result.success ? 'success' : 'error');
                closeDeliveryModal();
            } catch (error) {
                console.error('Failed to retry delivery:', error);
                showToast('Failed to retry delivery', 'error');
            }
        }

        // Setup event listeners
        function setupModalEventListeners() {
            // Close button click
            const closeBtn = document.getElementById('close-delivery-modal-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeDeliveryModal();
                });
            }

            // Backdrop click
            const modal = document.getElementById('delivery-modal');
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target.id === 'delivery-modal') {
                        closeDeliveryModal();
                    }
                });
            }

            // Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('delivery-modal');
                    if (modal && modal.classList.contains('active')) {
                        closeDeliveryModal();
                    }
                }
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            setupModalEventListeners();
            loadWebhooks();
            setInterval(loadWebhooks, 30000);
        });
    `;

    res.send(getPageTemplate({
        pageTitle: 'Webhooks',
        pageIcon: 'fas fa-link',
        activeNav: 'webhooks',
        contentBody: pageContent,
        additionalCSS: `
            #delivery-modal {
                display: none !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: rgba(0, 0, 0, 0.7) !important;
                backdrop-filter: blur(4px) !important;
                z-index: 99999 !important;
                align-items: center;
                justify-content: center;
            }
            
            #delivery-modal.active {
                display: flex !important;
            }
            
            #delivery-modal .modal-content {
                background: var(--bg-primary);
                border-radius: 12px;
                padding: 0;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                max-width: 900px;
                width: 90%;
                max-height: 90vh;
                overflow-y: auto;
                animation: slideUp 0.3s ease;
            }
            
            #delivery-modal .modal-header,
            #delivery-modal .modal-body,
            #delivery-modal .modal-footer {
                padding: 1.5rem 2rem;
            }
            
            #delivery-modal .modal-body {
                padding-top: 1rem;
                padding-bottom: 1rem;
            }
            
            /* Responsive breakpoints */
            @media (max-width: 640px) {
                #delivery-modal .modal-content {
                    width: 95% !important;
                    max-width: 95% !important;
                    max-height: 95vh !important;
                    border-radius: 8px !important;
                }
            }
            
            @media (min-width: 641px) and (max-width: 1024px) {
                #delivery-modal .modal-content {
                    width: 85% !important;
                    max-width: 750px !important;
                }
            }
            
            @media (min-width: 1025px) {
                #delivery-modal .modal-content {
                    width: 80% !important;
                    max-width: 1000px !important;
                }
            }
            
            #delivery-modal .modal-close {
                background: transparent !important;
                border: none !important;
                font-size: 2.5rem !important;
                line-height: 1 !important;
                cursor: pointer !important;
                color: var(--text-secondary) !important;
                font-weight: 300 !important;
                padding: 0 !important;
                width: 48px !important;
                height: 48px !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                border-radius: 8px !important;
                transition: all 0.2s ease !important;
                flex-shrink: 0 !important;
            }
            
            #delivery-modal .modal-close:hover {
                background: rgba(239, 68, 68, 0.1) !important;
                color: var(--error-color) !important;
                transform: rotate(90deg) !important;
            }
            
            @keyframes slideUp {
                from {
                    opacity: 0;
                    transform: translateY(20px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        `,
        additionalJS: additionalJS,
        req: req
    }));
});

// Add Webhook page
app.get('/webhooks/add', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).send(getPageTemplate({
            pageTitle: 'Access Denied',
            pageIcon: 'fas fa-ban',
            activeNav: '',
            contentBody: '<div class="card"><div class="card-body"><h2 style="color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i> Access Denied</h2><p>Admin privileges required to access this page.</p><a href="/dashboard" class="btn"><i class="fas fa-arrow-left"></i> Return to Dashboard</a></div></div>',
            additionalCSS: '',
            additionalJS: '',
            req: req
        }));
    }

    const pageContent = `
        <div class="page-header">
            <div>
                <h1><i class="fas fa-plus"></i> Add Webhook</h1>
                <p>Create a new webhook for event notifications</p>
            </div>
            <div>
                <a href="/webhooks" class="btn">
                    <i class="fas fa-arrow-left"></i> Back to Webhooks
                </a>
            </div>
        </div>

        <div class="grid" style="grid-template-columns: 1fr;">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-webhook"></i> Webhook Configuration</h3>
                </div>
                <div class="card-body">
                    <form id="webhook-form">
                        <div class="form-group">
                            <label><i class="fas fa-tag"></i> Name *</label>
                            <input type="text" id="webhook-name" class="form-control" placeholder="My Webhook" autocomplete="off" required>
                        </div>

                        <div class="form-group">
                            <label><i class="fas fa-link"></i> URL *</label>
                            <input type="url" id="webhook-url" class="form-control" placeholder="https://example.com/webhook" autocomplete="url" required>
                        </div>

                        <div class="form-group">
                            <label><i class="fas fa-exchange-alt"></i> HTTP Method</label>
                            <select id="webhook-method" class="form-control">
                                <option value="POST">POST</option>
                                <option value="GET">GET</option>
                                <option value="PUT">PUT</option>
                                <option value="DELETE">DELETE</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label><i class="fas fa-bolt"></i> Event Types</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color);">
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: normal;">
                                    <input type="checkbox" class="event-type" value="log_created"> Log Created
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: normal;">
                                    <input type="checkbox" class="event-type" value="alert_created"> Alert Created
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: normal;">
                                    <input type="checkbox" class="event-type" value="backup_created"> Backup Created
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: normal;">
                                    <input type="checkbox" class="event-type" value="user_login"> User Login
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: normal;">
                                    <input type="checkbox" class="event-type" value="user_logout"> User Logout
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: normal;">
                                    <input type="checkbox" class="event-type" value="system_error"> System Error
                                </label>
                            </div>
                            <small>Select events that will trigger this webhook</small>
                        </div>

                        <div class="form-group">
                            <label><i class="fas fa-key"></i> Secret (Optional)</label>
                            <input type="password" id="webhook-secret" class="form-control" placeholder="Secret for X-Webhook-Secret header">
                            <small>Used to verify webhook authenticity</small>
                        </div>

                        <div class="form-group">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: 600;">
                                <input type="checkbox" id="webhook-enabled" checked>
                                <span>Enable this webhook</span>
                            </label>
                        </div>

                        <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                            <button type="submit" class="btn">
                                <i class="fas fa-save"></i> Save Webhook
                            </button>
                            <a href="/webhooks" class="btn" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white;">
                                <i class="fas fa-times"></i> Cancel
                            </a>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    `;

    const additionalJS = `
        document.getElementById('webhook-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const name = document.getElementById('webhook-name').value;
            const url = document.getElementById('webhook-url').value;
            const method = document.getElementById('webhook-method').value;
            const secret = document.getElementById('webhook-secret').value;
            const enabled = document.getElementById('webhook-enabled').checked;
            const event_types = Array.from(document.querySelectorAll('.event-type:checked')).map(cb => cb.value);

            if (!name || !url) {
                showToast('Name and URL are required', 'error');
                return;
            }

            try {
                const response = await fetch('/api/webhooks', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, url, method, secret, enabled, event_types })
                });

                const result = await response.json();

                if (response.ok) {
                    showToast('Webhook created successfully', 'success');
                    setTimeout(() => window.location.href = '/webhooks', 1000);
                } else {
                    showToast(result.error || 'Failed to create webhook', 'error');
                }
            } catch (error) {
                console.error('Error creating webhook:', error);
                showToast('Failed to create webhook', 'error');
            }
        });
    `;

    res.send(getPageTemplate({
        pageTitle: 'Add Webhook',
        pageIcon: 'fas fa-plus',
        activeNav: 'webhooks',
        contentBody: pageContent,
        additionalCSS: '',
        additionalJS: additionalJS,
        req: req
    }));
});

// Edit Webhook page
app.get('/webhooks/edit/:id', requireAuth, async (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).send(getPageTemplate({
            pageTitle: 'Access Denied',
            pageIcon: 'fas fa-ban',
            activeNav: '',
            contentBody: '<div class="card"><div class="card-body"><h2 style="color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i> Access Denied</h2><p>Admin privileges required to access this page.</p><a href="/dashboard" class="btn"><i class="fas fa-arrow-left"></i> Return to Dashboard</a></div></div>',
            additionalCSS: '',
            additionalJS: '',
            req: req
        }));
    }

    const webhookId = req.params.id;

    const pageContent = `
        <div class="page-header">
            <div>
                <h1><i class="fas fa-edit"></i> Edit Webhook</h1>
                <p>Update webhook configuration</p>
            </div>
            <div>
                <a href="/webhooks" class="btn-secondary">
                    <i class="fas fa-arrow-left"></i> Back to Webhooks
                </a>
            </div>
        </div>

        <div class="grid" style="grid-template-columns: 1fr;">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-webhook"></i> Webhook Configuration</h3>
                </div>
                <div class="card-body" id="form-container">
                    <div style="text-align: center; padding: 2rem;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--accent-primary);"></i>
                        <p style="margin-top: 1rem; color: var(--text-muted);">Loading webhook...</p>
                    </div>
                </div>
            </div>
        </div>
    `;

    const additionalJS = `
        const webhookId = ${webhookId};

        async function loadWebhook() {
            try {
                const response = await fetch('/api/webhooks');
                const webhooks = await response.json();
                const webhook = webhooks.find(w => w.id === webhookId);

                if (!webhook) {
                    document.getElementById('form-container').innerHTML = \`
                        <div style="text-align: center; padding: 2rem; color: var(--error-color);">
                            <i class="fas fa-exclamation-triangle" style="font-size: 2rem;"></i>
                            <p style="margin-top: 1rem;">Webhook not found</p>
                            <a href="/webhooks" class="btn" style="margin-top: 1rem;">
                                <i class="fas fa-arrow-left"></i> Back to Webhooks
                            </a>
                        </div>
                    \`;
                    return;
                }

                document.getElementById('form-container').innerHTML = \`
                    <form id="webhook-form">
                        <div class="form-group">
                            <label><i class="fas fa-tag"></i> Name *</label>
                            <input type="text" id="webhook-name" class="form-control" value="\${webhook.name}" autocomplete="off" required>
                        </div>

                        <div class="form-group">
                            <label><i class="fas fa-link"></i> URL *</label>
                            <input type="url" id="webhook-url" class="form-control" value="\${webhook.url}" autocomplete="url" required>
                        </div>

                        <div class="form-group">
                            <label><i class="fas fa-exchange-alt"></i> HTTP Method</label>
                            <select id="webhook-method" class="form-control">
                                <option value="POST" \${webhook.method === 'POST' ? 'selected' : ''}>POST</option>
                                <option value="GET" \${webhook.method === 'GET' ? 'selected' : ''}>GET</option>
                                <option value="PUT" \${webhook.method === 'PUT' ? 'selected' : ''}>PUT</option>
                                <option value="DELETE" \${webhook.method === 'DELETE' ? 'selected' : ''}>DELETE</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label><i class="fas fa-bolt"></i> Event Types</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color);">
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: normal;">
                                    <input type="checkbox" class="event-type" value="log_created" \${webhook.event_types.includes('log_created') ? 'checked' : ''}> Log Created
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: normal;">
                                    <input type="checkbox" class="event-type" value="alert_created" \${webhook.event_types.includes('alert_created') ? 'checked' : ''}> Alert Created
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: normal;">
                                    <input type="checkbox" class="event-type" value="backup_created" \${webhook.event_types.includes('backup_created') ? 'checked' : ''}> Backup Created
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: normal;">
                                    <input type="checkbox" class="event-type" value="user_login" \${webhook.event_types.includes('user_login') ? 'checked' : ''}> User Login
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: normal;">
                                    <input type="checkbox" class="event-type" value="user_logout" \${webhook.event_types.includes('user_logout') ? 'checked' : ''}> User Logout
                                </label>
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: normal;">
                                    <input type="checkbox" class="event-type" value="system_error" \${webhook.event_types.includes('system_error') ? 'checked' : ''}> System Error
                                </label>
                            </div>
                            <small>Select events that will trigger this webhook</small>
                        </div>

                        <div class="form-group">
                            <label><i class="fas fa-key"></i> Secret (Optional)</label>
                            <input type="password" id="webhook-secret" class="form-control" value="\${webhook.secret || ''}" placeholder="Secret for X-Webhook-Secret header">
                            <small>Used to verify webhook authenticity. Leave blank to keep existing secret.</small>
                        </div>

                        <div class="form-group">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-weight: 600;">
                                <input type="checkbox" id="webhook-enabled" \${webhook.enabled ? 'checked' : ''}>
                                <span>Enable this webhook</span>
                            </label>
                        </div>

                        <div style="display: flex; gap: 1rem; margin-top: 2rem;">
                            <button type="submit" class="btn-success">
                                <i class="fas fa-save"></i> Update Webhook
                            </button>
                            <a href="/webhooks" class="btn-secondary">
                                <i class="fas fa-times"></i> Cancel
                            </a>
                        </div>
                    </form>
                \`;

                document.getElementById('webhook-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    const name = document.getElementById('webhook-name').value;
                    const url = document.getElementById('webhook-url').value;
                    const method = document.getElementById('webhook-method').value;
                    const secret = document.getElementById('webhook-secret').value;
                    const enabled = document.getElementById('webhook-enabled').checked;
                    const event_types = Array.from(document.querySelectorAll('.event-type:checked')).map(cb => cb.value);

                    if (!name || !url) {
                        showToast('Name and URL are required', 'error');
                        return;
                    }

                    try {
                        const response = await fetch(\`/api/webhooks/\${webhookId}\`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name, url, method, secret, enabled, event_types })
                        });

                        const result = await response.json();

                        if (response.ok) {
                            showToast('Webhook updated successfully', 'success');
                            setTimeout(() => window.location.href = '/webhooks', 1000);
                        } else {
                            showToast(result.error || 'Failed to update webhook', 'error');
                        }
                    } catch (error) {
                        console.error('Error updating webhook:', error);
                        showToast('Failed to update webhook', 'error');
                    }
                });
            } catch (error) {
                console.error('Error loading webhook:', error);
                document.getElementById('form-container').innerHTML = \`
                    <div style="text-align: center; padding: 2rem; color: var(--error-color);">
                        <i class="fas fa-exclamation-triangle" style="font-size: 2rem;"></i>
                        <p style="margin-top: 1rem;">Failed to load webhook</p>
                        <a href="/webhooks" class="btn" style="margin-top: 1rem;">
                            <i class="fas fa-arrow-left"></i> Back to Webhooks
                        </a>
                    </div>
                \`;
            }
        }

        document.addEventListener('DOMContentLoaded', loadWebhook);
    `;

    res.send(getPageTemplate({
        pageTitle: 'Edit Webhook',
        pageIcon: 'fas fa-edit',
        activeNav: 'webhooks',
        contentBody: pageContent,
        additionalCSS: '',
        additionalJS: additionalJS,
        req: req
    }));
});

// Integration Health Dashboard page
app.get('/integrations', requireAuth, (req, res) => {
    const pageContent = `
        <div class="page-header">
            <div>
                <h1><i class="fas fa-plug"></i> Integration Health</h1>
                <p style="color: var(--text-muted); margin-top: 0.5rem;">Monitor and test all system integrations</p>
            </div>
            <div style="display: flex; gap: 0.375rem;">
                <button onclick="showIntegrationLibrary()" class="btn">
                    <i class="fas fa-download"></i> Browse Integrations
                </button>
                <button onclick="showConfigureIntegrationModal()" class="btn">
                    <i class="fas fa-cog"></i> Configure Integration
                </button>
                <button onclick="testAllIntegrations()" class="btn">
                    <i class="fas fa-sync-alt"></i> Test All
                </button>
            </div>
        </div>

        <div id="integrations-grid" class="grid" style="grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 1.5rem;">
            <div style="text-align: center; padding: 3rem; color: var(--text-muted); grid-column: 1 / -1;">
                <i class="fas fa-spinner fa-spin" style="font-size: 2rem;"></i>
                <p>Loading integration health...</p>
            </div>
        </div>

        <!-- Integration Details Modal -->
        <div id="integration-modal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 800px;">
                <div class="modal-header">
                    <h3 id="integration-modal-title"><i class="fas fa-info-circle"></i> Integration Details</h3>
                </div>
                <div class="modal-body">
                    <div id="integration-details"></div>
                    <div id="integration-history" style="margin-top: 2rem;">
                        <h4 style="margin-bottom: 1rem;"><i class="fas fa-history"></i> Recent History</h4>
                        <div id="history-container"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" id="close-integration-modal-footer-btn" class="btn">
                        <i class="fas fa-times"></i> Close
                    </button>
                </div>
            </div>
        </div>

        <!-- Configure Integration Modal -->
        <div id="configure-integration-modal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 700px;">
                <div class="modal-header">
                    <h3><i class="fas fa-cog"></i> Configure Integration</h3>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="integration-select">Integration Type</label>
                        <select id="integration-select" class="form-control" onchange="updateIntegrationForm()">
                            <option value="">-- Select Integration --</option>
                            <option value="mqtt">MQTT Broker</option>
                            <option value="websocket">WebSocket Server</option>
                            <option value="home_assistant">Home Assistant</option>
                            <option value="unifi">UniFi Network</option>
                            <option value="pushover">Pushover Notifications</option>
                            <option value="discord">Discord Webhook</option>
                            <option value="slack">Slack Webhook</option>
                            <option value="telegram">Telegram Bot</option>
                            <option value="custom">Custom Integration</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                            <input type="checkbox" id="integration-enabled" style="width: auto;">
                            <span>Enable this integration</span>
                        </label>
                    </div>

                    <div id="integration-config-form"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" onclick="closeConfigureModal()" class="btn">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                    <button type="button" onclick="saveIntegrationConfig()" class="btn">
                        <i class="fas fa-save"></i> Save Configuration
                    </button>
                </div>
            </div>
        </div>

        <!-- Integration Library Modal -->
        <div id="integration-library-modal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 900px;">
                <div class="modal-header">
                    <h3><i class="fas fa-download"></i> Available Integrations</h3>
                </div>
                <div class="modal-body">
                    <p style="color: var(--text-muted); margin-bottom: 1.5rem;">
                        Select an integration template to quickly configure popular services
                    </p>
                    <div id="integration-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 1rem;"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" onclick="closeIntegrationLibrary()" class="btn">
                        <i class="fas fa-times"></i> Close
                    </button>
                </div>
            </div>
        </div>
    `;

    const additionalJS = `
        let integrations = [];

        const integrationInfo = {
            mqtt: { name: 'MQTT Broker', icon: 'fa-share-alt', iconClass: 'fas', color: '#8b5cf6' },
            websocket: { name: 'WebSocket Server', icon: 'fa-broadcast-tower', iconClass: 'fas', color: '#3b82f6' },
            home_assistant: { name: 'Home Assistant', icon: 'fa-home', iconClass: 'fas', color: '#18bcf2' },
            unifi: { name: 'UniFi Network', icon: 'fa-network-wired', iconClass: 'fas', color: '#0559C9' },
            pushover: { name: 'Pushover', icon: 'fa-bell', iconClass: 'fas', color: '#f59e0b' },
            discord: { name: 'Discord', icon: 'fa-discord', iconClass: 'fab', color: '#5865f2' },
            slack: { name: 'Slack', icon: 'fa-slack', iconClass: 'fab', color: '#4a154b' },
            telegram: { name: 'Telegram', icon: 'fa-telegram', iconClass: 'fab', color: '#0088cc' },
            custom: { name: 'Custom Integration', icon: 'fa-puzzle-piece', iconClass: 'fas', color: '#6b7280' }
        };

        async function loadIntegrations() {
            try {
                const response = await fetch('/api/integrations/health');
                const data = await response.json();
                console.log('loadIntegrations received data:', data);
                
                // Ensure integrations is always an array
                integrations = Array.isArray(data) ? data : [];
                console.log('integrations after processing:', integrations);
                
                // If no integrations exist, trigger a health check (but don't reload after)
                if (integrations.length === 0) {
                    console.log('No integrations found, running health check...');
                    await testAllIntegrations(true); // Pass true to skip reload
                    const retryResponse = await fetch('/api/integrations/health');
                    const retryData = await retryResponse.json();
                    integrations = Array.isArray(retryData) ? retryData : [];
                    console.log('integrations after retry:', integrations);
                }
                
                renderIntegrations();
            } catch (error) {
                console.error('Failed to load integrations:', error);
                showToast('Failed to load integrations', 'error');
                // Ensure integrations is an array even on error
                integrations = [];
                renderIntegrations();
            }
        }

        function getStatusColor(status) {
            switch(status) {
                case 'online': return '#10b981';
                case 'offline': return '#ef4444';
                case 'degraded': return '#f59e0b';
                case 'disabled': return '#6b7280';
                default: return '#9ca3af';
            }
        }

        function getStatusIcon(status) {
            switch(status) {
                case 'online': return 'check-circle';
                case 'offline': return 'times-circle';
                case 'degraded': return 'exclamation-circle';
                case 'disabled': return 'ban';
                default: return 'question-circle';
            }
        }

        function renderIntegrations() {
            const container = document.getElementById('integrations-grid');
            console.log('renderIntegrations called, integrations:', integrations);
            console.log('integrations.length:', integrations.length);
            console.log('container element:', container);
            
            if (integrations.length === 0) {
                container.innerHTML = 
                    '<div style="text-align: center; padding: 3rem; color: var(--text-muted); grid-column: 1 / -1;">' +
                        '<i class="fas fa-plug" style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;"></i>' +
                        '<p>No integration data available</p>' +
                        '<button onclick="testAllIntegrations()" class="btn" style="margin-top: 1rem;">' +
                            '<i class="fas fa-sync-alt"></i> Run Health Check' +
                        '</button>' +
                    '</div>';
                return;
            }

            const cards = integrations.map(integration => {
                const info = integrationInfo[integration.integration_name] || { 
                    name: integration.integration_name, 
                    icon: 'fa-plug', 
                    iconClass: 'fas',
                    color: '#6b7280' 
                };
                const statusColor = getStatusColor(integration.status);
                const statusIcon = getStatusIcon(integration.status);
                
                const errorSection = integration.error_message ? 
                    '<div style="padding: 0.75rem; background: var(--error-color)20; border-left: 3px solid var(--error-color); border-radius: 4px; margin-bottom: 1rem;">' +
                        '<div style="font-size: 0.875rem; color: var(--error-color);">' +
                            '<i class="fas fa-exclamation-triangle"></i> ' + integration.error_message +
                        '</div>' +
                    '</div>' : '';

                const responseTime = integration.response_time ? integration.response_time + 'ms' : 'N/A';
                const errorCountColor = integration.error_count > 0 ? 'var(--error-color)' : 'var(--success-color)';
                const errorCount = integration.error_count || 0;
                const lastCheck = integration.last_check_formatted || 'Never';
                const lastSuccess = integration.last_success_formatted || 'Never';

                return '<div class="card" style="border-left: 4px solid ' + statusColor + ';">' +
                        '<div class="card-body">' +
                            '<div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">' +
                                '<div style="display: flex; align-items: center; gap: 1rem;">' +
                                    '<div style="width: 48px; height: 48px; border-radius: 12px; background: linear-gradient(135deg, ' + info.color + '20, ' + info.color + '40); display: flex; align-items: center; justify-content: center;">' +
                                        '<i class="' + info.iconClass + ' ' + info.icon + '" style="font-size: 1.5rem; color: ' + info.color + ';"></i>' +
                                    '</div>' +
                                    '<div>' +
                                        '<h3 style="margin: 0; font-size: 1.1rem;">' + info.name + '</h3>' +
                                        '<div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem;">' + integration.integration_name + '</div>' +
                                    '</div>' +
                                '</div>' +
                                '<div style="text-align: right;">' +
                                    '<span class="status-badge" style="background: ' + statusColor + ';">' +
                                        '<i class="fas fa-' + statusIcon + '"></i> ' + integration.status +
                                    '</span>' +
                                '</div>' +
                            '</div>' +
                            '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px;">' +
                                '<div>' +
                                    '<div style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.25rem;">Response Time</div>' +
                                    '<div style="font-weight: 600; color: var(--text-primary);">' + responseTime + '</div>' +
                                '</div>' +
                                '<div>' +
                                    '<div style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.25rem;">Error Count</div>' +
                                    '<div style="font-weight: 600; color: ' + errorCountColor + ';">' + errorCount + '</div>' +
                                '</div>' +
                                '<div>' +
                                    '<div style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.25rem;">Last Check</div>' +
                                    '<div style="font-size: 0.875rem;">' + lastCheck + '</div>' +
                                '</div>' +
                                '<div>' +
                                    '<div style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.25rem;">Last Success</div>' +
                                    '<div style="font-size: 0.875rem;">' + lastSuccess + '</div>' +
                                '</div>' +
                            '</div>' +
                            errorSection +
                            '<div style="display: flex; gap: 0.5rem;">' +
                                '<button onclick="testIntegration(&quot;' + integration.integration_name + '&quot;)" class="btn" style="flex: 1; padding: 0.6rem;">' +
                                    '<i class="fas fa-sync-alt"></i> Test' +
                                '</button>' +
                                '<button onclick="viewIntegrationDetails(&quot;' + integration.integration_name + '&quot;)" class="btn" style="flex: 1; padding: 0.6rem; background: var(--info-color);">' +
                                    '<i class="fas fa-chart-line"></i> Details' +
                                '</button>' +
                            '</div>' +
                        '</div>' +
                    '</div>';
            });
            
            container.innerHTML = cards.join('');
        }

        async function testIntegration(name) {
            showToast('Testing ' + name + '...', 'info');
            
            try {
                const response = await fetch('/api/integrations/' + name + '/test', { method: 'POST' });
                const result = await response.json();
                
                showToast(name + ': ' + result.status, result.status === 'online' ? 'success' : 'error');
                loadIntegrations();
            } catch (error) {
                console.error('Failed to test integration:', error);
                showToast('Failed to test integration', 'error');
            }
        }

        async function testAllIntegrations(skipReload = false) {
            showToast('Testing all integrations...', 'info');
            
            try {
                const response = await fetch('/api/integrations/test-all', { method: 'POST' });
                const results = await response.json();
                
                // Handle object format returned by API
                const integrationList = Object.entries(results);
                const successCount = integrationList.filter(([name, integration]) => 
                    integration.enabled && integration.connected
                ).length;
                const totalCount = integrationList.filter(([name, integration]) => 
                    integration.enabled
                ).length;
                
                showToast(successCount + '/' + totalCount + ' integrations online', 'success');
                
                // Only reload if not called from loadIntegrations to prevent infinite loop
                if (!skipReload) {
                    loadIntegrations();
                }
            } catch (error) {
                console.error('Failed to test integrations:', error);
                showToast('Failed to test integrations', 'error');
            }
        }

        async function viewIntegrationDetails(name) {
            const integration = integrations.find(i => i.integration_name === name);
            if (!integration) return;

            const info = integrationInfo[name] || { name, icon: 'fa-plug', iconClass: 'fas', color: '#6b7280' };
            document.getElementById('integration-modal-title').innerHTML = '<i class="' + info.iconClass + ' ' + info.icon + '"></i> ' + info.name;

            const statusColor = getStatusColor(integration.status);
            const errorSection = integration.error_message ? 
                '<div style="padding: 1rem; background: rgba(239, 68, 68, 0.1); border-left: 3px solid var(--error-color); border-radius: 4px; margin-top: 1rem;">' +
                    '<div style="font-weight: 600; margin-bottom: 0.5rem;">Latest Error:</div>' +
                    '<div style="font-size: 0.875rem; color: var(--error-color);">' + integration.error_message + '</div>' +
                '</div>' : '';
            
            document.getElementById('integration-details').innerHTML = 
                '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">' +
                    '<div>' +
                        '<div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.5rem;">Status</div>' +
                        '<span class="status-badge" style="background: ' + statusColor + ';">' +
                            '<i class="fas fa-' + getStatusIcon(integration.status) + '"></i> ' + integration.status +
                        '</span>' +
                    '</div>' +
                    '<div>' +
                        '<div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.5rem;">Response Time</div>' +
                        '<div style="font-weight: 600;">' + (integration.response_time ? integration.response_time + 'ms' : 'N/A') + '</div>' +
                    '</div>' +
                    '<div>' +
                        '<div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.5rem;">Error Count</div>' +
                        '<div style="font-weight: 600; color: ' + (integration.error_count > 0 ? 'var(--error-color)' : 'var(--success-color)') + ';">' +
                            (integration.error_count || 0) +
                        '</div>' +
                    '</div>' +
                    '<div>' +
                        '<div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.5rem;">Last Check</div>' +
                        '<div style="font-size: 0.875rem;">' + (integration.last_check_formatted || 'Never') + '</div>' +
                    '</div>' +
                '</div>' + errorSection;

            // Load history
            try {
                const response = await fetch('/api/integrations/' + name + '/history?limit=10');
                const history = await response.json();

                if (history.length === 0) {
                    document.getElementById('history-container').innerHTML = '<p style="color: var(--text-muted); text-align: center;">No history available</p>';
                } else {
                    const historyHtml = history.map(h => {
                        const responseTimeHtml = h.response_time ? '<span style="margin-left: 0.5rem; font-size: 0.875rem; color: var(--text-muted);">' + h.response_time + 'ms</span>' : '';
                        return '<div style="padding: 0.75rem; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;">' +
                            '<div>' +
                                '<span class="status-badge" style="background: ' + getStatusColor(h.status) + '; font-size: 0.75rem;">' +
                                    (h.status || 'unknown') +
                                '</span>' +
                                responseTimeHtml +
                            '</div>' +
                            '<div style="font-size: 0.875rem; color: var(--text-muted);">' +
                                h.timestamp_formatted +
                            '</div>' +
                        '</div>';
                    }).join('');
                    
                    document.getElementById('history-container').innerHTML = 
                        '<div style="max-height: 300px; overflow-y: auto;">' + historyHtml + '</div>';
                }
            } catch (error) {
                console.error('Failed to load history:', error);
                document.getElementById('history-container').innerHTML = '<p style="color: var(--error-color);">Failed to load history</p>';
            }

            const modal = document.getElementById('integration-modal');
            modal.classList.add('active');
            modal.style.display = 'flex'; // Force show
        }

        function closeIntegrationModal() {
            const modal = document.getElementById('integration-modal');
            if (modal) {
                modal.classList.remove('active');
                modal.style.display = 'none'; // Force hide
            }
        }

        // Make function globally accessible
        window.closeIntegrationModal = closeIntegrationModal;

        // Setup event listeners - called multiple times with retry
        let eventListenersSetup = false;
        function setupModalEventListeners() {
            if (eventListenersSetup) return;

            const footerBtn = document.getElementById('close-integration-modal-footer-btn');
            
            if (!footerBtn) {
                setTimeout(setupModalEventListeners, 100);
                return;
            }

            footerBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                closeIntegrationModal();
            });

            // Backdrop click
            const modal = document.getElementById('integration-modal');
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeIntegrationModal();
                    }
                });
            }

            // Configure modal backdrop click
            const configModal = document.getElementById('configure-integration-modal');
            if (configModal) {
                configModal.addEventListener('click', function(e) {
                    if (e.target === configModal) {
                        closeConfigureModal();
                    }
                });
            }

            // Library modal backdrop click
            const libraryModal = document.getElementById('integration-library-modal');
            if (libraryModal) {
                libraryModal.addEventListener('click', function(e) {
                    if (e.target === libraryModal) {
                        closeIntegrationLibrary();
                    }
                });
            }

            // Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('integration-modal');
                    const configModal = document.getElementById('configure-integration-modal');
                    const libraryModal = document.getElementById('integration-library-modal');
                    
                    if (modal && modal.classList.contains('active')) {
                        closeIntegrationModal();
                    } else if (configModal && configModal.style.display === 'flex') {
                        closeConfigureModal();
                    } else if (libraryModal && libraryModal.style.display === 'flex') {
                        closeIntegrationLibrary();
                    }
                }
            });

            eventListenersSetup = true;
        }

        // Configure Integration Modal Functions
        function showConfigureIntegrationModal() {
            document.getElementById('configure-integration-modal').style.display = 'flex';
            document.getElementById('integration-select').value = '';
            document.getElementById('integration-enabled').checked = false;
            document.getElementById('integration-config-form').innerHTML = '';
        }

        function closeConfigureModal() {
            document.getElementById('configure-integration-modal').style.display = 'none';
        }

        // Integration Library Functions
        const availableIntegrations = [
            {
                id: 'grafana',
                name: 'Grafana',
                description: 'Send logs and metrics to Grafana Cloud or self-hosted instance',
                icon: 'fa-chart-line',
                iconClass: 'fas',
                color: '#F46800',
                category: 'Monitoring',
                template: {
                    type: 'rest',
                    authType: 'bearer',
                    url: 'https://your-grafana.com',
                    headers: { 'Content-Type': 'application/json' }
                }
            },
            {
                id: 'splunk',
                name: 'Splunk',
                description: 'Forward logs to Splunk Enterprise or Splunk Cloud',
                icon: 'fa-database',
                iconClass: 'fas',
                color: '#000000',
                category: 'SIEM',
                template: {
                    type: 'rest',
                    authType: 'bearer',
                    url: 'https://your-splunk.com:8088/services/collector',
                    headers: { 'Authorization': 'Splunk <token>' }
                }
            },
            {
                id: 'datadog',
                name: 'Datadog',
                description: 'Send logs and APM data to Datadog',
                icon: 'fa-dog',
                iconClass: 'fas',
                color: '#632CA6',
                category: 'Monitoring',
                template: {
                    type: 'rest',
                    authType: 'apikey',
                    url: 'https://http-intake.logs.datadoghq.com/v1/input',
                    headers: { 'Content-Type': 'application/json' }
                }
            },
            {
                id: 'newrelic',
                name: 'New Relic',
                description: 'Forward application logs to New Relic',
                icon: 'fa-chart-area',
                iconClass: 'fas',
                color: '#008C99',
                category: 'APM',
                template: {
                    type: 'rest',
                    authType: 'apikey',
                    url: 'https://log-api.newrelic.com/log/v1',
                    headers: { 'Content-Type': 'application/json' }
                }
            },
            {
                id: 'elastic',
                name: 'Elasticsearch',
                description: 'Index logs in Elasticsearch cluster',
                icon: 'fa-search',
                iconClass: 'fas',
                color: '#00BFB3',
                category: 'Search',
                template: {
                    type: 'rest',
                    authType: 'basic',
                    url: 'https://your-elastic.com:9200',
                    headers: { 'Content-Type': 'application/json' }
                }
            },
            {
                id: 'pagerduty',
                name: 'PagerDuty',
                description: 'Create incidents and alerts in PagerDuty',
                icon: 'fa-bell',
                iconClass: 'fas',
                color: '#06AC38',
                category: 'Alerting',
                template: {
                    type: 'rest',
                    authType: 'bearer',
                    url: 'https://events.pagerduty.com/v2/enqueue',
                    headers: { 'Content-Type': 'application/json' }
                }
            },
            {
                id: 'msteams',
                name: 'Microsoft Teams',
                description: 'Send notifications to Teams channels',
                icon: 'fa-microsoft',
                iconClass: 'fab',
                color: '#5059C9',
                category: 'Communication',
                template: {
                    type: 'webhook',
                    authType: 'none',
                    url: 'https://outlook.office.com/webhook/...',
                    headers: { 'Content-Type': 'application/json' }
                }
            },
            {
                id: 'opsgenie',
                name: 'Opsgenie',
                description: 'Create alerts and incidents in Opsgenie',
                icon: 'fa-exclamation-triangle',
                iconClass: 'fas',
                color: '#2684FF',
                category: 'Alerting',
                template: {
                    type: 'rest',
                    authType: 'bearer',
                    url: 'https://api.opsgenie.com/v2/alerts',
                    headers: { 'Content-Type': 'application/json' }
                }
            }
        ];

        function showIntegrationLibrary() {
            const modal = document.getElementById('integration-library-modal');
            modal.style.display = 'flex';
            renderIntegrationLibrary();
        }

        function closeIntegrationLibrary() {
            document.getElementById('integration-library-modal').style.display = 'none';
        }

        function renderIntegrationLibrary() {
            const container = document.getElementById('integration-library-grid');
            
            const cards = availableIntegrations.map(integration => {
                return \`
                    <div class="card" style="cursor: pointer; transition: all 0.3s ease; border-left: 4px solid \${integration.color};" 
                         onclick="installIntegration('\${integration.id}')">
                        <div class="card-body" style="padding: 1.5rem;">
                            <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                                <div style="width: 48px; height: 48px; border-radius: 12px; background: linear-gradient(135deg, \${integration.color}20, \${integration.color}40); display: flex; align-items: center; justify-content: center;">
                                    <i class="\${integration.iconClass} \${integration.icon}" style="font-size: 1.5rem; color: \${integration.color};"></i>
                                </div>
                                <div style="flex: 1;">
                                    <h4 style="margin: 0; font-size: 1.1rem;">\${integration.name}</h4>
                                    <span style="font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;">\${integration.category}</span>
                                </div>
                            </div>
                            <p style="font-size: 0.875rem; color: var(--text-secondary); margin: 0;">\${integration.description}</p>
                            <div style="margin-top: 1rem; display: flex; align-items: center; gap: 0.5rem; color: var(--accent-primary); font-size: 0.875rem; font-weight: 600;">
                                <i class="fas fa-plus-circle"></i> Add Integration
                            </div>
                        </div>
                    </div>
                \`;
            }).join('');
            
            container.innerHTML = cards;
        }

        function installIntegration(integrationId) {
            const integration = availableIntegrations.find(i => i.id === integrationId);
            if (!integration) return;

            closeIntegrationLibrary();
            
            // Open configure modal with pre-filled template
            document.getElementById('configure-integration-modal').style.display = 'flex';
            document.getElementById('integration-select').value = 'custom';
            document.getElementById('integration-enabled').checked = false;
            
            // Pre-fill the custom integration form with template
            setTimeout(() => {
                updateIntegrationForm();
                setTimeout(() => {
                    document.getElementById('custom-name').value = integration.name;
                    document.getElementById('custom-type').value = integration.template.type;
                    document.getElementById('custom-url').value = integration.template.url;
                    document.getElementById('custom-auth').value = integration.template.authType;
                    if (integration.template.headers) {
                        document.getElementById('custom-headers').value = JSON.stringify(integration.template.headers, null, 2);
                    }
                    showToast('Template loaded! Complete the configuration and save.', 'info');
                }, 100);
            }, 100);
        }

        function updateIntegrationForm() {
            const integrationType = document.getElementById('integration-select').value;
            const formContainer = document.getElementById('integration-config-form');
            
            if (!integrationType) {
                formContainer.innerHTML = '';
                return;
            }

            // Load existing config if available
            fetch('/api/integrations/configs/' + integrationType)
                .then(response => response.json())
                .then(config => {
                    if (config) {
                        document.getElementById('integration-enabled').checked = config.enabled;
                        renderIntegrationForm(integrationType, config.config_json ? JSON.parse(config.config_json) : {});
                    } else {
                        renderIntegrationForm(integrationType, {});
                    }
                })
                .catch(() => {
                    renderIntegrationForm(integrationType, {});
                });
        }

        function renderIntegrationForm(type, config) {
            const formContainer = document.getElementById('integration-config-form');
            let formHTML = '';

            switch(type) {
                case 'mqtt':
                    formHTML = \`
                        <div class="form-group">
                            <label for="mqtt-broker">Broker URL</label>
                            <input type="text" id="mqtt-broker" class="form-control" placeholder="mqtt://localhost:1883" value="\${config.broker || ''}">
                        </div>
                        <div class="form-group">
                            <label for="mqtt-username">Username (optional)</label>
                            <input type="text" id="mqtt-username" class="form-control" value="\${config.username || ''}">
                        </div>
                        <div class="form-group">
                            <label for="mqtt-password">Password (optional)</label>
                            <input type="password" id="mqtt-password" class="form-control" value="\${config.password || ''}">
                        </div>
                        <div class="form-group">
                            <label for="mqtt-topics">Topics (comma-separated)</label>
                            <input type="text" id="mqtt-topics" class="form-control" placeholder="home/sensors/#, dsc/events" value="\${(config.topics || []).join(', ')}">
                        </div>
                    \`;
                    break;

                case 'websocket':
                    formHTML = \`
                        <div class="form-group">
                            <label for="ws-port">WebSocket Port</label>
                            <input type="number" id="ws-port" class="form-control" placeholder="8080" value="\${config.port || 8080}">
                        </div>
                    \`;
                    break;

                case 'home_assistant':
                    formHTML = \`
                        <div class="form-group">
                            <label for="ha-url">Home Assistant URL</label>
                            <input type="text" id="ha-url" class="form-control" placeholder="http://homeassistant.local:8123" value="\${config.url || ''}">
                        </div>
                        <div class="form-group">
                            <label for="ha-token">Long-Lived Access Token</label>
                            <input type="password" id="ha-token" class="form-control" value="\${config.token || ''}">
                        </div>
                    \`;
                    break;

                case 'pushover':
                    formHTML = \`
                        <div class="form-group">
                            <label for="pushover-token">API Token</label>
                            <input type="password" id="pushover-token" class="form-control" value="\${config.token || ''}">
                        </div>
                        <div class="form-group">
                            <label for="pushover-user">User Key</label>
                            <input type="password" id="pushover-user" class="form-control" value="\${config.user || ''}">
                        </div>
                    \`;
                    break;

                case 'discord':
                    formHTML = \`
                        <div class="form-group">
                            <label for="discord-webhook">Webhook URL</label>
                            <input type="text" id="discord-webhook" class="form-control" placeholder="https://discord.com/api/webhooks/..." value="\${config.webhookUrl || ''}">
                        </div>
                    \`;
                    break;

                case 'slack':
                    formHTML = \`
                        <div class="form-group">
                            <label for="slack-webhook">Webhook URL</label>
                            <input type="text" id="slack-webhook" class="form-control" placeholder="https://hooks.slack.com/services/..." value="\${config.webhookUrl || ''}">
                        </div>
                    \`;
                    break;

                case 'telegram':
                    formHTML = \`
                        <div class="form-group">
                            <label for="telegram-token">Bot Token</label>
                            <input type="password" id="telegram-token" class="form-control" value="\${config.token || ''}">
                        </div>
                        <div class="form-group">
                            <label for="telegram-chatid">Chat ID</label>
                            <input type="text" id="telegram-chatid" class="form-control" value="\${config.chatId || ''}">
                        </div>
                    \`;
                    break;

                case 'unifi':
                    formHTML = \`
                        <div class="form-group">
                            <label for="unifi-host">Controller URL</label>
                            <input type="text" id="unifi-host" class="form-control" placeholder="https://192.168.1.1:8443" value="\${config.host || ''}">
                            <small style="color: var(--text-muted);">UniFi controller address with port</small>
                        </div>
                        <div class="form-group">
                            <label for="unifi-username">Username</label>
                            <input type="text" id="unifi-username" class="form-control" placeholder="admin" value="\${config.username || ''}">
                        </div>
                        <div class="form-group">
                            <label for="unifi-password">Password</label>
                            <input type="password" id="unifi-password" class="form-control" value="\${config.password || ''}">
                        </div>
                        <div class="form-group">
                            <label for="unifi-site">Site Name</label>
                            <input type="text" id="unifi-site" class="form-control" placeholder="default" value="\${config.site || 'default'}">
                            <small style="color: var(--text-muted);">Usually 'default'</small>
                        </div>
                    \`;
                    break;

                case 'custom':
                    formHTML = \`
                        <div class="form-group">
                            <label for="custom-name">Integration Name</label>
                            <input type="text" id="custom-name" class="form-control" placeholder="My Custom Service" value="\${config.name || ''}">
                        </div>
                        <div class="form-group">
                            <label for="custom-type">Type</label>
                            <select id="custom-type" class="form-control">
                                <option value="rest" \${config.type === 'rest' ? 'selected' : ''}>REST API</option>
                                <option value="webhook" \${config.type === 'webhook' ? 'selected' : ''}>Webhook</option>
                                <option value="graphql" \${config.type === 'graphql' ? 'selected' : ''}>GraphQL</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="custom-url">Base URL</label>
                            <input type="text" id="custom-url" class="form-control" placeholder="https://api.example.com" value="\${config.url || ''}">
                        </div>
                        <div class="form-group">
                            <label for="custom-auth">Authentication Type</label>
                            <select id="custom-auth" class="form-control">
                                <option value="none" \${config.authType === 'none' ? 'selected' : ''}>None</option>
                                <option value="bearer" \${config.authType === 'bearer' ? 'selected' : ''}>Bearer Token</option>
                                <option value="basic" \${config.authType === 'basic' ? 'selected' : ''}>Basic Auth</option>
                                <option value="apikey" \${config.authType === 'apikey' ? 'selected' : ''}>API Key</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="custom-auth-value">Auth Value</label>
                            <input type="password" id="custom-auth-value" class="form-control" placeholder="Token, password, or API key" value="\${config.authValue || ''}">
                        </div>
                        <div class="form-group">
                            <label for="custom-headers">Custom Headers (JSON)</label>
                            <textarea id="custom-headers" class="form-control" rows="3" placeholder='{"X-Custom-Header": "value"}'>\${config.headers ? JSON.stringify(config.headers, null, 2) : ''}</textarea>
                        </div>
                    \`;
                    break;
            }

            formContainer.innerHTML = formHTML;
        }

        async function saveIntegrationConfig() {
            const integrationType = document.getElementById('integration-select').value;
            if (!integrationType) {
                showToast('Please select an integration type', 'error');
                return;
            }

            const enabled = document.getElementById('integration-enabled').checked;
            let configData = {};

            switch(integrationType) {
                case 'mqtt':
                    const topics = document.getElementById('mqtt-topics').value.split(',').map(t => t.trim()).filter(t => t);
                    configData = {
                        broker: document.getElementById('mqtt-broker').value,
                        username: document.getElementById('mqtt-username').value,
                        password: document.getElementById('mqtt-password').value,
                        topics: topics
                    };
                    break;

                case 'websocket':
                    configData = {
                        port: parseInt(document.getElementById('ws-port').value) || 8080
                    };
                    break;

                case 'home_assistant':
                    configData = {
                        url: document.getElementById('ha-url').value,
                        token: document.getElementById('ha-token').value
                    };
                    break;

                case 'pushover':
                    configData = {
                        token: document.getElementById('pushover-token').value,
                        user: document.getElementById('pushover-user').value
                    };
                    break;

                case 'discord':
                    configData = {
                        webhookUrl: document.getElementById('discord-webhook').value
                    };
                    break;

                case 'slack':
                    configData = {
                        webhookUrl: document.getElementById('slack-webhook').value
                    };
                    break;

                case 'telegram':
                    configData = {
                        token: document.getElementById('telegram-token').value,
                        chatId: document.getElementById('telegram-chatid').value
                    };
                    break;

                case 'unifi':
                    configData = {
                        host: document.getElementById('unifi-host').value,
                        username: document.getElementById('unifi-username').value,
                        password: document.getElementById('unifi-password').value,
                        site: document.getElementById('unifi-site').value || 'default'
                    };
                    break;

                case 'custom':
                    let headers = {};
                    try {
                        const headersText = document.getElementById('custom-headers').value.trim();
                        if (headersText) {
                            headers = JSON.parse(headersText);
                        }
                    } catch (e) {
                        showToast('Invalid JSON in custom headers', 'error');
                        return;
                    }
                    
                    configData = {
                        name: document.getElementById('custom-name').value,
                        type: document.getElementById('custom-type').value,
                        url: document.getElementById('custom-url').value,
                        authType: document.getElementById('custom-auth').value,
                        authValue: document.getElementById('custom-auth-value').value,
                        headers: headers
                    };
                    break;
            }

            try {
                const response = await fetch('/api/integrations/configs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        integration_name: integrationType,
                        integration_type: integrationType,
                        enabled: enabled,
                        config_json: JSON.stringify(configData)
                    })
                });

                const result = await response.json();
                
                if (response.ok) {
                    showToast('Integration configured successfully', 'success');
                    closeConfigureModal();
                    loadIntegrations();
                } else {
                    showToast(result.error || 'Failed to save configuration', 'error');
                }
            } catch (error) {
                console.error('Failed to save integration config:', error);
                showToast('Failed to save configuration', 'error');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            setupModalEventListeners();
            loadIntegrations();
            setInterval(loadIntegrations, 60000);
        });

        // Also try immediately in case DOM is already loaded
        if (document.readyState !== 'loading') {
            setupModalEventListeners();
        }
    `;

    res.send(getPageTemplate({
        pageTitle: 'Integration Health',
        pageIcon: 'fas fa-plug',
        activeNav: 'integrations',
        contentBody: pageContent,
        additionalCSS: `
            #integration-modal {
                display: none !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: rgba(0, 0, 0, 0.7) !important;
                backdrop-filter: blur(4px) !important;
                z-index: 99999 !important;
                align-items: center;
                justify-content: center;
            }
            
            #integration-modal.active {
                display: flex !important;
            }
            
            #integration-modal .modal-content {
                background: var(--bg-primary);
                border-radius: 12px;
                padding: 0;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
                max-width: 900px;
                width: 90%;
                max-height: 90vh;
                overflow-y: auto;
                animation: slideUp 0.3s ease;
            }
            
            #integration-modal .modal-header,
            #integration-modal .modal-body,
            #integration-modal .modal-footer {
                padding: 1.5rem 2rem;
            }
            
            #integration-modal .modal-body {
                padding-top: 1rem;
                padding-bottom: 1rem;
            }
            
            /* Responsive breakpoints */
            @media (max-width: 640px) {
                #integration-modal .modal-content {
                    width: 95% !important;
                    max-width: 95% !important;
                    max-height: 95vh !important;
                    border-radius: 8px !important;
                }
            }
            
            @media (min-width: 641px) and (max-width: 1024px) {
                #integration-modal .modal-content {
                    width: 85% !important;
                    max-width: 750px !important;
                }
            }
            
            @media (min-width: 1025px) {
                #integration-modal .modal-content {
                    width: 80% !important;
                    max-width: 1000px !important;
                }
            }
            
            @keyframes slideUp {
                from {
                    opacity: 0;
                    transform: translateY(20px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        `,
        additionalJS: additionalJS,
        req: req
    }));
});

// ============================================================
// ADVANCED SEARCH PAGE
// ============================================================

app.get('/search', requireAuth, (req, res) => {
    const contentBody = `
        <!-- Search Interface -->
        <div style="background: var(--bg-primary); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem; box-shadow: var(--shadow-light); border: 1px solid var(--border-color);">
            <h2 style="margin: 0 0 1.5rem 0; color: var(--text-primary); display: flex; align-items: center; gap: 0.5rem;">
                <i class="fas fa-search"></i> Advanced Log Search
            </h2>
            
            <!-- Search Text Input -->
            <div style="margin-bottom: 1rem;">
                <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-weight: 600;">
                    <i class="fas fa-keyboard"></i> Search Text
                </label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                    <input type="text" id="searchText" placeholder="Search in log messages..." 
                           style="flex: 1; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); font-size: 1rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.75rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color); cursor: pointer;">
                        <input type="checkbox" id="useRegex" style="cursor: pointer;">
                        <span style="color: var(--text-secondary); font-size: 0.9rem;">Regex</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.75rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color); cursor: pointer;">
                        <input type="checkbox" id="caseSensitive" style="cursor: pointer;">
                        <span style="color: var(--text-secondary); font-size: 0.9rem;">Case Sensitive</span>
                    </label>
                </div>
            </div>

            <!-- Date Range -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                <div>
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-weight: 600;">
                        <i class="fas fa-calendar-alt"></i> Start Date
                    </label>
                    <input type="datetime-local" id="startDate" 
                           style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary);">
                </div>
                <div>
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-weight: 600;">
                        <i class="fas fa-calendar-check"></i> End Date
                    </label>
                    <input type="datetime-local" id="endDate" 
                           style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary);">
                </div>
            </div>

            <!-- Multi-select Filters -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                <div>
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-weight: 600;">
                        <i class="fas fa-layer-group"></i> Log Levels
                    </label>
                    <select id="levelsFilter" multiple 
                            style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); min-height: 80px;">
                        <!-- Populated by JS -->
                    </select>
                </div>
                <div>
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-weight: 600;">
                        <i class="fas fa-server"></i> Sources
                    </label>
                    <select id="sourcesFilter" multiple 
                            style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); min-height: 80px;">
                        <!-- Populated by JS -->
                    </select>
                </div>
                <div>
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-weight: 600;">
                        <i class="fas fa-tags"></i> Categories
                    </label>
                    <select id="categoriesFilter" multiple 
                            style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); min-height: 80px;">
                        <!-- Populated by JS -->
                    </select>
                </div>
            </div>

            <!-- Action Buttons -->
            <div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
                <button onclick="performSearch()" class="btn" style="background: var(--gradient-ocean); padding: 0.75rem 1.5rem;">
                    <i class="fas fa-search"></i> Search
                </button>
                <button onclick="clearSearch()" class="btn" style="background: var(--bg-secondary); color: var(--text-primary); padding: 0.75rem 1.5rem;">
                    <i class="fas fa-times"></i> Clear
                </button>
                <button onclick="saveSearch()" class="btn" style="background: var(--success-color); padding: 0.75rem 1.5rem;">
                    <i class="fas fa-save"></i> Save Search
                </button>
                <button onclick="loadSavedSearches()" class="btn" style="background: var(--info-color); padding: 0.75rem 1.5rem;">
                    <i class="fas fa-folder-open"></i> Load Saved
                </button>
            </div>
        </div>

        <!-- Saved Searches -->
        <div id="savedSearchesPanel" style="display: none; background: var(--bg-primary); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem; box-shadow: var(--shadow-light); border: 1px solid var(--border-color);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h3 style="margin: 0; color: var(--text-primary);">
                    <i class="fas fa-bookmark"></i> Saved Searches
                </h3>
                <button onclick="closeSavedSearches()" class="btn" style="padding: 0.5rem 1rem; background: var(--bg-secondary); color: var(--text-primary);">
                    <i class="fas fa-times"></i> Close
                </button>
            </div>
            <div id="savedSearchesList" style="display: flex; flex-direction: column; gap: 0.5rem;">
                <!-- Populated by JS -->
            </div>
        </div>

        <!-- Search Results -->
        <div style="background: var(--bg-primary); border-radius: 12px; padding: 1.5rem; box-shadow: var(--shadow-light); border: 1px solid var(--border-color);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h2 style="margin: 0; color: var(--text-primary);">
                    <i class="fas fa-list"></i> Search Results <span id="resultCount" style="color: var(--text-secondary); font-size: 0.9em;"></span>
                </h2>
                <div style="display: flex; gap: 0.5rem;">
                    <button onclick="exportResults()" class="btn" style="padding: 0.5rem 1rem; background: var(--accent-primary);">
                        <i class="fas fa-download"></i> Export
                    </button>
                </div>
            </div>
            
            <div id="searchResults" style="overflow-x: auto;">
                <div style="text-align: center; padding: 3rem; color: var(--text-secondary);">
                    <i class="fas fa-search" style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;"></i>
                    <p>Configure your search criteria and click Search to view results</p>
                </div>
            </div>
        </div>
    `;

    const additionalJS = `
        let filterOptions = { levels: [], sources: [], categories: [] };
        let currentResults = [];

        // Load filter options on page load
        async function loadFilterOptions() {
            try {
                const response = await fetch('/api/logs/filter-options');
                filterOptions = await response.json();
                
                // Populate selects
                const levelsSelect = document.getElementById('levelsFilter');
                const sourcesSelect = document.getElementById('sourcesFilter');
                const categoriesSelect = document.getElementById('categoriesFilter');
                
                filterOptions.levels.forEach(level => {
                    const option = document.createElement('option');
                    option.value = level;
                    option.textContent = level;
                    levelsSelect.appendChild(option);
                });
                
                filterOptions.sources.forEach(source => {
                    const option = document.createElement('option');
                    option.value = source;
                    option.textContent = source;
                    sourcesSelect.appendChild(option);
                });
                
                filterOptions.categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    categoriesSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Error loading filter options:', error);
            }
        }

        async function performSearch() {
            const searchText = document.getElementById('searchText').value;
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            const useRegex = document.getElementById('useRegex').checked;
            const caseSensitive = document.getElementById('caseSensitive').checked;
            
            const levelsSelect = document.getElementById('levelsFilter');
            const sourcesSelect = document.getElementById('sourcesFilter');
            const categoriesSelect = document.getElementById('categoriesFilter');
            
            const levels = Array.from(levelsSelect.selectedOptions).map(opt => opt.value);
            const sources = Array.from(sourcesSelect.selectedOptions).map(opt => opt.value);
            const categories = Array.from(categoriesSelect.selectedOptions).map(opt => opt.value);
            
            try {
                const response = await fetch('/api/logs/search', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        searchText,
                        startDate: startDate || null,
                        endDate: endDate || null,
                        levels,
                        sources,
                        categories,
                        useRegex,
                        caseSensitive,
                        limit: 1000
                    })
                });
                
                const data = await response.json();
                currentResults = data.results;
                displayResults(data.results);
                document.getElementById('resultCount').textContent = \`(\${data.count} results)\`;
            } catch (error) {
                console.error('Search error:', error);
                showNotification('Search failed', 'error');
            }
        }

        function displayResults(results) {
            const container = document.getElementById('searchResults');
            
            if (results.length === 0) {
                container.innerHTML = \`
                    <div style="text-align: center; padding: 3rem; color: var(--text-secondary);">
                        <i class="fas fa-inbox" style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;"></i>
                        <p>No results found matching your search criteria</p>
                    </div>
                \`;
                return;
            }
            
            let html = \`
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: var(--bg-secondary); border-bottom: 2px solid var(--border-color);">
                            <th style="padding: 0.75rem; text-align: left; color: var(--text-secondary); font-weight: 600;">Time</th>
                            <th style="padding: 0.75rem; text-align: left; color: var(--text-secondary); font-weight: 600;">Level</th>
                            <th style="padding: 0.75rem; text-align: left; color: var(--text-secondary); font-weight: 600;">Source</th>
                            <th style="padding: 0.75rem; text-align: left; color: var(--text-secondary); font-weight: 600;">Category</th>
                            <th style="padding: 0.75rem; text-align: left; color: var(--text-secondary); font-weight: 600;">Message</th>
                        </tr>
                    </thead>
                    <tbody>
            \`;
            
            results.forEach(log => {
                const levelColor = {
                    'CRITICAL': 'var(--error-color)',
                    'ERROR': 'var(--error-color)',
                    'WARNING': 'var(--warning-color)',
                    'INFO': 'var(--info-color)',
                    'DEBUG': 'var(--text-secondary)'
                }[log.severity] || 'var(--text-primary)';
                
                html += \`
                    <tr style="border-bottom: 1px solid var(--border-color); transition: background 0.2s ease;">
                        <td style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.9rem; white-space: nowrap;">\${log.timestamp || ''}</td>
                        <td style="padding: 0.75rem;">
                            <span style="padding: 0.25rem 0.75rem; border-radius: 6px; font-size: 0.85rem; font-weight: 600; background: \${levelColor}20; color: \${levelColor};">
                                \${log.severity || 'N/A'}
                            </span>
                        </td>
                        <td style="padding: 0.75rem; color: var(--text-primary); font-size: 0.9rem;">\${log.source || 'N/A'}</td>
                        <td style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.9rem;">\${log.category || 'N/A'}</td>
                        <td style="padding: 0.75rem; color: var(--text-primary); font-size: 0.9rem; max-width: 400px; overflow: hidden; text-overflow: ellipsis;">\${log.message || ''}</td>
                    </tr>
                \`;
            });
            
            html += \`
                    </tbody>
                </table>
            \`;
            
            container.innerHTML = html;
        }

        function clearSearch() {
            document.getElementById('searchText').value = '';
            document.getElementById('startDate').value = '';
            document.getElementById('endDate').value = '';
            document.getElementById('useRegex').checked = false;
            document.getElementById('caseSensitive').checked = false;
            document.getElementById('levelsFilter').selectedIndex = -1;
            document.getElementById('sourcesFilter').selectedIndex = -1;
            document.getElementById('categoriesFilter').selectedIndex = -1;
            document.getElementById('searchResults').innerHTML = \`
                <div style="text-align: center; padding: 3rem; color: var(--text-secondary);">
                    <i class="fas fa-search" style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;"></i>
                    <p>Configure your search criteria and click Search to view results</p>
                </div>
            \`;
            document.getElementById('resultCount').textContent = '';
        }

        async function saveSearch() {
            const name = prompt('Enter a name for this search:');
            if (!name) return;
            
            const description = prompt('Enter a description (optional):') || '';
            
            const filters = {
                searchText: document.getElementById('searchText').value,
                startDate: document.getElementById('startDate').value,
                endDate: document.getElementById('endDate').value,
                useRegex: document.getElementById('useRegex').checked,
                caseSensitive: document.getElementById('caseSensitive').checked,
                levels: Array.from(document.getElementById('levelsFilter').selectedOptions).map(opt => opt.value),
                sources: Array.from(document.getElementById('sourcesFilter').selectedOptions).map(opt => opt.value),
                categories: Array.from(document.getElementById('categoriesFilter').selectedOptions).map(opt => opt.value)
            };
            
            try {
                const response = await fetch('/api/saved-searches', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, description, filters })
                });
                
                if (response.ok) {
                    showNotification('Search saved successfully', 'success');
                } else {
                    showNotification('Failed to save search', 'error');
                }
            } catch (error) {
                console.error('Error saving search:', error);
                showNotification('Failed to save search', 'error');
            }
        }

        async function loadSavedSearches() {
            try {
                const response = await fetch('/api/saved-searches');
                const searches = await response.json();
                
                const panel = document.getElementById('savedSearchesPanel');
                const list = document.getElementById('savedSearchesList');
                
                if (searches.length === 0) {
                    list.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 2rem;">No saved searches yet</p>';
                } else {
                    list.innerHTML = searches.map(search => \`
                        <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong style="color: var(--text-primary);">\${search.name}</strong>
                                <p style="margin: 0.25rem 0 0 0; color: var(--text-secondary); font-size: 0.9rem;">\${search.description || 'No description'}</p>
                            </div>
                            <div style="display: flex; gap: 0.5rem;">
                                <button onclick="applySearch(\${search.id})" class="btn" style="padding: 0.5rem 1rem; background: var(--accent-primary);">
                                    <i class="fas fa-play"></i> Apply
                                </button>
                                <button onclick="deleteSearch(\${search.id})" class="btn" style="padding: 0.5rem 1rem; background: var(--error-color);">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    \`).join('');
                }
                
                panel.style.display = 'block';
            } catch (error) {
                console.error('Error loading saved searches:', error);
                showNotification('Failed to load saved searches', 'error');
            }
        }

        function closeSavedSearches() {
            document.getElementById('savedSearchesPanel').style.display = 'none';
        }

        async function applySearch(searchId) {
            try {
                const response = await fetch('/api/saved-searches');
                const searches = await response.json();
                const search = searches.find(s => s.id === searchId);
                
                if (!search) return;
                
                // Apply filters to form
                const filters = search.filters;
                document.getElementById('searchText').value = filters.searchText || '';
                document.getElementById('startDate').value = filters.startDate || '';
                document.getElementById('endDate').value = filters.endDate || '';
                document.getElementById('useRegex').checked = filters.useRegex || false;
                document.getElementById('caseSensitive').checked = filters.caseSensitive || false;
                
                // Select options
                const levelsSelect = document.getElementById('levelsFilter');
                const sourcesSelect = document.getElementById('sourcesFilter');
                const categoriesSelect = document.getElementById('categoriesFilter');
                
                Array.from(levelsSelect.options).forEach(opt => opt.selected = filters.levels.includes(opt.value));
                Array.from(sourcesSelect.options).forEach(opt => opt.selected = filters.sources.includes(opt.value));
                Array.from(categoriesSelect.options).forEach(opt => opt.selected = filters.categories.includes(opt.value));
                
                closeSavedSearches();
                
                // Track usage
                await fetch(\`/api/saved-searches/\${searchId}/use\`, { method: 'POST' });
                
                // Perform search
                performSearch();
            } catch (error) {
                console.error('Error applying search:', error);
                showNotification('Failed to apply search', 'error');
            }
        }

        async function deleteSearch(searchId) {
            if (!confirm('Delete this saved search?')) return;
            
            try {
                const response = await fetch(\`/api/saved-searches/\${searchId}\`, { method: 'DELETE' });
                if (response.ok) {
                    showNotification('Search deleted', 'success');
                    loadSavedSearches();
                } else {
                    showNotification('Failed to delete search', 'error');
                }
            } catch (error) {
                console.error('Error deleting search:', error);
                showNotification('Failed to delete search', 'error');
            }
        }

        function exportResults() {
            if (currentResults.length === 0) {
                showNotification('No results to export', 'warning');
                return;
            }
            
            const csv = [
                ['Timestamp', 'Level', 'Source', 'Category', 'Message'].join(','),
                ...currentResults.map(log => [
                    log.timestamp || '',
                    log.severity || '',
                    log.source || '',
                    log.category || '',
                    (log.message || '').replace(/"/g, '""')
                ].map(v => \`"\${v}"\`).join(','))
            ].join('\\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = \`search-results-\${new Date().toISOString().split('T')[0]}.csv\`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification('Results exported successfully', 'success');
        }

        // Initialize
        loadFilterOptions();
    `;

    res.send(getPageTemplate({
        pageTitle: 'Advanced Search',
        pageIcon: 'fas fa-search',
        activeNav: 'search',
        contentBody: contentBody,
        additionalCSS: '',
        additionalJS: additionalJS,
        req: req
    }));
});

// Admin Settings page
app.get('/admin/settings', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).send(getPageTemplate({
            pageTitle: 'Access Denied',
            pageIcon: 'fas fa-ban',
            activeNav: '',
            contentBody: '<div class="card"><div class="card-body"><h2 style="color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i> Access Denied</h2><p>Admin privileges required to access this page.</p><a href="/dashboard" class="btn"><i class="fas fa-arrow-left"></i> Return to Dashboard</a></div></div>',
            additionalCSS: '',
            additionalJS: '',
            req: req
        }));
    }
    
    const additionalCSS = `
        .tab-button.active {
            color: var(--accent-primary) !important;
            border-bottom-color: var(--accent-primary) !important;
        }
        .tab-button:hover {
            color: var(--accent-primary);
            background: var(--bg-secondary);
        }
        .tab-content {
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .settings-grid {
            display: grid;
            gap: 1.5rem;
        }
        .setting-item {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 1rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            align-items: center;
        }
        .setting-label {
            font-weight: 600;
            color: var(--text-primary);
        }
        .setting-label i {
            margin-right: 0.5rem;
            color: var(--accent-primary);
        }
        .setting-description {
            font-size: 0.875rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }
        .setting-control {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .setting-control input,
        .setting-control select {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        .setting-control input[type="checkbox"] {
            flex: none;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .setting-readonly {
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            color: var(--text-muted);
            font-family: 'Courier New', monospace;
        }
        .tab-btn { transition: all 0.3s ease; }
        .tab-btn:hover { transform: translateY(-2px); box-shadow: var(--shadow-light); }
        .tab-btn.active { background: var(--gradient-ocean) !important; color: white !important; }
        .save-btn {
            position: sticky;
            bottom: 1rem;
            z-index: 10;
        }
        .section-header {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            margin: 1.5rem 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }
        .section-header i {
            margin-right: 0.5rem;
            color: var(--accent-primary);
        }
    `;

    const contentBody = `
        <!-- Tab Navigation -->
        <div style="background: var(--bg-primary); border-radius: 12px; padding: 1rem; margin-bottom: 1.5rem; box-shadow: var(--shadow-light); border: 1px solid var(--border-color);">
            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                <button onclick="switchTab('settings')" id="tab-settings" class="tab-btn active" style="padding: 0.75rem 1.5rem; border: none; background: var(--gradient-ocean); color: white; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-cog"></i> Settings
                </button>
                <button onclick="switchTab('api-keys')" id="tab-api-keys" class="tab-btn" style="padding: 0.75rem 1.5rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-key"></i> API Keys
                </button>
                <button onclick="switchTab('backups')" id="tab-backups" class="tab-btn" style="padding: 0.75rem 1.5rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-database"></i> Backups
                </button>
                <button onclick="switchTab('metrics')" id="tab-metrics" class="tab-btn" style="padding: 0.75rem 1.5rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-heartbeat"></i> System Metrics
                </button>
                <button onclick="switchTab('appearance')" id="tab-appearance" class="tab-btn" style="padding: 0.75rem 1.5rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-palette"></i> Appearance
                </button>
                <button onclick="switchTab('import-export')" id="tab-import-export" class="tab-btn" style="padding: 0.75rem 1.5rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-file-import"></i> Import/Export
                </button>
            </div>
        </div>

        <!-- API Keys Tab Content -->
        <div id="content-api-keys" class="tab-content" style="display: none;">
            <div class="card">
                <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <h3><i class="fas fa-key"></i> API Key Management</h3>
                    <button onclick="showCreateAPIKeyModal()" class="btn" style="background: var(--success-color);">
                        <i class="fas fa-plus"></i> Generate New Key
                    </button>
                </div>
                <div class="card-body">
                    <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                        API keys allow external applications to authenticate with the logging server. Keep your keys secure!
                    </p>
                    <div id="apiKeysContainer">
                        <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                            <i class="fas fa-spinner fa-spin" style="font-size: 2rem;"></i>
                            <p style="margin-top: 1rem;">Loading API keys...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Tab Content -->
        <div id="content-settings" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-cog"></i> System Settings</h3>
                    <button onclick="loadSettings()" class="btn">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                </div>
                <div class="card-body">
                    <div id="settings-content">
                        <p style="text-align: center; color: var(--text-muted); padding: 2rem;">
                            <i class="fas fa-spinner fa-spin" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                            <br>Loading system settings...
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Backups Tab Content -->
        <div id="content-backups" class="tab-content" style="display: none;">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-database"></i> Database Backups</h3>
                    <button onclick="createBackup()" class="btn">
                        <i class="fas fa-plus"></i> Create Backup
                    </button>
                </div>
                <div class="card-body">
                    <div id="backups-content">
                        <p style="text-align: center; color: var(--text-muted); padding: 2rem;">
                            <i class="fas fa-spinner fa-spin" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                            <br>Loading backups...
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Metrics Tab Content -->
        <div id="content-metrics" class="tab-content" style="display: none;">
            <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
            
            <div style="display: grid; grid-template-columns: 320px 1fr; gap: 1.25rem;">
                <!-- Stats Table -->
                <div class="card">
                    <div class="card-header">
                        <h3><i class="fas fa-chart-bar"></i> Current Stats</h3>
                    </div>
                    <div style="padding: 1.5rem;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <tbody>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 1rem 0; color: var(--text-muted);">
                                        <i class="fas fa-memory" style="color: #10b981; margin-right: 0.5rem; width: 20px;"></i>
                                        Memory Usage
                                    </td>
                                    <td style="padding: 1rem 0; text-align: right;">
                                        <div style="font-weight: 600; font-size: 1.1rem;" id="metrics-current-memory">-- MB</div>
                                        <div style="font-size: 0.75rem; color: var(--text-muted);"><span id="metrics-memory-percent">--</span>% of heap</div>
                                    </td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 1rem 0; color: var(--text-muted);">
                                        <i class="fas fa-microchip" style="color: #3b82f6; margin-right: 0.5rem; width: 20px;"></i>
                                        CPU Usage
                                    </td>
                                    <td style="padding: 1rem 0; text-align: right;">
                                        <div style="font-weight: 600; font-size: 1.1rem;" id="metrics-current-cpu">--%</div>
                                        <div style="font-size: 0.75rem; color: var(--text-muted);">Process load</div>
                                    </td>
                                </tr>
                                <tr style="border-bottom: 1px solid var(--border-color);">
                                    <td style="padding: 1rem 0; color: var(--text-muted);">
                                        <i class="fas fa-clock" style="color: #f59e0b; margin-right: 0.5rem; width: 20px;"></i>
                                        Server Uptime
                                    </td>
                                    <td style="padding: 1rem 0; text-align: right;">
                                        <div style="font-weight: 600; font-size: 1.1rem;" id="metrics-server-uptime">--</div>
                                        <div style="font-size: 0.75rem; color: #10b981;"><i class="fas fa-circle" style="font-size: 0.4rem;"></i> Online</div>
                                    </td>
                                </tr>
                                <tr>
                                    <td style="padding: 1rem 0; color: var(--text-muted);">
                                        <i class="fas fa-exchange-alt" style="color: #8b5cf6; margin-right: 0.5rem; width: 20px;"></i>
                                        Total Requests
                                    </td>
                                    <td style="padding: 1rem 0; text-align: right;">
                                        <div style="font-weight: 600; font-size: 1.1rem;" id="metrics-request-total">--</div>
                                        <div style="font-size: 0.75rem; color: var(--text-muted);"><span id="metrics-request-rate">--</span>/min</div>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Charts Column -->
                <div style="display: flex; flex-direction: column; gap: 1.25rem;">
                    <!-- Memory Chart -->
                    <div class="card">
                        <div class="card-header">
                            <h3><i class="fas fa-memory"></i> Memory Usage</h3>
                        </div>
                        <div style="padding: 1.5rem; height: 200px;">
                            <canvas id="metrics-memory-chart"></canvas>
                        </div>
                    </div>

                    <!-- CPU Chart -->
                    <div class="card">
                        <div class="card-header">
                            <h3><i class="fas fa-microchip"></i> CPU Usage</h3>
                        </div>
                        <div style="padding: 1.5rem; height: 200px;">
                            <canvas id="metrics-cpu-chart"></canvas>
                        </div>
                    </div>

                    <!-- Memory Breakdown -->
                    <div class="card">
                        <div class="card-header">
                            <h3><i class="fas fa-server"></i> Memory Breakdown</h3>
                        </div>
                        <div style="padding: 1.5rem;">
                            <div style="margin-bottom: 1.25rem;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.875rem;">
                                    <span style="color: var(--text-muted);">Heap Used</span>
                                    <span id="metrics-heap-used" style="font-weight: 600;">-- MB</span>
                                </div>
                                <div style="background: var(--bg-secondary); height: 8px; border-radius: 4px; overflow: hidden;">
                                    <div id="metrics-heap-bar" style="background: linear-gradient(90deg, #10b981, #059669); height: 100%; width: 0%; transition: width 0.3s;"></div>
                                </div>
                            </div>
                            <div style="margin-bottom: 1.25rem;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.875rem;">
                                    <span style="color: var(--text-muted);">Heap Total</span>
                                    <span id="metrics-heap-total" style="font-weight: 600;">-- MB</span>
                                </div>
                                <div style="background: var(--bg-secondary); height: 8px; border-radius: 4px; overflow: hidden;">
                                    <div id="metrics-heap-total-bar" style="background: linear-gradient(90deg, #3b82f6, #2563eb); height: 100%; width: 0%; transition: width 0.3s;"></div>
                                </div>
                            </div>
                            <div style="margin-bottom: 1.25rem;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.875rem;">
                                    <span style="color: var(--text-muted);">RSS (Resident Set)</span>
                                    <span id="metrics-rss" style="font-weight: 600;">-- MB</span>
                                </div>
                                <div style="background: var(--bg-secondary); height: 8px; border-radius: 4px; overflow: hidden;">
                                    <div id="metrics-rss-bar" style="background: linear-gradient(90deg, #f59e0b, #d97706); height: 100%; width: 0%; transition: width 0.3s;"></div>
                                </div>
                            </div>
                            <div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.875rem;">
                                    <span style="color: var(--text-muted);">External Memory</span>
                                    <span id="metrics-external-mem" style="font-weight: 600;">-- MB</span>
                                </div>
                                <div style="background: var(--bg-secondary); height: 8px; border-radius: 4px; overflow: hidden;">
                                    <div id="metrics-external-bar" style="background: linear-gradient(90deg, #8b5cf6, #7c3aed); height: 100%; width: 0%; transition: width 0.3s;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Appearance Tab Content -->
        <div id="content-appearance" class="tab-content" style="display: none;">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-palette"></i> Theme Customization</h3>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="saveTheme()" class="btn">
                            <i class="fas fa-save"></i> Save Theme
                        </button>
                        <button onclick="resetTheme()" class="btn" style="background: var(--error-color);">
                            <i class="fas fa-undo"></i> Reset to Default
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <!-- Left Column: Controls -->
                        <div>
                            <!-- Gradient Editor Section -->
                            <div class="section-header">
                                <i class="fas fa-fill-drip"></i> Button Gradient
                            </div>
                            
                            <div style="margin-bottom: 1.5rem; padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px;">
                                <!-- Gradient Type -->
                                <div style="margin-bottom: 1rem;">
                                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-primary);">
                                        Gradient Type
                                    </label>
                                    <select id="gradient-type" onchange="updateGradientPreview()" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                                        <option value="linear">Linear</option>
                                        <option value="radial">Radial</option>
                                    </select>
                                </div>
                                
                                <!-- Gradient Angle (only for linear) -->
                                <div id="gradient-angle-container" style="margin-bottom: 1rem;">
                                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-primary);">
                                        Angle: <span id="angle-value">135</span>¬∞
                                    </label>
                                    <input type="range" id="gradient-angle" min="0" max="360" value="135" oninput="updateAngleDisplay(); updateGradientPreview();" style="width: 100%; cursor: pointer;">
                                </div>
                                
                                <!-- Gradient Stops -->
                                <div style="margin-bottom: 1rem;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                        <label style="font-weight: 600; color: var(--text-primary);">
                                            Gradient Stops
                                        </label>
                                        <button onclick="addGradientStop()" class="btn" style="padding: 0.4rem 0.8rem; font-size: 0.875rem;">
                                            <i class="fas fa-plus"></i> Add Stop
                                        </button>
                                    </div>
                                    <div id="gradient-stops-container" style="display: flex; flex-direction: column; gap: 0.75rem;">
                                        <!-- Gradient stops will be added here dynamically -->
                                    </div>
                                </div>
                                
                                <!-- Live Gradient Preview -->
                                <div style="margin-top: 1rem;">
                                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-primary);">
                                        Preview
                                    </label>
                                    <div id="gradient-preview" style="height: 50px; border-radius: 8px; background: linear-gradient(135deg, #0ea5e9 0%, #3b82f6 50%, #6366f1 100%);"></div>
                                </div>
                            </div>
                            
                            <!-- Color Pickers Section -->
                            <div class="section-header">
                                <i class="fas fa-palette"></i> Color Scheme
                            </div>
                            
                            <div style="display: grid; gap: 1rem;">
                                <!-- Background Colors -->
                                <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px;">
                                    <h4 style="margin: 0 0 1rem 0; color: var(--text-primary); font-size: 1rem;">
                                        <i class="fas fa-window-maximize" style="color: var(--accent-primary); margin-right: 0.5rem;"></i>
                                        Background Colors
                                    </h4>
                                    <div style="display: grid; gap: 0.75rem;">
                                        <div style="display: flex; align-items: center; gap: 1rem;">
                                            <input type="color" id="color-bg-primary" value="#ffffff" onchange="updateColorPreview()" style="width: 50px; height: 40px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 600; color: var(--text-primary);">Primary Background</div>
                                                <div style="font-size: 0.75rem; color: var(--text-muted);">Main content areas</div>
                                            </div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 1rem;">
                                            <input type="color" id="color-bg-secondary" value="#f8fafc" onchange="updateColorPreview()" style="width: 50px; height: 40px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 600; color: var(--text-primary);">Secondary Background</div>
                                                <div style="font-size: 0.75rem; color: var(--text-muted);">Panels and cards</div>
                                            </div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 1rem;">
                                            <input type="color" id="color-bg-tertiary" value="#f1f5f9" onchange="updateColorPreview()" style="width: 50px; height: 40px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 600; color: var(--text-primary);">Tertiary Background</div>
                                                <div style="font-size: 0.75rem; color: var(--text-muted);">Subtle elements</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Text Colors -->
                                <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px;">
                                    <h4 style="margin: 0 0 1rem 0; color: var(--text-primary); font-size: 1rem;">
                                        <i class="fas fa-font" style="color: var(--accent-primary); margin-right: 0.5rem;"></i>
                                        Text Colors
                                    </h4>
                                    <div style="display: grid; gap: 0.75rem;">
                                        <div style="display: flex; align-items: center; gap: 1rem;">
                                            <input type="color" id="color-text-primary" value="#1e293b" onchange="updateColorPreview()" style="width: 50px; height: 40px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 600; color: var(--text-primary);">Primary Text</div>
                                                <div style="font-size: 0.75rem; color: var(--text-muted);">Main content text</div>
                                            </div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 1rem;">
                                            <input type="color" id="color-text-secondary" value="#475569" onchange="updateColorPreview()" style="width: 50px; height: 40px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 600; color: var(--text-primary);">Secondary Text</div>
                                                <div style="font-size: 0.75rem; color: var(--text-muted);">Subtitles and labels</div>
                                            </div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 1rem;">
                                            <input type="color" id="color-text-muted" value="#64748b" onchange="updateColorPreview()" style="width: 50px; height: 40px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="flex: 1;">
                                                <div style="font-weight: 600; color: var(--text-primary);">Muted Text</div>
                                                <div style="font-size: 0.75rem; color: var(--text-muted);">Hints and placeholders</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Accent & Status Colors -->
                                <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px;">
                                    <h4 style="margin: 0 0 1rem 0; color: var(--text-primary); font-size: 1rem;">
                                        <i class="fas fa-star" style="color: var(--accent-primary); margin-right: 0.5rem;"></i>
                                        Accent & Status Colors
                                    </h4>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                                            <input type="color" id="color-border" value="#e2e8f0" onchange="updateColorPreview()" style="width: 40px; height: 35px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">Border</div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                                            <input type="color" id="color-accent-primary" value="#3b82f6" onchange="updateColorPreview()" style="width: 40px; height: 35px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">Accent Primary</div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                                            <input type="color" id="color-accent-secondary" value="#1d4ed8" onchange="updateColorPreview()" style="width: 40px; height: 35px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">Accent Secondary</div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                                            <input type="color" id="color-success" value="#10b981" onchange="updateColorPreview()" style="width: 40px; height: 35px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">Success</div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                                            <input type="color" id="color-warning" value="#f59e0b" onchange="updateColorPreview()" style="width: 40px; height: 35px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">Warning</div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                                            <input type="color" id="color-error" value="#ef4444" onchange="updateColorPreview()" style="width: 40px; height: 35px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">Error</div>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                                            <input type="color" id="color-info" value="#3b82f6" onchange="updateColorPreview()" style="width: 40px; height: 35px; border: none; border-radius: 6px; cursor: pointer;">
                                            <div style="font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">Info</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Right Column: Live Preview -->
                        <div>
                            <div class="section-header">
                                <i class="fas fa-eye"></i> Live Preview
                            </div>
                            
                            <div id="theme-preview-container" style="padding: 1.5rem; background: var(--bg-primary); border: 2px solid var(--border-color); border-radius: 8px;">
                                <!-- Sample Card -->
                                <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem;">
                                    <h3 style="margin: 0 0 0.5rem 0; color: var(--text-primary);">Sample Card</h3>
                                    <p style="margin: 0 0 1rem 0; color: var(--text-secondary);">This is how your content will look with the new theme.</p>
                                    <p style="margin: 0; color: var(--text-muted); font-size: 0.875rem;">Subtle text and hints appear like this.</p>
                                </div>
                                
                                <!-- Sample Buttons -->
                                <div style="margin-bottom: 1.5rem;">
                                    <button class="btn" style="margin-right: 0.5rem; margin-bottom: 0.5rem;">
                                        <i class="fas fa-check"></i> Primary Button
                                    </button>
                                    <button style="padding: 0.75rem 1.5rem; border: 1px solid var(--border-color); background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; cursor: pointer; margin-right: 0.5rem; margin-bottom: 0.5rem;">
                                        Secondary Button
                                    </button>
                                </div>
                                
                                <!-- Status Messages -->
                                <div style="display: grid; gap: 0.75rem;">
                                    <div style="padding: 0.75rem; background: var(--success-color); color: white; border-radius: 6px; font-size: 0.875rem;">
                                        <i class="fas fa-check-circle"></i> Success message example
                                    </div>
                                    <div style="padding: 0.75rem; background: var(--warning-color); color: white; border-radius: 6px; font-size: 0.875rem;">
                                        <i class="fas fa-exclamation-triangle"></i> Warning message example
                                    </div>
                                    <div style="padding: 0.75rem; background: var(--error-color); color: white; border-radius: 6px; font-size: 0.875rem;">
                                        <i class="fas fa-times-circle"></i> Error message example
                                    </div>
                                    <div style="padding: 0.75rem; background: var(--info-color); color: white; border-radius: 6px; font-size: 0.875rem;">
                                        <i class="fas fa-info-circle"></i> Info message example
                                    </div>
                                </div>
                                
                                <!-- Sample Form Elements -->
                                <div style="margin-top: 1.5rem;">
                                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-primary);">
                                        Sample Input Field
                                    </label>
                                    <input type="text" placeholder="Enter text here..." style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Import/Export Tab Content -->
        <div id="content-import-export" class="tab-content" style="display: none;">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-file-import"></i> Import/Export Settings</h3>
                </div>
                <div class="card-body">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
                        <!-- Export Section -->
                        <div>
                            <div class="section-header">
                                <i class="fas fa-download"></i> Export Settings
                            </div>
                            <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px;">
                                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                                    Export all system settings, configurations, and integration settings to a JSON file.
                                    This file can be used to backup your configuration or migrate settings to another system.
                                </p>
                                <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 6px; border-left: 4px solid var(--info-color); margin-bottom: 1.5rem;">
                                    <strong style="color: var(--text-primary);">Export includes:</strong>
                                    <ul style="margin: 0.5rem 0 0 1.5rem; color: var(--text-secondary);">
                                        <li>System settings</li>
                                        <li>Integration configurations</li>
                                        <li>Maintenance schedules</li>
                                        <li>Theme preferences (excluding passwords/tokens)</li>
                                    </ul>
                                </div>
                                <button onclick="exportSettings()" class="btn" style="width: 100%;">
                                    <i class="fas fa-download"></i> Download Settings
                                </button>
                            </div>
                        </div>

                        <!-- Import Section -->
                        <div>
                            <div class="section-header">
                                <i class="fas fa-upload"></i> Import Settings
                            </div>
                            <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px;">
                                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                                    Import settings from a previously exported JSON file. This will replace your current settings.
                                </p>
                                <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 6px; border-left: 4px solid var(--warning-color); margin-bottom: 1.5rem;">
                                    <strong style="color: var(--warning-color);"><i class="fas fa-exclamation-triangle"></i> Warning:</strong>
                                    <p style="margin: 0.5rem 0 0 0; color: var(--text-secondary); font-size: 0.875rem;">
                                        Importing settings will overwrite your current configuration. 
                                        It's recommended to export your current settings first as a backup.
                                        Server may require restart after import.
                                    </p>
                                </div>
                                <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="handleFileSelect(event)">
                                <button onclick="document.getElementById('import-file-input').click()" class="btn" style="width: 100%; background: var(--warning-color);">
                                    <i class="fas fa-upload"></i> Upload Settings File
                                </button>
                                <div id="import-status" style="margin-top: 1rem; display: none;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Import Preview Section -->
                    <div id="import-preview" style="display: none; margin-top: 2rem;">
                        <div class="section-header">
                            <i class="fas fa-eye"></i> Import Preview
                        </div>
                        <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                                <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 6px;">
                                    <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.25rem;">File Version</div>
                                    <div style="font-size: 1.25rem; font-weight: 600; color: var(--text-primary);" id="preview-version">-</div>
                                </div>
                                <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 6px;">
                                    <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.25rem;">Settings Count</div>
                                    <div style="font-size: 1.25rem; font-weight: 600; color: var(--text-primary);" id="preview-count">-</div>
                                </div>
                            </div>
                            <div style="margin-bottom: 1.5rem;">
                                <pre id="preview-json" style="background: var(--bg-primary); padding: 1rem; border-radius: 6px; border: 1px solid var(--border-color); max-height: 300px; overflow-y: auto; font-size: 0.875rem; color: var(--text-primary);"></pre>
                            </div>
                            <div style="display: flex; gap: 1rem;">
                                <button onclick="confirmImport()" class="btn" style="flex: 1; background: var(--success-color);">
                                    <i class="fas fa-check"></i> Confirm Import
                                </button>
                                <button onclick="cancelImport()" class="btn" style="flex: 1; background: var(--error-color);">
                                    <i class="fas fa-times"></i> Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;

    const additionalJS = `
        let currentSettings = {};
        let metricsInterval;

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.style.display = 'none');
            document.querySelectorAll('.tab-btn').forEach(btn => { 
                btn.classList.remove('active'); 
                btn.style.background = 'var(--bg-secondary)'; 
                btn.style.color = 'var(--text-primary)'; 
            });
            
            document.getElementById('content-' + tabName).style.display = 'block';
            const activeBtn = document.getElementById('tab-' + tabName);
            activeBtn.classList.add('active');
            activeBtn.style.background = 'var(--gradient-ocean)';
            activeBtn.style.color = 'white';
            
            // Clear metrics interval when switching away
            if (metricsInterval) {
                clearInterval(metricsInterval);
                metricsInterval = null;
            }
            
            if (tabName === 'settings') {
                loadSettings();
            } else if (tabName === 'api-keys') {
                loadAPIKeys();
            } else if (tabName === 'backups') {
                loadBackups();
            } else if (tabName === 'metrics') {
                refreshMetrics();
                // Auto-refresh metrics every 5 seconds
                metricsInterval = setInterval(fetchSystemMetrics, 5000);
            } else if (tabName === 'appearance') {
                loadThemeSettings();
            } else if (tabName === 'import-export') {
                // Import/Export tab loaded
            }
        }

        async function loadBackups() {
            try {
                const response = await fetch('/api/backups');
                if (!response.ok) throw new Error('Failed to fetch backups');
                
                const data = await response.json();
                renderBackups(data);
            } catch (error) {
                console.error('Error loading backups:', error);
                document.getElementById('backups-content').innerHTML = \`
                    <p style="text-align: center; color: var(--error-color); padding: 2rem;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                        <br>Failed to load backups
                    </p>
                \`;
            }
        }

        function renderBackups(data) {
            const container = document.getElementById('backups-content');
            
            if (data.backups.length === 0) {
                container.innerHTML = \`
                    <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                        <i class="fas fa-database" style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;"></i>
                        <p>No backups found</p>
                        <button onclick="createBackup()" class="btn" style="margin-top: 1rem;">
                            <i class="fas fa-plus"></i> Create First Backup
                        </button>
                    </div>
                \`;
                return;
            }

            const formatBytes = (bytes) => {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
            };

            container.innerHTML = \`
                <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.25rem;">Total Backups</div>
                        <div style="font-size: 1.5rem; font-weight: 600;">\${data.backups.length}</div>
                    </div>
                    <div>
                        <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.25rem;">Total Size</div>
                        <div style="font-size: 1.5rem; font-weight: 600;">\${formatBytes(data.totalSize)}</div>
                    </div>
                    <div>
                        <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.25rem;">Current DB Size</div>
                        <div style="font-size: 1.5rem; font-weight: 600;">\${formatBytes(data.currentDbSize)}</div>
                    </div>
                </div>

                <div class="data-table-container">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Filename</th>
                                <th>Size</th>
                                <th>Created</th>
                                <th style="text-align: center;">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            \${data.backups.map(backup => \`
                                <tr>
                                    <td>
                                        <i class="fas fa-database" style="color: var(--accent-primary); margin-right: 0.5rem;"></i>
                                        \${backup.filename}
                                    </td>
                                    <td>\${formatBytes(backup.size)}</td>
                                    <td>\${backup.createdFormatted}</td>
                                    <td style="text-align: center;">
                                        <button onclick="downloadBackup('\${backup.filename}')" class="btn" style="padding: 0.4rem 0.8rem; margin: 0 0.25rem;" title="Download">
                                            <i class="fas fa-download"></i>
                                        </button>
                                        <button onclick="restoreBackup('\${backup.filename}')" class="btn" style="padding: 0.4rem 0.8rem; margin: 0 0.25rem; background: var(--warning-color);" title="Restore">
                                            <i class="fas fa-undo"></i>
                                        </button>
                                        <button onclick="deleteBackup('\${backup.filename}')" class="btn" style="padding: 0.4rem 0.8rem; margin: 0 0.25rem; background: var(--error-color);" title="Delete">
                                            <i class="fas fa-trash"></i>
                                        </button>
                                    </td>
                                </tr>
                            \`).join('')}
                        </tbody>
                    </table>
                </div>
            \`;
        }

        // Metrics variables and functions
        let metricsMemoryChart, metricsCpuChart;
        let metricsHistory = [];
        const MAX_METRICS_POINTS = 20;

        function initMetricsCharts() {
            const chartConfig = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false }
                },
                scales: {
                    x: {
                        grid: { color: 'rgba(255,255,255,0.1)' },
                        ticks: { color: 'var(--text-muted)', maxTicksLimit: 6 }
                    },
                    y: {
                        grid: { color: 'rgba(255,255,255,0.1)' },
                        ticks: { color: 'var(--text-muted)' },
                        beginAtZero: true
                    }
                }
            };

            const memCtx = document.getElementById('metrics-memory-chart');
            if (memCtx && !metricsMemoryChart) {
                metricsMemoryChart = new Chart(memCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Memory (MB)',
                            data: [],
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: chartConfig
                });
            }

            const cpuCtx = document.getElementById('metrics-cpu-chart');
            if (cpuCtx && !metricsCpuChart) {
                metricsCpuChart = new Chart(cpuCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'CPU %',
                            data: [],
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: chartConfig
                });
            }
        }

        async function fetchSystemMetrics() {
            try {
                const response = await fetch('/api/system/metrics', {
                    credentials: 'same-origin'
                });
                if (!response.ok) throw new Error('Failed to fetch metrics');
                
                const metrics = await response.json();
                updateMetricsDisplay(metrics);
            } catch (error) {
                console.error('Error fetching metrics:', error);
            }
        }

        function updateMetricsDisplay(metrics) {
            // Update current stats - handle actual metric structure
            const memoryUsage = metrics.memoryUsage || 0;
            const cpuUsage = metrics.cpuUsage || 0;
            const uptime = metrics.uptime || 0;
            const totalRequests = metrics.totalRequests || 0;
            
            document.getElementById('metrics-current-memory').textContent = memoryUsage + ' MB';
            document.getElementById('metrics-current-cpu').textContent = cpuUsage + '%';
            document.getElementById('metrics-server-uptime').textContent = formatMetricsUptime(uptime);
            document.getElementById('metrics-request-total').textContent = totalRequests.toLocaleString();
            document.getElementById('metrics-request-rate').textContent = Math.round(totalRequests / Math.max(uptime / 1000, 1) * 60);

            // Calculate percentages using available data
            const heapPercent = Math.min(Math.max((memoryUsage / 2048) * 100, 0), 100); // Assume 2GB max for percentage
            document.getElementById('metrics-memory-percent').textContent = heapPercent.toFixed(1);

            // Update memory breakdown with bars (use safe defaults)
            document.getElementById('metrics-heap-used').textContent = memoryUsage + ' MB';
            document.getElementById('metrics-heap-bar').style.width = heapPercent + '%';
            
            document.getElementById('metrics-heap-total').textContent = '2048 MB'; // Default total
            document.getElementById('metrics-heap-total-bar').style.width = '100%';
            
            document.getElementById('metrics-rss').textContent = memoryUsage + ' MB';
            document.getElementById('metrics-rss-bar').style.width = heapPercent + '%';

            document.getElementById('metrics-external-mem').textContent = '0 MB';
            const externalPercent = 0;
            document.getElementById('metrics-external-bar').style.width = Math.min(externalPercent, 100) + '%';

            // Add to history using corrected data structure
            metricsHistory.push({
                timestamp: new Date(),
                memory: memoryUsage,
                cpu: cpuUsage
            });

            // Keep only last MAX_METRICS_POINTS
            if (metricsHistory.length > MAX_METRICS_POINTS) {
                metricsHistory.shift();
            }

            // Update charts
            updateMetricsCharts();
        }

        function updateMetricsCharts() {
            if (!metricsMemoryChart || !metricsCpuChart) return;

            const labels = metricsHistory.map(m => m.timestamp.toLocaleTimeString());
            
            metricsMemoryChart.data.labels = labels;
            metricsMemoryChart.data.datasets[0].data = metricsHistory.map(m => m.memory);
            metricsMemoryChart.update('none');

            metricsCpuChart.data.labels = labels;
            metricsCpuChart.data.datasets[0].data = metricsHistory.map(m => m.cpu || 0);
            metricsCpuChart.update('none');
        }

        function formatMetricsUptime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            if (hours > 0) return hours + 'h ' + minutes + 'm';
            if (minutes > 0) return minutes + 'm';
            return seconds + 's';
        }

        function refreshMetrics() {
            initMetricsCharts();
            fetchSystemMetrics();
        }

        async function createBackup() {
            if (!confirm('Create a new backup of the database?')) return;
            
            try {
                showToast('Creating backup...', 'info');
                const response = await fetch('/api/backups/create', { method: 'POST' });
                
                if (!response.ok) throw new Error('Failed to create backup');
                
                const result = await response.json();
                showToast('Backup created successfully', 'success');
                loadBackups();
            } catch (error) {
                console.error('Error creating backup:', error);
                showToast('Failed to create backup', 'error');
            }
        }

        function downloadBackup(filename) {
            window.location.href = \`/api/backups/\${filename}/download\`;
            showToast('Downloading backup...', 'info');
        }

        async function restoreBackup(filename) {
            if (!confirm(\`Are you sure you want to restore from "\${filename}"?\\n\\nThis will replace the current database and restart the server.\`)) return;
            
            try {
                showToast('Restoring backup...', 'info');
                const response = await fetch(\`/api/backups/\${filename}/restore\`, { method: 'POST' });
                
                if (!response.ok) throw new Error('Failed to restore backup');
                
                const result = await response.json();
                showToast('Backup restored. Server restarting...', 'success');
                
                // Redirect to login after 2 seconds
                setTimeout(() => {
                    window.location.href = '/login';
                }, 2000);
            } catch (error) {
                console.error('Error restoring backup:', error);
                showToast('Failed to restore backup', 'error');
            }
        }

        async function deleteBackup(filename) {
            if (!confirm(\`Are you sure you want to delete "\${filename}"?\\n\\nThis action cannot be undone.\`)) return;
            
            try {
                showToast('Deleting backup...', 'info');
                const response = await fetch(\`/api/backups/\${filename}\`, { method: 'DELETE' });
                
                if (!response.ok) throw new Error('Failed to delete backup');
                
                showToast('Backup deleted successfully', 'success');
                loadBackups();
            } catch (error) {
                console.error('Error deleting backup:', error);
                showToast('Failed to delete backup', 'error');
            }
        }

        // API Keys Functions
        async function loadAPIKeys() {
            try {
                const response = await fetch('/api/api-keys');
                if (!response.ok) throw new Error('Failed to fetch API keys');
                
                const data = await response.json();
                renderAPIKeys(data.keys || []);
            } catch (error) {
                console.error('Error loading API keys:', error);
                document.getElementById('apiKeysContainer').innerHTML = \`
                    <div style="text-align: center; padding: 3rem; color: var(--error-color);">
                        <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                        <p>Failed to load API keys</p>
                    </div>
                \`;
            }
        }

        function renderAPIKeys(keys) {
            const container = document.getElementById('apiKeysContainer');
            
            if (keys.length === 0) {
                container.innerHTML = \`
                    <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                        <i class="fas fa-key" style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;"></i>
                        <p>No API keys created yet</p>
                        <button onclick="showCreateAPIKeyModal()" class="btn" style="margin-top: 1rem; background: var(--success-color);">
                            <i class="fas fa-plus"></i> Generate Your First Key
                        </button>
                    </div>
                \`;
                return;
            }

            let html = '<div style="display: flex; flex-direction: column; gap: 1rem;">';
            
            keys.forEach(key => {
                const isExpired = key.expires_at && new Date(key.expires_at) < new Date();
                const statusColor = isExpired ? 'var(--error-color)' : (key.is_active ? 'var(--success-color)' : 'var(--warning-color)');
                const statusText = isExpired ? 'Expired' : (key.is_active ? 'Active' : 'Inactive');
                const maskedKey = key.key_value.substring(0, 12) + '...' + key.key_value.substring(key.key_value.length - 4);
                
                html += \`
                    <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color);">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                                    <h4 style="margin: 0; color: var(--text-primary);"><i class="fas fa-key"></i> \${key.name}</h4>
                                    <span style="padding: 0.25rem 0.75rem; border-radius: 6px; font-size: 0.75rem; font-weight: 600; background: \${statusColor}20; color: \${statusColor};">
                                        \${statusText}
                                    </span>
                                </div>
                                \${key.description ? \`<p style="margin: 0.5rem 0; color: var(--text-secondary); font-size: 0.9rem;">\${key.description}</p>\` : ''}
                                <div style="margin: 0.75rem 0; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 6px; font-family: monospace; font-size: 0.9rem; color: var(--text-primary); display: flex; justify-content: space-between; align-items: center;">
                                    <code id="key-\${key.id}">\${maskedKey}</code>
                                    <button onclick="copyToClipboard('\${key.key_value}', 'key-\${key.id}')" class="btn" style="padding: 0.5rem 1rem; background: var(--info-color);">
                                        <i class="fas fa-copy"></i> Copy
                                    </button>
                                </div>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 0.75rem; font-size: 0.85rem; color: var(--text-secondary);">
                                    <div><i class="fas fa-user"></i> Created by: <strong>\${key.created_by_username || 'Unknown'}</strong></div>
                                    <div><i class="fas fa-calendar"></i> Created: <strong>\${new Date(key.created_at).toLocaleDateString()}</strong></div>
                                    <div><i class="fas fa-clock"></i> Last used: <strong>\${key.last_used ? new Date(key.last_used).toLocaleDateString() : 'Never'}</strong></div>
                                    <div><i class="fas fa-chart-line"></i> Uses: <strong>\${key.usage_count || 0}</strong></div>
                                    \${key.expires_at ? \`<div><i class="fas fa-hourglass-end"></i> Expires: <strong>\${new Date(key.expires_at).toLocaleDateString()}</strong></div>\` : ''}
                                </div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button onclick="toggleAPIKeyStatus(\${key.id}, \${key.is_active})" class="btn" style="background: var(--warning-color);">
                                <i class="fas fa-\${key.is_active ? 'pause' : 'play'}"></i> \${key.is_active ? 'Deactivate' : 'Activate'}
                            </button>
                            <button onclick="regenerateAPIKey(\${key.id})" class="btn" style="background: var(--info-color);">
                                <i class="fas fa-sync-alt"></i> Regenerate
                            </button>
                            <button onclick="deleteAPIKey(\${key.id})" class="btn" style="background: var(--error-color);">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                        </div>
                    </div>
                \`;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        function showCreateAPIKeyModal() {
            const modal = \`
                <div id="apiKeyModal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;">
                    <div style="background: var(--bg-primary); border-radius: 12px; padding: 2rem; max-width: 500px; width: 90%; box-shadow: var(--shadow-medium);">
                        <h3 style="margin: 0 0 1.5rem 0; color: var(--text-primary);"><i class="fas fa-key"></i> Generate New API Key</h3>
                        
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-weight: 600;">
                                Key Name <span style="color: var(--error-color);">*</span>
                            </label>
                            <input type="text" id="newKeyName" placeholder="e.g., Mobile App, External Service" 
                                   style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary);">
                        </div>
                        
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-weight: 600;">
                                Description
                            </label>
                            <textarea id="newKeyDescription" placeholder="Optional description" rows="3"
                                      style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); resize: vertical;"></textarea>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-weight: 600;">
                                Expiration
                            </label>
                            <select id="newKeyExpiration" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary);">
                                <option value="0">Never expires</option>
                                <option value="7">7 days</option>
                                <option value="30">30 days</option>
                                <option value="90">90 days</option>
                                <option value="180">180 days</option>
                                <option value="365">1 year</option>
                            </select>
                        </div>
                        
                        <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
                            <button onclick="closeModal('apiKeyModal')" class="btn" style="background: var(--bg-secondary); color: var(--text-primary);">
                                <i class="fas fa-times"></i> Cancel
                            </button>
                            <button onclick="createAPIKey()" class="btn" style="background: var(--success-color);">
                                <i class="fas fa-check"></i> Generate Key
                            </button>
                        </div>
                    </div>
                </div>
            \`;
            
            document.body.insertAdjacentHTML('beforeend', modal);
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) modal.remove();
        }

        async function createAPIKey() {
            const name = document.getElementById('newKeyName').value.trim();
            const description = document.getElementById('newKeyDescription').value.trim();
            const expiresInDays = parseInt(document.getElementById('newKeyExpiration').value);
            
            if (!name) {
                showToast('Please enter a key name', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/api-keys', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, description, expires_in_days: expiresInDays })
                });
                
                if (!response.ok) throw new Error('Failed to create API key');
                
                const result = await response.json();
                showToast('API key created successfully!', 'success');
                closeModal('apiKeyModal');
                loadAPIKeys();
                
                // Show the full key in an alert (only time it's shown)
                alert(\`API Key created successfully!\\n\\nKey: \${result.key}\\n\\nIMPORTANT: Copy this key now. It will not be shown again!\`);
            } catch (error) {
                console.error('Error creating API key:', error);
                showToast('Failed to create API key', 'error');
            }
        }

        async function toggleAPIKeyStatus(keyId, currentStatus) {
            try {
                const response = await fetch(\`/api/api-keys/\${keyId}\`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ is_active: !currentStatus })
                });
                
                if (!response.ok) throw new Error('Failed to update API key');
                
                showToast(\`API key \${!currentStatus ? 'activated' : 'deactivated'} successfully\`, 'success');
                loadAPIKeys();
            } catch (error) {
                console.error('Error updating API key:', error);
                showToast('Failed to update API key', 'error');
            }
        }

        async function regenerateAPIKey(keyId) {
            if (!confirm('Regenerate this API key?\\n\\nThe old key will stop working immediately.')) return;
            
            try {
                const response = await fetch(\`/api/api-keys/\${keyId}/regenerate\`, { method: 'POST' });
                
                if (!response.ok) throw new Error('Failed to regenerate API key');
                
                const result = await response.json();
                showToast('API key regenerated successfully!', 'success');
                loadAPIKeys();
                
                alert(\`New API Key: \${result.key}\\n\\nIMPORTANT: Copy this key now. It will not be shown again!\`);
            } catch (error) {
                console.error('Error regenerating API key:', error);
                showToast('Failed to regenerate API key', 'error');
            }
        }

        async function deleteAPIKey(keyId) {
            if (!confirm('Delete this API key?\\n\\nThis action cannot be undone.')) return;
            
            try {
                const response = await fetch(\`/api/api-keys/\${keyId}\`, { method: 'DELETE' });
                
                if (!response.ok) throw new Error('Failed to delete API key');
                
                showToast('API key deleted successfully', 'success');
                loadAPIKeys();
            } catch (error) {
                console.error('Error deleting API key:', error);
                showToast('Failed to delete API key', 'error');
            }
        }

        function copyToClipboard(text, elementId) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('API key copied to clipboard!', 'success');
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = text;
                    setTimeout(() => {
                        const maskedKey = text.substring(0, 12) + '...' + text.substring(text.length - 4);
                        element.textContent = maskedKey;
                    }, 3000);
                }
            }).catch(err => {
                showToast('Failed to copy to clipboard', 'error');
            });
        }

        async function loadSettings() {
            try {
                const response = await fetch('/api/settings');
                if (!response.ok) throw new Error('Failed to fetch settings');
                
                currentSettings = await response.json();
                renderSettings();
            } catch (error) {
                console.error('Error loading settings:', error);
                document.getElementById('settings-content').innerHTML = \`
                    <p style="text-align: center; color: var(--error-color); padding: 2rem;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                        <br>Failed to load settings
                    </p>
                \`;
            }
        }

        function renderSettings() {
            const settingsDiv = document.getElementById('settings-content');
            settingsDiv.innerHTML = \`
                <!-- Enterprise Settings Navigation -->
                <div style="background: var(--bg-primary); border-radius: 12px; padding: 1rem; margin-bottom: 1.5rem; box-shadow: var(--shadow-light); border: 1px solid var(--border-color);">
                    <div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
                        <button onclick="switchSettingsTab('general')" id="settings-tab-general" class="settings-tab-btn active" style="padding: 0.5rem 1rem; border: none; background: var(--gradient-ocean); color: white; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.875rem; transition: all 0.3s ease;">
                            <i class="fas fa-cog"></i> General
                        </button>
                        <button onclick="switchSettingsTab('ratelimiting')" id="settings-tab-ratelimiting" class="settings-tab-btn" style="padding: 0.5rem 1rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.875rem; transition: all 0.3s ease;">
                            <i class="fas fa-shield-alt"></i> Rate Limiting
                        </button>
                        <button onclick="switchSettingsTab('alerting')" id="settings-tab-alerting" class="settings-tab-btn" style="padding: 0.5rem 1rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.875rem; transition: all 0.3s ease;">
                            <i class="fas fa-bell"></i> Alerting
                        </button>
                        <button onclick="switchSettingsTab('websocket')" id="settings-tab-websocket" class="settings-tab-btn" style="padding: 0.5rem 1rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.875rem; transition: all 0.3s ease;">
                            <i class="fas fa-plug"></i> WebSocket
                        </button>
                        <button onclick="switchSettingsTab('parsing')" id="settings-tab-parsing" class="settings-tab-btn" style="padding: 0.5rem 1rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.875rem; transition: all 0.3s ease;">
                            <i class="fas fa-code"></i> Log Parsing
                        </button>
                        <button onclick="switchSettingsTab('maintenance')" id="settings-tab-maintenance" class="settings-tab-btn" style="padding: 0.5rem 1rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.875rem; transition: all 0.3s ease;">
                            <i class="fas fa-wrench"></i> Maintenance
                        </button>
                    </div>
                </div>

                <form id="settingsForm">
                    <!-- GENERAL SETTINGS TAB -->
                    <div id="settings-content-general" class="settings-tab-content">
                        <div class="section-header">
                            <i class="fas fa-info-circle"></i> System Information
                        </div>
                    <div class="settings-grid">
                        <div class="setting-item">
                            <div>
                                <div class="setting-label"><i class="fas fa-tag"></i> System Name</div>
                                <div class="setting-description">Platform identifier</div>
                            </div>
                            <div class="setting-control">
                                <input type="text" id="systemName" name="systemName" 
                                       value="\${currentSettings.system?.name || 'Enterprise Logging Platform'}"
                                       placeholder="Enterprise Logging Platform">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div>
                                <div class="setting-label"><i class="fas fa-code-branch"></i> Version</div>
                                <div class="setting-description">Current server version (read-only)</div>
                            </div>
                            <div class="setting-readonly">\${currentSettings.system?.version || '2.1.0-stable-enhanced'}</div>
                        </div>
                        <div class="setting-item">
                            <div>
                                <div class="setting-label"><i class="fas fa-user"></i> Owner</div>
                                <div class="setting-description">System administrator</div>
                            </div>
                            <div class="setting-control">
                                <input type="text" id="systemOwner" name="systemOwner" 
                                       value="\${currentSettings.system?.owner || 'Tom Nelson'}"
                                       placeholder="Tom Nelson">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div>
                                <div class="setting-label"><i class="fas fa-server"></i> Server Port</div>
                                <div class="setting-description">HTTP server port (read-only, requires restart)</div>
                            </div>
                            <div class="setting-readonly">\${currentSettings.server?.port || 10180}</div>
                        </div>
                        <div class="setting-item">
                            <div>
                                <div class="setting-label"><i class="fas fa-database"></i> Database</div>
                                <div class="setting-description">SQLite database file location (read-only)</div>
                            </div>
                            <div class="setting-readonly">\${currentSettings.database?.path || 'N/A'}</div>
                        </div>
                    </div>

                    <div class="section-header">
                        <i class="fas fa-clock"></i> System Configuration
                    </div>
                    <div class="settings-grid">
                        <div class="setting-item">
                            <div>
                                <div class="setting-label"><i class="fas fa-globe"></i> Timezone</div>
                                <div class="setting-description">Server timezone for logs and timestamps</div>
                            </div>
                            <div class="setting-control">
                                <select id="timezone" name="timezone">
                                    <option value="America/Denver" \${currentSettings.system?.timezone === 'America/Denver' ? 'selected' : ''}>America/Denver (US Mountain Time)</option>
                                    <option value="America/Edmonton" \${currentSettings.system?.timezone === 'America/Edmonton' ? 'selected' : ''}>America/Edmonton (Canada Mountain Time)</option>
                                    <option value="America/New_York" \${currentSettings.system?.timezone === 'America/New_York' ? 'selected' : ''}>America/New_York (Eastern)</option>
                                    <option value="America/Chicago" \${currentSettings.system?.timezone === 'America/Chicago' ? 'selected' : ''}>America/Chicago (Central)</option>
                                    <option value="America/Los_Angeles" \${currentSettings.system?.timezone === 'America/Los_Angeles' ? 'selected' : ''}>America/Los_Angeles (Pacific)</option>
                                    <option value="America/Toronto" \${currentSettings.system?.timezone === 'America/Toronto' ? 'selected' : ''}>America/Toronto (Canada Eastern)</option>
                                    <option value="America/Vancouver" \${currentSettings.system?.timezone === 'America/Vancouver' ? 'selected' : ''}>America/Vancouver (Canada Pacific)</option>
                                    <option value="UTC" \${currentSettings.system?.timezone === 'UTC' ? 'selected' : ''}>UTC</option>
                                </select>
                            </div>
                        </div>
                        <div class="setting-item">
                            <div>
                                <div class="setting-label"><i class="fas fa-palette"></i> Default Theme</div>
                                <div class="setting-description">Default color theme for the interface</div>
                            </div>
                            <div class="setting-control">
                                <select id="default_theme" name="default_theme">
                                    <option value="auto" \${(currentSettings.theme || 'auto') === 'auto' ? 'selected' : ''}>Auto (System Preference)</option>
                                    <option value="light" \${currentSettings.theme === 'light' ? 'selected' : ''}>Light Mode</option>
                                    <option value="dark" \${currentSettings.theme === 'dark' ? 'selected' : ''}>Dark Mode</option>
                                    <option value="ocean" \${currentSettings.theme === 'ocean' ? 'selected' : ''}>Ocean Blue</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="section-header">
                        <i class="fas fa-database"></i> Data Retention
                    </div>
                    <div class="settings-grid">
                        <div class="setting-item">
                            <div>
                                <div class="setting-label"><i class="fas fa-calendar-alt"></i> Log Retention Days</div>
                                <div class="setting-description">Automatically delete logs older than this many days</div>
                            </div>
                            <div class="setting-control">
                                <input type="number" id="logRetention" name="logRetention" min="1" max="365" 
                                       value="\${currentSettings.maintenance?.logRetentionDays || 30}">
                                <span>days</span>
                            </div>
                        </div>
                        <div class="setting-item">
                            <div>
                                <div class="setting-label"><i class="fas fa-clock"></i> Backup Schedule</div>
                                <div class="setting-description">Daily backup time</div>
                            </div>
                            <div class="setting-control">
                                <input type="time" id="backupSchedule" name="backupSchedule" 
                                       value="02:00">
                                <small style="color: var(--text-muted); margin-left: 0.5rem;">Daily at this time</small>
                            </div>
                        </div>
                        <div class="setting-item">
                            <div>
                                <div class="setting-label"><i class="fas fa-broom"></i> Cleanup Schedule</div>
                                <div class="setting-description">Weekly cleanup time</div>
                            </div>
                            <div class="setting-control">
                                <select id="cleanupDay" name="cleanupDay" style="width: auto; margin-right: 0.5rem;">
                                    <option value="0">Sunday</option>
                                    <option value="1">Monday</option>
                                    <option value="2">Tuesday</option>
                                    <option value="3">Wednesday</option>
                                    <option value="4">Thursday</option>
                                    <option value="5">Friday</option>
                                    <option value="6">Saturday</option>
                                </select>
                                <input type="time" id="cleanupSchedule" name="cleanupSchedule" 
                                       value="03:00" style="width: auto;">
                            </div>
                        </div>
                    </div>
                    </div>

                    <!-- RATE LIMITING SETTINGS TAB -->
                    <div id="settings-content-ratelimiting" class="settings-tab-content" style="display: none;">
                        <div class="section-header">
                            <i class="fas fa-shield-alt"></i> Three-Tier Rate Limiting Protection
                        </div>
                        <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid #f59e0b;">
                            <p style="margin: 0; color: var(--text-muted); font-size: 0.875rem;">
                                <i class="fas fa-info-circle" style="color: #f59e0b;"></i> 
                                <strong>Enterprise Protection:</strong> Configure three layers of rate limiting to protect against abuse and ensure service availability.
                            </p>
                        </div>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-globe"></i> General API Limits</div>
                                    <div class="setting-description">Rate limits for all general API endpoints</div>
                                </div>
                                <div class="setting-control">
                                    <input type="number" id="generalMaxRequests" name="generalMaxRequests" min="1" max="10000"
                                           value="\${currentSettings.rateLimiting?.general?.maxRequests || 100}"
                                           style="width: 100px; margin-right: 0.5rem;">
                                    <span>requests per</span>
                                    <input type="number" id="generalWindowMs" name="generalWindowMs" min="60000" max="3600000" step="60000"
                                           value="\${(currentSettings.rateLimiting?.general?.windowMs || 15 * 60 * 1000) / 60000}"
                                           style="width: 80px; margin: 0 0.5rem;">
                                    <span>minutes</span>
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-file-alt"></i> Log Ingestion Limits</div>
                                    <div class="setting-description">Higher limits for log submission endpoints</div>
                                </div>
                                <div class="setting-control">
                                    <input type="number" id="logMaxRequests" name="logMaxRequests" min="10" max="50000"
                                           value="\${currentSettings.rateLimiting?.logIngestion?.maxRequests || 1000}"
                                           style="width: 100px; margin-right: 0.5rem;">
                                    <span>requests per</span>
                                    <input type="number" id="logWindowMs" name="logWindowMs" min="60000" max="1800000" step="60000"
                                           value="\${(currentSettings.rateLimiting?.logIngestion?.windowMs || 5 * 60 * 1000) / 60000}"
                                           style="width: 80px; margin: 0 0.5rem;">
                                    <span>minutes</span>
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-lock"></i> Authentication Limits</div>
                                    <div class="setting-description">Strict limits for login attempts</div>
                                </div>
                                <div class="setting-control">
                                    <input type="number" id="authMaxRequests" name="authMaxRequests" min="1" max="50"
                                           value="\${currentSettings.rateLimiting?.authentication?.maxRequests || 5}"
                                           style="width: 100px; margin-right: 0.5rem;">
                                    <span>attempts per</span>
                                    <input type="number" id="authWindowMs" name="authWindowMs" min="300000" max="3600000" step="300000"
                                           value="\${(currentSettings.rateLimiting?.authentication?.windowMs || 15 * 60 * 1000) / 60000}"
                                           style="width: 80px; margin: 0 0.5rem;">
                                    <span>minutes</span>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border-left: 4px solid var(--error-color);">
                            <p style="margin: 0; color: var(--text-muted); font-size: 0.875rem;">
                                <i class="fas fa-exclamation-triangle" style="color: var(--error-color);"></i> 
                                <strong>Restart Required:</strong> Rate limiting changes require a server restart to take effect.
                            </p>
                        </div>
                    </div>

                    <!-- ALERTING SETTINGS TAB -->
                    <div id="settings-content-alerting" class="settings-tab-content" style="display: none;">
                        <div class="section-header">
                            <i class="fas fa-bell"></i> Real-Time Alerting System
                        </div>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-power-off"></i> Enable Alerting</div>
                                    <div class="setting-description">Master switch for the alerting system</div>
                                </div>
                                <div class="setting-control">
                                    <input type="checkbox" id="alertingEnabled" name="alertingEnabled" 
                                           \${currentSettings.alerting?.enabled ? 'checked' : ''}>
                                    <span style="margin-left: 0.5rem;">Enable real-time alerts</span>
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-clock"></i> Cooldown Period</div>
                                    <div class="setting-description">Minimum time between alerts of the same type</div>
                                </div>
                                <div class="setting-control">
                                    <input type="number" id="alertingCooldown" name="alertingCooldown" min="30" max="3600"
                                           value="\${Math.floor((currentSettings.alerting?.cooldownPeriod || 300) / 60)}"
                                           style="width: 100px; margin-right: 0.5rem;">
                                    <span>minutes</span>
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-exclamation-triangle"></i> Max Alerts Per Hour</div>
                                    <div class="setting-description">Prevent alert spam</div>
                                </div>
                                <div class="setting-control">
                                    <input type="number" id="alertingMaxHourly" name="alertingMaxHourly" min="1" max="100"
                                           value="\${currentSettings.alerting?.maxAlertsPerHour || 10}">
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-list"></i> Active Rules</div>
                                    <div class="setting-description">Currently configured alert rules</div>
                                </div>
                                <div class="setting-readonly">
                                    \${currentSettings.alerting?.rules || 0} rules configured
                                    <button type="button" onclick="manageAlertRules()" style="margin-left: 1rem; padding: 0.25rem 0.5rem; font-size: 0.75rem; background: var(--accent-primary); color: white; border: none; border-radius: 4px; cursor: pointer;">
                                        Manage Rules
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="section-header" style="margin-top: 2rem;">
                            <i class="fas fa-broadcast-tower"></i> Alert Channels
                        </div>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fab fa-slack"></i> Slack Integration</div>
                                    <div class="setting-description">Send alerts to Slack workspace</div>
                                </div>
                                <div class="setting-control">
                                    <input type="checkbox" id="slackEnabled" name="slackEnabled" 
                                           \${currentSettings.alerting?.channels?.slack?.enabled ? 'checked' : ''}>
                                    <input type="url" id="slackWebhook" name="slackWebhook" placeholder="Slack webhook URL"
                                           value="\${currentSettings.alerting?.channels?.slack?.webhook || ''}" 
                                           style="margin-left: 0.5rem; flex: 1;">
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fab fa-discord"></i> Discord Integration</div>
                                    <div class="setting-description">Send alerts to Discord channel</div>
                                </div>
                                <div class="setting-control">
                                    <input type="checkbox" id="discordEnabled" name="discordEnabled" 
                                           \${currentSettings.alerting?.channels?.discord?.enabled ? 'checked' : ''}>
                                    <input type="url" id="discordWebhook" name="discordWebhook" placeholder="Discord webhook URL"
                                           value="\${currentSettings.alerting?.channels?.discord?.webhook || ''}" 
                                           style="margin-left: 0.5rem; flex: 1;">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- WEBSOCKET SETTINGS TAB -->
                    <div id="settings-content-websocket" class="settings-tab-content" style="display: none;">
                        <div class="section-header">
                            <i class="fas fa-plug"></i> Real-Time WebSocket Configuration
                        </div>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-power-off"></i> Enable WebSocket</div>
                                    <div class="setting-description">Real-time log streaming and notifications</div>
                                </div>
                                <div class="setting-control">
                                    <input type="checkbox" id="wsEnabled" name="wsEnabled" 
                                           \${currentSettings.websocket?.enabled ? 'checked' : ''}>
                                    <span style="margin-left: 0.5rem;">Enable WebSocket server</span>
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-ethernet"></i> WebSocket Port</div>
                                    <div class="setting-description">Port for WebSocket connections (read-only)</div>
                                </div>
                                <div class="setting-readonly">\${currentSettings.websocket?.port || 10181}</div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-users"></i> Max Connections</div>
                                    <div class="setting-description">Maximum concurrent WebSocket clients</div>
                                </div>
                                <div class="setting-control">
                                    <input type="number" id="wsMaxConnections" name="wsMaxConnections" min="1" max="1000"
                                           value="\${currentSettings.websocket?.maxConnections || 100}">
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-heartbeat"></i> Heartbeat Interval</div>
                                    <div class="setting-description">Keep-alive ping frequency</div>
                                </div>
                                <div class="setting-control">
                                    <input type="number" id="wsHeartbeat" name="wsHeartbeat" min="10" max="300"
                                           value="\${(currentSettings.websocket?.heartbeatInterval || 30000) / 1000}"
                                           style="width: 100px; margin-right: 0.5rem;">
                                    <span>seconds</span>
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-link"></i> Current Connections</div>
                                    <div class="setting-description">Active WebSocket clients (read-only)</div>
                                </div>
                                <div class="setting-readonly">
                                    \${currentSettings.websocket?.currentConnections || 0} connected
                                    <button type="button" onclick="refreshWebSocketStats()" style="margin-left: 1rem; padding: 0.25rem 0.5rem; font-size: 0.75rem; background: var(--accent-primary); color: white; border: none; border-radius: 4px; cursor: pointer;">
                                        Refresh
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- LOG PARSING SETTINGS TAB -->
                    <div id="settings-content-parsing" class="settings-tab-content" style="display: none;">
                        <div class="section-header">
                            <i class="fas fa-code"></i> Log Parsing and Enrichment
                        </div>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-magic"></i> Auto-Detection</div>
                                    <div class="setting-description">Automatically detect log formats</div>
                                </div>
                                <div class="setting-control">
                                    <input type="checkbox" id="parsingAutoDetection" name="parsingAutoDetection" 
                                           \${currentSettings.logParsing?.autoDetection ? 'checked' : ''}>
                                    <span style="margin-left: 0.5rem;">Enable auto-detection</span>
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-list"></i> Supported Formats</div>
                                    <div class="setting-description">Built-in log format parsers (read-only)</div>
                                </div>
                                <div class="setting-readonly">
                                    \${(currentSettings.logParsing?.formats || ['nginx', 'apache', 'docker', 'syslog', 'json']).join(', ')}
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-globe"></i> GeoIP Enrichment</div>
                                    <div class="setting-description">Add location data for IP addresses</div>
                                </div>
                                <div class="setting-control">
                                    <input type="checkbox" id="geoipEnabled" name="geoipEnabled" 
                                           \${currentSettings.logParsing?.enrichment?.geoip ? 'checked' : ''}>
                                    <span style="margin-left: 0.5rem;">Enable GeoIP lookups</span>
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-desktop"></i> User-Agent Parsing</div>
                                    <div class="setting-description">Extract browser and OS information</div>
                                </div>
                                <div class="setting-control">
                                    <input type="checkbox" id="userAgentEnabled" name="userAgentEnabled" 
                                           \${currentSettings.logParsing?.enrichment?.userAgent ? 'checked' : ''}>
                                    <span style="margin-left: 0.5rem;">Enable User-Agent parsing</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- MAINTENANCE SETTINGS TAB -->
                    <div id="settings-content-maintenance" class="settings-tab-content" style="display: none;">
                        <div class="section-header">
                            <i class="fas fa-database"></i> Data Retention and Cleanup
                        </div>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-calendar-alt"></i> Log Retention Days</div>
                                    <div class="setting-description">Automatically delete logs older than this many days</div>
                                </div>
                                <div class="setting-control">
                                    <input type="number" id="logRetentionMaint" name="logRetentionMaint" min="1" max="365" 
                                           value="\${currentSettings.maintenance?.logRetentionDays || 30}">
                                    <span>days</span>
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-clock"></i> Backup Schedule</div>
                                    <div class="setting-description">Daily backup time</div>
                                </div>
                                <div class="setting-control">
                                    <input type="time" id="backupScheduleMaint" name="backupScheduleMaint" 
                                           value="02:00">
                                    <small style="color: var(--text-muted); margin-left: 0.5rem;">Daily at this time</small>
                                </div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label"><i class="fas fa-broom"></i> Cleanup Schedule</div>
                                    <div class="setting-description">Weekly cleanup time</div>
                                </div>
                                <div class="setting-control">
                                    <select id="cleanupDayMaint" name="cleanupDayMaint" style="width: auto; margin-right: 0.5rem;">
                                        <option value="0">Sunday</option>
                                        <option value="1">Monday</option>
                                        <option value="2">Tuesday</option>
                                        <option value="3">Wednesday</option>
                                        <option value="4">Thursday</option>
                                        <option value="5">Friday</option>
                                        <option value="6">Saturday</option>
                                    </select>
                                    <input type="time" id="cleanupScheduleMaint" name="cleanupScheduleMaint" 
                                           value="03:00" style="width: auto;">
                                </div>
                            </div>
                        </div>
                        
                        <div class="section-header" style="margin-top: 2rem;">
                            <i class="fas fa-plug"></i> Legacy Integrations
                        </div>
                        <div style="padding: 2rem; background: var(--bg-secondary); border-radius: 12px; border-left: 4px solid var(--accent-primary); text-align: center;">
                            <i class="fas fa-plug" style="font-size: 3rem; color: var(--accent-primary); margin-bottom: 1rem; opacity: 0.8;"></i>
                            <h3 style="margin: 0 0 0.5rem 0; color: var(--text-primary);">Manage Integrations</h3>
                            <p style="color: var(--text-muted); margin-bottom: 1.5rem;">
                                All integration configuration has been moved to the dedicated Integrations page for better organization.
                            </p>
                            <a href="/integrations" class="btn" style="background: var(--gradient-ocean); text-decoration: none; display: inline-block;">
                                <i class="fas fa-arrow-right"></i> Go to Integrations Page
                            </a>
                        </div>
                    </div>

                    <!-- Save Button (Always Visible) -->
                    <div style="position: sticky; bottom: 1rem; background: var(--bg-primary); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color); margin-top: 2rem; display: flex; justify-content: flex-end; gap: 1rem; box-shadow: var(--shadow-light);">
                        <button type="button" onclick="loadSettings()" class="btn btn-secondary">
                            <i class="fas fa-undo"></i> Reset Changes
                        </button>
                        <button type="submit" class="btn">
                            <i class="fas fa-save"></i> Save Enterprise Settings
                        </button>
                    </div>
                </form>

                <div class="section-header" style="margin-top: 2rem;">
                    <i class="fas fa-tools"></i> Server Actions
                </div>
                <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                    <button onclick="clearCache()" class="btn btn-secondary">
                        <i class="fas fa-broom"></i> Clear Cache
                    </button>
                    <button onclick="confirmRestart()" class="btn btn-warning">
                        <i class="fas fa-sync-alt"></i> Restart Server
                    </button>
                    <button onclick="testEnterpriseFeatures()" class="btn" style="background: var(--gradient-ocean);">
                        <i class="fas fa-check-circle"></i> Test Enterprise Features
                    </button>
                </div>

                <div style="margin-top: 2rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border-left: 4px solid var(--accent-primary);">
                    <p style="margin: 0; color: var(--text-muted); font-size: 0.875rem;">
                        <i class="fas fa-info-circle"></i> <strong>Enterprise Edition:</strong> This logging server is running with enterprise-grade features including advanced rate limiting, real-time alerting, log parsing, and comprehensive monitoring capabilities.
                    </p>
                </div>
            \`;

            // Setup form submission
            document.getElementById('settingsForm').addEventListener('submit', saveEnterpriseSettings);
            
            // Parse cron schedules and populate time fields
            parseCronSchedules();
            
            // Initialize settings tabs
            initializeSettingsTabs();
        }
        
        function parseCronSchedules() {
            // Parse backup schedule (format: "0 2 * * *" = daily at 2:00 AM)
            const backupCron = currentSettings.maintenance?.backupSchedule || '0 2 * * *';
            const backupParts = backupCron.split(' ');
            if (backupParts.length >= 2) {
                const minute = backupParts[0].padStart(2, '0');
                const hour = backupParts[1].padStart(2, '0');
                document.getElementById('backupSchedule').value = \`\${hour}:\${minute}\`;
            }
            
            // Parse cleanup schedule (format: "0 3 * * 0" = Sunday at 3:00 AM)
            const cleanupCron = currentSettings.maintenance?.cleanupSchedule || '0 3 * * 0';
            const cleanupParts = cleanupCron.split(' ');
            if (cleanupParts.length >= 5) {
                const minute = cleanupParts[0].padStart(2, '0');
                const hour = cleanupParts[1].padStart(2, '0');
                const day = cleanupParts[4]; // Day of week (0 = Sunday)
                document.getElementById('cleanupSchedule').value = \`\${hour}:\${minute}\`;
                document.getElementById('cleanupDay').value = day;
            }
        }
        
        function timeToCron(time, day = null) {
            // Convert HH:MM to cron format
            const [hour, minute] = time.split(':');
            if (day !== null) {
                // Weekly schedule with specific day
                return \`\${parseInt(minute)} \${parseInt(hour)} * * \${day}\`;
            } else {
                // Daily schedule
                return \`\${parseInt(minute)} \${parseInt(hour)} * * *\`;
            }
        }

        async function saveSettings(e) {
            e.preventDefault();
            
            const formData = new FormData(e.target);
            
            // Convert time picker values back to cron format
            const backupTime = formData.get('backupSchedule');
            const cleanupTime = formData.get('cleanupSchedule');
            const cleanupDay = formData.get('cleanupDay');
            
            const updates = {
                systemName: formData.get('systemName'),
                systemOwner: formData.get('systemOwner'),
                timezone: formData.get('timezone'),
                default_theme: formData.get('default_theme'),
                logRetentionDays: parseInt(formData.get('logRetention')),
                backupSchedule: timeToCron(backupTime),
                cleanupSchedule: timeToCron(cleanupTime, cleanupDay),
                wsEnabled: formData.get('wsEnabled') === 'on',
                mqttEnabled: formData.get('mqttEnabled') === 'on',
                mqttBroker: formData.get('mqttBroker'),
                mqttUsername: formData.get('mqttUsername'),
                mqttPassword: formData.get('mqttPassword'),
                mqttTopic: formData.get('mqttTopic'),
                unifiEnabled: formData.get('unifiEnabled') === 'on',
                unifiHost: formData.get('unifiHost'),
                unifiUsername: formData.get('unifiUsername'),
                unifiPassword: formData.get('unifiPassword'),
                unifiSite: formData.get('unifiSite'),
                haEnabled: formData.get('haEnabled') === 'on',
                haHost: formData.get('haHost'),
                haToken: formData.get('haToken')
            };

            try {
                const response = await fetch('/api/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updates)
                });

                if (response.ok) {
                    const result = await response.json();
                    alert('‚úÖ ' + result.message);
                    loadSettings();
                    // Reload page to apply timezone/theme changes
                    setTimeout(() => window.location.reload(), 1000);
                } else {
                    const error = await response.json();
                    alert('‚ùå Failed to save settings: ' + (error.error || 'Unknown error'));
                }
            } catch (error) {
                alert('‚ùå Error saving settings: ' + error.message);
            }
        }

        async function testConnection() {
            try {
                const response = await fetch('/api/integrations/status');
                const data = await response.json();
                
                if (data.success) {
                    let message = 'üîå Integration Status:\\n\\n';
                    message += \`‚úÖ Server: \${data.status.server.status}\\n\`;
                    message += \`üìä Uptime: \${Math.floor(data.status.server.uptime / 3600)}h \${Math.floor((data.status.server.uptime % 3600) / 60)}m\\n\`;
                    message += \`üíæ Memory: \${data.status.server.memory_mb} MB\\n\\n\`;
                    
                    if (data.status.integrations.mqtt) {
                        message += \`MQTT: \${data.status.integrations.mqtt.status || 'disconnected'}\\n\`;
                    }
                    if (data.status.integrations.websocket) {
                        message += \`WebSocket: \${data.status.integrations.websocket.enabled ? 'enabled' : 'disabled'} (\${data.status.integrations.websocket.clients || 0} clients)\\n\`;
                    }
                    if (data.status.integrations.unifi) {
                        message += \`UniFi: \${data.status.integrations.unifi.status || 'disconnected'}\\n\`;
                    }
                    if (data.status.integrations.home_assistant) {
                        message += \`Home Assistant: \${data.status.integrations.home_assistant.status || 'disconnected'}\\n\`;
                    }
                    
                    alert(message);
                } else {
                    alert('‚ùå Failed to test connections');
                }
            } catch (error) {
                alert('‚ùå Error testing connections: ' + error.message);
            }
        }

        function clearCache() {
            if (confirm('Clear server cache?\\n\\nThis will clear temporary data and may improve performance.')) {
                alert('‚úÖ Cache cleared successfully!\\n\\nNote: This is a placeholder - implement actual cache clearing logic in the backend.');
            }
        }

        function exportSettings() {
            const settingsJson = JSON.stringify(currentSettings, null, 2);
            const blob = new Blob([settingsJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'enterprise-logging-settings-' + new Date().toISOString().split('T')[0] + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function confirmRestart() {
            if (confirm('‚ö†Ô∏è Restart Server?\\n\\nThis will restart the entire logging server.\\nAll active connections will be disconnected.\\n\\nAre you sure?')) {
                fetch('/api/admin/restart', {
                    method: 'POST',
                    credentials: 'same-origin'
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showToast('üîÑ Server restarting... Page will reload in 10 seconds.', 'info');
                        setTimeout(() => {
                            window.location.reload();
                        }, 10000);
                    } else {
                        showToast(data.error || 'Restart failed', 'error');
                    }
                })
                .catch(error => {
                    console.error('Restart error:', error);
                    showToast('üîÑ Server restarting... Page will reload in 10 seconds.', 'info');
                    setTimeout(() => {
                        window.location.reload();
                    }, 10000);
                });
            }
        }

        // ===== THEME CUSTOMIZATION FUNCTIONS =====
        let gradientStops = [
            { position: 0, color: '#0ea5e9' },
            { position: 50, color: '#3b82f6' },
            { position: 100, color: '#6366f1' }
        ];

        async function loadThemeSettings() {
            try {
                const response = await fetch('/api/user/theme');
                if (!response.ok) throw new Error('Failed to load theme');
                
                const theme = await response.json();
                
                if (theme) {
                    // Load gradient settings
                    document.getElementById('gradient-type').value = theme.gradient_type || 'linear';
                    document.getElementById('gradient-angle').value = theme.gradient_angle || 135;
                    updateAngleDisplay();
                    
                    // Load gradient stops
                    if (theme.gradient_stops) {
                        gradientStops = theme.gradient_stops;
                    }
                    
                    // Load color settings
                    if (theme.bg_primary) document.getElementById('color-bg-primary').value = theme.bg_primary;
                    if (theme.bg_secondary) document.getElementById('color-bg-secondary').value = theme.bg_secondary;
                    if (theme.bg_tertiary) document.getElementById('color-bg-tertiary').value = theme.bg_tertiary;
                    if (theme.text_primary) document.getElementById('color-text-primary').value = theme.text_primary;
                    if (theme.text_secondary) document.getElementById('color-text-secondary').value = theme.text_secondary;
                    if (theme.text_muted) document.getElementById('color-text-muted').value = theme.text_muted;
                    if (theme.border_color) document.getElementById('color-border').value = theme.border_color;
                    if (theme.accent_primary) document.getElementById('color-accent-primary').value = theme.accent_primary;
                    if (theme.accent_secondary) document.getElementById('color-accent-secondary').value = theme.accent_secondary;
                    if (theme.success_color) document.getElementById('color-success').value = theme.success_color;
                    if (theme.warning_color) document.getElementById('color-warning').value = theme.warning_color;
                    if (theme.error_color) document.getElementById('color-error').value = theme.error_color;
                    if (theme.info_color) document.getElementById('color-info').value = theme.info_color;
                }
                
                // Render gradient stops and update previews
                renderGradientStops();
                updateGradientPreview();
                updateColorPreview();
            } catch (error) {
                console.error('Error loading theme:', error);
                // Initialize with defaults
                renderGradientStops();
                updateGradientPreview();
            }
        }

        function renderGradientStops() {
            const container = document.getElementById('gradient-stops-container');
            container.innerHTML = gradientStops.map((stop, index) => \`
                <div style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 6px;">
                    <input type="color" value="\${stop.color}" onchange="updateStopColor(\${index}, this.value)" style="width: 50px; height: 40px; border: none; border-radius: 6px; cursor: pointer;">
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
                            <span style="font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">Stop \${index + 1}</span>
                            <span style="font-size: 0.75rem; color: var(--text-muted);">\${stop.position}%</span>
                        </div>
                        <input type="range" min="0" max="100" value="\${stop.position}" oninput="updateStopPosition(\${index}, this.value)" style="width: 100%; cursor: pointer;">
                    </div>
                    \${gradientStops.length > 2 ? \`
                        <button onclick="removeGradientStop(\${index})" style="padding: 0.5rem; background: var(--error-color); color: white; border: none; border-radius: 6px; cursor: pointer;" title="Remove">
                            <i class="fas fa-trash"></i>
                        </button>
                    \` : ''}
                </div>
            \`).join('');
        }

        function addGradientStop() {
            if (gradientStops.length >= 10) {
                showToast('Maximum 10 gradient stops allowed', 'warning');
                return;
            }
            
            // Add new stop in the middle
            const newPosition = Math.round((gradientStops[gradientStops.length - 1].position + gradientStops[gradientStops.length - 2].position) / 2);
            gradientStops.push({
                position: newPosition || 50,
                color: '#6366f1'
            });
            
            // Sort by position
            gradientStops.sort((a, b) => a.position - b.position);
            
            renderGradientStops();
            updateGradientPreview();
        }

        function removeGradientStop(index) {
            if (gradientStops.length <= 2) {
                showToast('Minimum 2 gradient stops required', 'warning');
                return;
            }
            
            gradientStops.splice(index, 1);
            renderGradientStops();
            updateGradientPreview();
        }

        function updateStopColor(index, color) {
            gradientStops[index].color = color;
            updateGradientPreview();
        }

        function updateStopPosition(index, position) {
            gradientStops[index].position = parseInt(position);
            
            // Update the display
            const stopElements = document.querySelectorAll('#gradient-stops-container > div');
            if (stopElements[index]) {
                const posLabel = stopElements[index].querySelector('.text-muted');
                if (posLabel) posLabel.textContent = position + '%';
            }
            
            updateGradientPreview();
        }

        function updateAngleDisplay() {
            const angle = document.getElementById('gradient-angle').value;
            document.getElementById('angle-value').textContent = angle;
        }

        function updateGradientPreview() {
            const type = document.getElementById('gradient-type').value;
            const angle = document.getElementById('gradient-angle').value;
            
            // Show/hide angle control
            document.getElementById('gradient-angle-container').style.display = type === 'linear' ? 'block' : 'none';
            
            // Sort stops by position
            const sortedStops = [...gradientStops].sort((a, b) => a.position - b.position);
            
            // Build gradient string
            const stops = sortedStops.map(stop => \`\${stop.color} \${stop.position}%\`).join(', ');
            let gradient;
            
            if (type === 'linear') {
                gradient = \`linear-gradient(\${angle}deg, \${stops})\`;
            } else {
                gradient = \`radial-gradient(circle, \${stops})\`;
            }
            
            // Update preview
            document.getElementById('gradient-preview').style.background = gradient;
            
            // Update live CSS variable
            document.documentElement.style.setProperty('--gradient-ocean', gradient);
        }

        function updateColorPreview() {
            // Update all CSS variables with current color values
            const colorMap = {
                'color-bg-primary': '--bg-primary',
                'color-bg-secondary': '--bg-secondary',
                'color-bg-tertiary': '--bg-tertiary',
                'color-text-primary': '--text-primary',
                'color-text-secondary': '--text-secondary',
                'color-text-muted': '--text-muted',
                'color-border': '--border-color',
                'color-accent-primary': '--accent-primary',
                'color-accent-secondary': '--accent-secondary',
                'color-success': '--success-color',
                'color-warning': '--warning-color',
                'color-error': '--error-color',
                'color-info': '--info-color'
            };
            
            Object.keys(colorMap).forEach(inputId => {
                const value = document.getElementById(inputId).value;
                document.documentElement.style.setProperty(colorMap[inputId], value);
            });
        }

        async function saveTheme() {
            try {
                const themeData = {
                    gradient_type: document.getElementById('gradient-type').value,
                    gradient_angle: parseInt(document.getElementById('gradient-angle').value),
                    gradient_stops: gradientStops,
                    bg_primary: document.getElementById('color-bg-primary').value,
                    bg_secondary: document.getElementById('color-bg-secondary').value,
                    bg_tertiary: document.getElementById('color-bg-tertiary').value,
                    text_primary: document.getElementById('color-text-primary').value,
                    text_secondary: document.getElementById('color-text-secondary').value,
                    text_muted: document.getElementById('color-text-muted').value,
                    border_color: document.getElementById('color-border').value,
                    accent_primary: document.getElementById('color-accent-primary').value,
                    accent_secondary: document.getElementById('color-accent-secondary').value,
                    success_color: document.getElementById('color-success').value,
                    warning_color: document.getElementById('color-warning').value,
                    error_color: document.getElementById('color-error').value,
                    info_color: document.getElementById('color-info').value
                };
                
                const response = await fetch('/api/user/theme', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(themeData)
                });
                
                if (!response.ok) throw new Error('Failed to save theme');
                
                showToast('Theme saved successfully! Changes will persist across sessions.', 'success');
            } catch (error) {
                console.error('Error saving theme:', error);
                showToast('Failed to save theme', 'error');
            }
        }

        async function resetTheme() {
            if (!confirm('Are you sure you want to reset to the default theme? This will reload the page.')) return;
            
            try {
                const response = await fetch('/api/user/theme', { method: 'DELETE' });
                
                if (!response.ok) throw new Error('Failed to reset theme');
                
                showToast('Theme reset to defaults. Reloading...', 'success');
                
                // Reload page after a short delay
                setTimeout(() => window.location.reload(), 1000);
            } catch (error) {
                console.error('Error resetting theme:', error);
                showToast('Failed to reset theme', 'error');
            }
        }

        // ===== IMPORT/EXPORT FUNCTIONS =====
        let importData = null;

        function exportSettings() {
            window.location.href = '/api/settings/export';
            showToast('Downloading settings export...', 'info');
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    importData = JSON.parse(e.target.result);
                    
                    // Show preview
                    document.getElementById('import-preview').style.display = 'block';
                    document.getElementById('preview-version').textContent = importData.version || 'Unknown';
                    document.getElementById('preview-count').textContent = (importData.settings ? importData.settings.length : 0) + ' settings';
                    document.getElementById('preview-json').textContent = JSON.stringify(importData, null, 2);
                    
                    showToast('File loaded successfully. Review and confirm import.', 'success');
                } catch (error) {
                    console.error('Error parsing import file:', error);
                    showToast('Invalid JSON file format', 'error');
                    importData = null;
                }
            };
            reader.readAsText(file);
        }

        async function confirmImport() {
            if (!importData) {
                showToast('No import data loaded', 'error');
                return;
            }

            if (!confirm('Are you sure you want to import these settings?\\n\\nThis will overwrite your current configuration and may require a server restart.')) {
                return;
            }

            try {
                const response = await fetch('/api/settings/import', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(importData)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Import failed');
                }

                const result = await response.json();
                showToast(result.message, 'success');
                
                // Reset form
                cancelImport();
                document.getElementById('import-file-input').value = '';
                
                // Reload settings
                loadSettings();
            } catch (error) {
                console.error('Error importing settings:', error);
                showToast('Failed to import settings: ' + error.message, 'error');
            }
        }

        function cancelImport() {
            importData = null;
            document.getElementById('import-preview').style.display = 'none';
            document.getElementById('import-file-input').value = '';
        }

        // ================================================================================
        // ENHANCED ENTERPRISE SETTINGS FUNCTIONS
        // ================================================================================
        
        // Settings tab management
        function switchSettingsTab(tabName) {
            // Hide all tab contents
            const tabs = ['general', 'ratelimiting', 'alerting', 'websocket', 'parsing', 'maintenance'];
            tabs.forEach(tab => {
                const content = document.getElementById('settings-content-' + tab);
                const button = document.getElementById('settings-tab-' + tab);
                if (content) content.style.display = 'none';
                if (button) {
                    button.style.background = 'var(--bg-secondary)';
                    button.style.color = 'var(--text-primary)';
                    button.classList.remove('active');
                }
            });
            
            // Show selected tab
            const selectedContent = document.getElementById('settings-content-' + tabName);
            const selectedButton = document.getElementById('settings-tab-' + tabName);
            if (selectedContent) selectedContent.style.display = 'block';
            if (selectedButton) {
                selectedButton.style.background = 'var(--gradient-ocean)';
                selectedButton.style.color = 'white';
                selectedButton.classList.add('active');
            }
        }
        
        // Initialize settings tabs
        function initializeSettingsTabs() {
            // Ensure general tab is shown by default
            switchSettingsTab('general');
        }
        
        // Enhanced settings save function
        async function saveEnterpriseSettings(e) {
            e.preventDefault();
            
            const formData = new FormData(e.target);
            
            // Convert time picker values back to cron format
            const backupTime = formData.get('backupSchedule') || '02:00';
            const cleanupTime = formData.get('cleanupSchedule') || '03:00';
            const cleanupDay = formData.get('cleanupDay') || '0';
            
            const updates = {
                // System settings
                systemName: formData.get('systemName'),
                systemOwner: formData.get('systemOwner'),
                timezone: formData.get('timezone'),
                default_theme: formData.get('default_theme'),
                
                // Rate limiting settings
                rateLimiting: {
                    general: {
                        maxRequests: parseInt(formData.get('generalMaxRequests')) || 100,
                        windowMs: (parseInt(formData.get('generalWindowMs')) || 15) * 60000
                    },
                    logIngestion: {
                        maxRequests: parseInt(formData.get('logMaxRequests')) || 1000,
                        windowMs: (parseInt(formData.get('logWindowMs')) || 5) * 60000
                    },
                    authentication: {
                        maxRequests: parseInt(formData.get('authMaxRequests')) || 5,
                        windowMs: (parseInt(formData.get('authWindowMs')) || 15) * 60000
                    }
                },
                
                // Alerting settings
                alerting: {
                    enabled: formData.get('alertingEnabled') === 'on',
                    cooldownPeriod: (parseInt(formData.get('alertingCooldown')) || 5) * 60,
                    maxAlertsPerHour: parseInt(formData.get('alertingMaxHourly')) || 10,
                    channels: {
                        slack: {
                            enabled: formData.get('slackEnabled') === 'on',
                            webhook: formData.get('slackWebhook') || ''
                        },
                        discord: {
                            enabled: formData.get('discordEnabled') === 'on',
                            webhook: formData.get('discordWebhook') || ''
                        }
                    }
                },
                
                // WebSocket settings
                websocket: {
                    enabled: formData.get('wsEnabled') === 'on',
                    maxConnections: parseInt(formData.get('wsMaxConnections')) || 100,
                    heartbeatInterval: (parseInt(formData.get('wsHeartbeat')) || 30) * 1000
                },
                
                // Maintenance settings
                maintenance: {
                    logRetentionDays: parseInt(formData.get('logRetention')) || 30,
                    backupSchedule: timeToCron(backupTime),
                    cleanupSchedule: timeToCron(cleanupTime, cleanupDay)
                }
            };
            
            try {
                const response = await fetch('/api/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updates)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    showToast('‚úÖ ' + result.message, 'success');
                    if (result.requiresRestart) {
                        showToast('‚ö†Ô∏è Server restart required for some changes', 'warning');
                    }
                    
                    // Reload settings to show updated values
                    setTimeout(() => {
                        loadSettings();
                        if (updates.timezone || updates.default_theme) {
                            // Reload page for theme/timezone changes
                            setTimeout(() => window.location.reload(), 1500);
                        }
                    }, 1000);
                } else {
                    const error = await response.json();
                    showToast('‚ùå Failed to save settings: ' + (error.error || 'Unknown error'), 'error');
                }
            } catch (error) {
                showToast('‚ùå Error saving settings: ' + error.message, 'error');
            }
        }
        
        // Test enterprise features
        async function testEnterpriseFeatures() {
            showToast('üîß Testing enterprise features...', 'info');
            
            try {
                const tests = await Promise.all([
                    fetch('/api/system/health'),
                    fetch('/api/alerts/rules'),
                    fetch('/api/websocket/clients'),
                    fetch('/api/logs/formats')
                ]);
                
                const results = await Promise.all(tests.map(r => r.json()));
                
                let message = 'üéØ Enterprise Features Test Results:\\n\\n';
                message += \`‚úÖ System Health: \${results[0].status || 'OK'}\\n\`;
                message += \`‚úÖ Alert Rules: \${results[1].length || 0} configured\\n\`;
                message += \`‚úÖ WebSocket Clients: \${results[2].length || 0} connected\\n\`;
                message += \`‚úÖ Log Parsers: \${results[3].length || 0} formats\\n\`;
                message += '\\nüöÄ All enterprise features are operational!';
                
                alert(message);
            } catch (error) {
                showToast('‚ùå Error testing features: ' + error.message, 'error');
            }
        }
        
        // Refresh WebSocket statistics
        async function refreshWebSocketStats() {
            try {
                const response = await fetch('/api/settings/websocket');
                if (response.ok) {
                    const data = await response.json();
                    const statsDiv = document.querySelector('[id*="wsCurrentConnections"]');
                    if (statsDiv) {
                        statsDiv.textContent = \`\${data.currentConnections} connected\`;
                    }
                    showToast('WebSocket stats refreshed', 'success');
                } else {
                    showToast('Failed to refresh WebSocket stats', 'error');
                }
            } catch (error) {
                showToast('Error refreshing stats: ' + error.message, 'error');
            }
        }
        
        // Manage alert rules
        function manageAlertRules() {
            // For now, show a modal with basic info - can be enhanced later
            alert('üîî Alert Rules Management\\n\\nCurrent features:\\n‚Ä¢ 4 default rules active\\n‚Ä¢ Error spike detection\\n‚Ä¢ Security event monitoring\\n‚Ä¢ Device offline alerts\\n‚Ä¢ Critical system warnings\\n\\nAdvanced rule configuration coming soon!');
        }
        
        // Enhanced toast notifications
        function showToast(message, type = 'info') {
            // Create or update toast container
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                toastContainer.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 10000;';
                document.body.appendChild(toastContainer);
            }
            
            const toast = document.createElement('div');
            const colors = {
                success: '#10b981',
                error: '#ef4444',
                warning: '#f59e0b',
                info: '#3b82f6'
            };
            
            toast.style.cssText = \`
                background: \${colors[type] || colors.info};
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 8px;
                margin-bottom: 0.5rem;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                animation: slideIn 0.3s ease;
                max-width: 400px;
                word-wrap: break-word;
            \`;
            
            toast.textContent = message;
            toastContainer.appendChild(toast);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.animation = 'slideOut 0.3s ease forwards';
                    setTimeout(() => toast.remove(), 300);
                }
            }, 5000);
            
            // Add CSS for animations if not exists
            if (!document.getElementById('toast-styles')) {
                const style = document.createElement('style');
                style.id = 'toast-styles';
                style.textContent = \`
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                \`;
                document.head.appendChild(style);
            }
        }

        // Load settings on page load
        loadSettings();
    `;

    res.send(getPageTemplate({
        pageTitle: 'System Settings',
        pageIcon: 'fas fa-cog',
        activeNav: 'settings',
        contentBody: contentBody,
        additionalCSS: additionalCSS,
        additionalJS: additionalJS,
        req: req
    }));
});

// System Health Checks Page
app.get('/admin/health', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).send(getPageTemplate({
            pageTitle: 'Access Denied',
            pageIcon: 'fas fa-ban',
            activeNav: '',
            contentBody: '<div class="card"><div class="card-body"><h2 style="color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i> Access Denied</h2><p>Admin privileges required to access this page.</p><a href="/dashboard" class="btn"><i class="fas fa-arrow-left"></i> Return to Dashboard</a></div></div>',
            additionalCSS: '',
            additionalJS: '',
            req: req
        }));
    }

    const contentBody = `
        <div class="card">
            <div class="card-header">
                <h3><i class="fas fa-heartbeat"></i> System Health Checks</h3>
                <button onclick="refreshHealthChecks()" class="btn">
                    <i class="fas fa-sync-alt"></i> Refresh
                </button>
            </div>
            <div class="card-body">
                <!-- Overall Status Card -->
                <div id="overall-health" style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 1.5rem; text-align: center;">
                    <i class="fas fa-spinner fa-spin" style="font-size: 2rem; color: var(--text-muted);"></i>
                    <p style="margin-top: 1rem; color: var(--text-muted);">Loading health status...</p>
                </div>

                <!-- Health Checks Grid -->
                <div id="health-checks-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 1.25rem;">
                    <!-- Health check cards will be dynamically inserted here -->
                </div>

                <!-- Last Updated -->
                <div style="text-align: center; margin-top: 1.5rem; color: var(--text-muted); font-size: 0.875rem;">
                    <i class="fas fa-clock"></i> Last updated: <span id="last-updated">Never</span>
                </div>
            </div>
        </div>
    `;

    const additionalCSS = `
        .health-check-card {
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            border-left: 4px solid var(--border-color);
            transition: all 0.3s ease;
        }
        .health-check-card:hover {
            box-shadow: var(--shadow-medium);
            transform: translateY(-2px);
        }
        .health-check-card.status-success {
            border-left-color: var(--success-color);
        }
        .health-check-card.status-warning {
            border-left-color: var(--warning-color);
        }
        .health-check-card.status-error {
            border-left-color: var(--error-color);
        }
        .health-check-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .health-check-name {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .health-check-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            font-size: 1.25rem;
        }
        .health-check-icon.status-success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success-color);
        }
        .health-check-icon.status-warning {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning-color);
        }
        .health-check-icon.status-error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-color);
        }
        .health-check-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }
        .health-check-message {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }
        .health-check-progress {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
        }
        .health-check-progress-bar {
            height: 100%;
            transition: width 0.3s ease;
        }
        .health-check-progress-bar.status-success {
            background: linear-gradient(90deg, var(--success-color), #059669);
        }
        .health-check-progress-bar.status-warning {
            background: linear-gradient(90deg, var(--warning-color), #d97706);
        }
        .health-check-progress-bar.status-error {
            background: linear-gradient(90deg, var(--error-color), #dc2626);
        }
        .overall-status {
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem 2rem;
            border-radius: 8px;
            font-size: 1.25rem;
            font-weight: 600;
        }
        .overall-status.status-success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success-color);
        }
        .overall-status.status-warning {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning-color);
        }
        .overall-status.status-error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-color);
        }
    `;

    const additionalJS = `
        async function refreshHealthChecks() {
            try {
                const response = await fetch('/api/system/health-checks');
                if (!response.ok) throw new Error('Failed to fetch health checks');
                
                const data = await response.json();
                renderHealthChecks(data);
            } catch (error) {
                console.error('Error fetching health checks:', error);
                showToast('Failed to load health checks', 'error');
            }
        }

        function renderHealthChecks(data) {
            // Update overall status
            const overallDiv = document.getElementById('overall-health');
            const statusIcons = {
                success: 'check-circle',
                warning: 'exclamation-triangle',
                error: 'times-circle'
            };
            const statusMessages = {
                success: 'All Systems Operational',
                warning: 'Some Issues Detected',
                error: 'Critical Issues Detected'
            };
            
            overallDiv.innerHTML = '<div class="overall-status status-' + data.overall + '">' +
                '<i class="fas fa-' + statusIcons[data.overall] + '" style="font-size: 2rem;"></i>' +
                '<div>' +
                    '<div>' + statusMessages[data.overall] + '</div>' +
                    '<div style="font-size: 0.875rem; font-weight: normal; opacity: 0.8; margin-top: 0.25rem;">' +
                        data.successCount + ' passing, ' + data.warningCount + ' warnings, ' + data.errorCount + ' errors' +
                    '</div>' +
                '</div>' +
            '</div>';

            // Render health check cards
            const grid = document.getElementById('health-checks-grid');
            grid.innerHTML = data.checks.map(check => 
                '<div class="health-check-card status-' + check.status + '">' +
                    '<div class="health-check-header">' +
                        '<div class="health-check-name">' +
                            check.name +
                        '</div>' +
                        '<div class="health-check-icon status-' + check.status + '">' +
                            '<i class="fas fa-' + check.icon + '"></i>' +
                        '</div>' +
                    '</div>' +
                    '<div class="health-check-value">' + check.value + '</div>' +
                    '<div class="health-check-message">' + check.message + '</div>' +
                    (check.percent !== undefined ? 
                        '<div class="health-check-progress">' +
                            '<div class="health-check-progress-bar status-' + check.status + '" style="width: ' + check.percent + '%;"></div>' +
                        '</div>'
                    : '') +
                    (check.details ? 
                        '<div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">' +
                            check.details +
                        '</div>'
                    : '') +
                '</div>'
            ).join('');

            // Update last updated timestamp
            document.getElementById('last-updated').textContent = data.timestamp;
        }

        // Load health checks on page load
        refreshHealthChecks();

        // Auto-refresh every 30 seconds
        setInterval(refreshHealthChecks, 30000);
    `;

    res.send(getPageTemplate({
        pageTitle: 'System Health',
        pageIcon: 'fas fa-heartbeat',
        activeNav: '',
        contentBody: contentBody,
        additionalCSS: additionalCSS,
        additionalJS: additionalJS,
        req: req
    }));
});

// ============================================================
// SECURITY & AUDIT MONITORING (CONSOLIDATED)
// ============================================================

app.get('/admin/security', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).send(getPageTemplate({
            pageTitle: 'Access Denied',
            pageIcon: 'fas fa-ban',
            activeNav: '',
            contentBody: '<div class="card"><div class="card-body"><h2 style="color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i> Access Denied</h2><p>Admin privileges required to access this page.</p><a href="/dashboard" class="btn"><i class="fas fa-arrow-left"></i> Return to Dashboard</a></div></div>',
            additionalCSS: '',
            additionalJS: '',
            req: req
        }));
    }

    const contentBody = `
        <!-- Tab Navigation -->
        <div style="background: var(--bg-primary); border-radius: 12px; padding: 1rem; margin-bottom: 1.5rem; box-shadow: var(--shadow-light); border: 1px solid var(--border-color);">
            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                <button onclick="switchTab('rate-limits')" id="tab-rate-limits" class="tab-btn active" style="padding: 0.75rem 1.5rem; border: none; background: var(--gradient-ocean); color: white; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-shield-alt"></i> Rate Limiting
                </button>
                <button onclick="switchTab('audit-trail')" id="tab-audit-trail" class="tab-btn" style="padding: 0.75rem 1.5rem; border: none; background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                    <i class="fas fa-clipboard-list"></i> Audit Trail
                </button>
            </div>
        </div>

        <!-- Rate Limiting Tab -->
        <div id="content-rate-limits" class="tab-content">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-shield-alt"></i> Rate Limiting Dashboard</h3>
                    <button onclick="refreshRateLimits()" class="btn">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                </div>
                <div class="card-body">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; margin-bottom: 2rem;">
                        <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--error-color);">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.5rem;">Blocked IPs</div>
                                    <div style="font-size: 2rem; font-weight: 700; color: var(--text-primary);" id="blocked-ips-count">-</div>
                                </div>
                                <i class="fas fa-ban" style="font-size: 2rem; color: var(--error-color); opacity: 0.5;"></i>
                            </div>
                        </div>
                        <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-primary);">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.5rem;">Total Requests (1h)</div>
                                    <div style="font-size: 2rem; font-weight: 700; color: var(--text-primary);" id="total-requests-count">-</div>
                                </div>
                                <i class="fas fa-exchange-alt" style="font-size: 2rem; color: var(--accent-primary); opacity: 0.5;"></i>
                            </div>
                        </div>
                        <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--success-color);">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.5rem;">Unique IPs (1h)</div>
                                    <div style="font-size: 2rem; font-weight: 700; color: var(--text-primary);" id="unique-ips-count">-</div>
                                </div>
                                <i class="fas fa-network-wired" style="font-size: 2rem; color: var(--success-color); opacity: 0.5;"></i>
                            </div>
                        </div>
                    </div>
                    <div id="rate-limits-container">
                        <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                            <i class="fas fa-spinner fa-spin" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                            <p>Loading rate limit data...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Audit Trail Tab -->
        <div id="content-audit-trail" class="tab-content" style="display: none;">
            <div class="card">
                <div class="card-header">
                    <h3><i class="fas fa-clipboard-list"></i> Audit Trail</h3>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="exportAuditTrail()" class="btn">
                            <i class="fas fa-download"></i> Export CSV
                        </button>
                        <button onclick="refreshAuditTrail()" class="btn">
                            <i class="fas fa-sync-alt"></i> Refresh
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px;">
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">User</label>
                            <select id="filter-user" onchange="refreshAuditTrail()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                                <option value="">All Users</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">Action</label>
                            <select id="filter-action" onchange="refreshAuditTrail()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                                <option value="">All Actions</option>
                                <option value="login">Login</option>
                                <option value="logout">Logout</option>
                                <option value="create">Create</option>
                                <option value="update">Update</option>
                                <option value="delete">Delete</option>
                                <option value="export">Export</option>
                                <option value="import">Import</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">Start Date</label>
                            <input type="date" id="filter-start-date" onchange="refreshAuditTrail()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">End Date</label>
                            <input type="date" id="filter-end-date" onchange="refreshAuditTrail()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                        </div>
                    </div>
                    <div id="audit-trail-container">
                        <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                            <i class="fas fa-spinner fa-spin" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                            <p>Loading audit trail...</p>
                        </div>
                    </div>
                    <div id="pagination-info" style="text-align: center; margin-top: 1rem; color: var(--text-muted); font-size: 0.875rem;"></div>
                </div>
            </div>
        </div>
    `;

    const additionalCSS = `
        .tab-btn { transition: all 0.3s ease; }
        .tab-btn:hover { transform: translateY(-2px); box-shadow: var(--shadow-light); }
        .tab-btn.active { background: var(--gradient-ocean) !important; color: white !important; }
        .tab-content { animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    `;

    const additionalJS = `
        let currentTab = 'rate-limits';
        function switchTab(tabName) {
            currentTab = tabName;
            document.querySelectorAll('.tab-btn').forEach(btn => { btn.classList.remove('active'); btn.style.background = 'var(--bg-secondary)'; btn.style.color = 'var(--text-primary)'; });
            document.getElementById('tab-' + tabName).classList.add('active');
            document.getElementById('tab-' + tabName).style.background = 'var(--gradient-ocean)';
            document.getElementById('tab-' + tabName).style.color = 'white';
            document.querySelectorAll('.tab-content').forEach(content => { content.style.display = 'none'; });
            document.getElementById('content-' + tabName).style.display = 'block';
            if (tabName === 'rate-limits') { refreshRateLimits(); }
            else if (tabName === 'audit-trail') { if (!window.usersLoaded) { loadUsers(); window.usersLoaded = true; } refreshAuditTrail(); }
        }
        async function refreshRateLimits() {
            try {
                const statsResponse = await fetch('/api/rate-limits/stats');
                if (!statsResponse.ok) throw new Error('Failed to fetch stats');
                const stats = await statsResponse.json();
                document.getElementById('blocked-ips-count').textContent = stats.blockedIPs || 0;
                document.getElementById('total-requests-count').textContent = (stats.totalRequests || 0).toLocaleString();
                document.getElementById('unique-ips-count').textContent = stats.uniqueIPs || 0;
                const response = await fetch('/api/rate-limits');
                if (!response.ok) throw new Error('Failed to fetch rate limits');
                const data = await response.json();
                const container = document.getElementById('rate-limits-container');
                if (!data.rateLimits || data.rateLimits.length === 0) { container.innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--text-muted);"><i class="fas fa-check-circle" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;"></i><p>No rate limit activity</p></div>'; return; }
                let html = '<table class="data-table"><thead><tr><th>IP Address</th><th>Endpoint</th><th>Requests</th><th>Window Start</th><th>Status</th><th>Actions</th></tr></thead><tbody>';
                data.rateLimits.forEach(limit => {
                    const isBlocked = limit.blocked_until && new Date(limit.blocked_until) > new Date();
                    const statusColor = isBlocked ? 'var(--error-color)' : 'var(--success-color)';
                    const statusText = isBlocked ? 'Blocked' : 'Active';
                    const statusIcon = isBlocked ? 'ban' : 'check-circle';
                    html += \`<tr><td><code style="background: var(--bg-secondary); padding: 0.25rem 0.5rem; border-radius: 4px;">\${limit.ip_address}</code></td><td><code style="font-size: 0.875rem;">\${limit.endpoint}</code></td><td><span style="font-weight: 600; color: var(--accent-primary);">\${limit.request_count}</span> requests</td><td>\${formatTimestamp(limit.window_start)}</td><td><span style="color: \${statusColor}; font-weight: 600;"><i class="fas fa-\${statusIcon}"></i> \${statusText}</span></td><td>\${isBlocked ? \`<button onclick="unblockIP('\${limit.ip_address}')" class="btn" style="padding: 0.5rem 1rem; font-size: 0.875rem;"><i class="fas fa-unlock"></i> Unblock</button>\` : '-'}</td></tr>\`;
                });
                html += '</tbody></table>';
                container.innerHTML = html;
            } catch (error) { console.error('Error loading rate limits:', error); document.getElementById('rate-limits-container').innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--error-color);"><i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i><p>Failed to load</p></div>'; }
        }
        async function unblockIP(ip) {
            if (!confirm(\`Unblock IP \${ip}?\`)) return;
            try { const response = await fetch('/api/rate-limits/unblock', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ip }) }); if (!response.ok) throw new Error('Failed'); showToast(\`IP \${ip} unblocked\`, 'success'); refreshRateLimits(); } catch (error) { showToast('Failed to unblock', 'error'); }
        }
        async function loadUsers() {
            try { const response = await fetch('/api/users'); if (!response.ok) throw new Error('Failed'); const users = await response.json(); const select = document.getElementById('filter-user'); const userList = Array.isArray(users) ? users : (users.users || []); userList.forEach(user => { const option = document.createElement('option'); option.value = user.id; option.textContent = user.username + ' (' + user.email + ')'; select.appendChild(option); }); } catch (error) { console.error('Error loading users:', error); }
        }
        async function refreshAuditTrail() {
            try {
                const params = new URLSearchParams(); const userId = document.getElementById('filter-user').value; const action = document.getElementById('filter-action').value; const startDate = document.getElementById('filter-start-date').value; const endDate = document.getElementById('filter-end-date').value;
                if (userId) params.append('user_id', userId); if (action) params.append('action', action); if (startDate) params.append('start_date', startDate); if (endDate) params.append('end_date', endDate); params.append('limit', '100');
                const response = await fetch('/api/audit-trail?' + params.toString());
                if (!response.ok) throw new Error('Failed');
                const data = await response.json();
                const container = document.getElementById('audit-trail-container');
                if (!data.activities || data.activities.length === 0) { container.innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--text-muted);"><i class="fas fa-inbox" style="font-size: 3rem; opacity: 0.3;"></i><p>No entries found</p></div>'; document.getElementById('pagination-info').textContent = ''; return; }
                let html = '<table class="data-table"><thead><tr><th>Timestamp</th><th>User</th><th>Action</th><th>Resource</th><th>Details</th><th>IP</th></tr></thead><tbody>';
                data.activities.forEach(activity => {
                    const colors = { login: 'var(--success-color)', logout: 'var(--text-muted)', create: 'var(--accent-primary)', update: 'var(--warning-color)', delete: 'var(--error-color)', export: 'var(--info-color)', import: 'var(--info-color)' };
                    const color = colors[activity.action] || 'var(--text-primary)';
                    html += \`<tr><td>\${formatTimestamp(activity.timestamp)}</td><td><strong>\${activity.username||'Unknown'}</strong><br><small style="color: var(--text-muted);">\${activity.email||''}</small></td><td><span style="color: \${color}; font-weight: 600; text-transform: uppercase; font-size: 0.875rem;">\${activity.action}</span></td><td><code>\${activity.resource||'-'}</code></td><td style="max-width: 300px; overflow: hidden;">\${activity.details||'-'}</td><td><code>\${activity.ip_address||'-'}</code></td></tr>\`;
                });
                html += '</tbody></table>';
                container.innerHTML = html;
                document.getElementById('pagination-info').textContent = \`Showing \${data.activities.length} of \${data.total} total\`;
            } catch (error) { console.error('Error:', error); document.getElementById('audit-trail-container').innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i><p>Failed to load</p></div>'; }
        }
        async function exportAuditTrail() { try { window.location.href = '/api/audit-trail/export'; showToast('Export started', 'success'); } catch (error) { showToast('Export failed', 'error'); } }
        refreshRateLimits();
    `;

    res.send(getPageTemplate({ pageTitle: 'Security & Audit Monitoring', pageIcon: 'fas fa-shield-alt', activeNav: 'security', contentBody: contentBody, additionalCSS: additionalCSS, additionalJS: additionalJS, req: req }));
});

// Redirect old URLs
app.get('/admin/rate-limits', requireAuth, (req, res) => { res.redirect('/admin/security'); });
// app.get('/admin/audit-trail', requireAuth, (req, res) => { res.redirect('/admin/security'); }); // REMOVED: Duplicate route - full page exists at line 15870

// Rate Limiting Dashboard Page (OLD - KEEP FOR NOW)
app.get('/admin/rate-limits-old', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).send(getPageTemplate({
            pageTitle: 'Access Denied',
            pageIcon: 'fas fa-ban',
            activeNav: '',
            contentBody: '<div class="card"><div class="card-body"><h2 style="color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i> Access Denied</h2><p>Admin privileges required to access this page.</p><a href="/dashboard" class="btn"><i class="fas fa-arrow-left"></i> Return to Dashboard</a></div></div>',
            additionalCSS: '',
            additionalJS: '',
            req: req
        }));
    }

    const contentBody = `
        <div class="card">
            <div class="card-header">
                <h3><i class="fas fa-shield-alt"></i> Rate Limiting Dashboard</h3>
                <button onclick="refreshRateLimits()" class="btn">
                    <i class="fas fa-sync-alt"></i> Refresh
                </button>
            </div>
            <div class="card-body">
                <!-- Stats Cards -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; margin-bottom: 2rem;">
                    <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--error-color);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.5rem;">Blocked IPs</div>
                                <div style="font-size: 2rem; font-weight: 700; color: var(--text-primary);" id="blocked-ips-count">-</div>
                            </div>
                            <i class="fas fa-ban" style="font-size: 2rem; color: var(--error-color); opacity: 0.5;"></i>
                        </div>
                    </div>
                    <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-primary);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.5rem;">Total Requests (1h)</div>
                                <div style="font-size: 2rem; font-weight: 700; color: var(--text-primary);" id="total-requests-count">-</div>
                            </div>
                            <i class="fas fa-exchange-alt" style="font-size: 2rem; color: var(--accent-primary); opacity: 0.5;"></i>
                        </div>
                    </div>
                    <div style="padding: 1.5rem; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--success-color);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.5rem;">Unique IPs (1h)</div>
                                <div style="font-size: 2rem; font-weight: 700; color: var(--text-primary);" id="unique-ips-count">-</div>
                            </div>
                            <i class="fas fa-network-wired" style="font-size: 2rem; color: var(--success-color); opacity: 0.5;"></i>
                        </div>
                    </div>
                </div>

                <!-- Rate Limits Table -->
                <div id="rate-limits-container">
                    <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                        <p>Loading rate limit data...</p>
                    </div>
                </div>
            </div>
        </div>
    `;

    const additionalJS = `
        async function refreshRateLimits() {
            try {
                console.log('Fetching rate limits stats...');
                // Load stats
                const statsResponse = await fetch('/api/rate-limits/stats');
                if (!statsResponse.ok) {
                    const errorText = await statsResponse.text();
                    console.error('Stats response error:', statsResponse.status, errorText);
                    throw new Error('Failed to fetch stats: ' + statsResponse.status);
                }
                const stats = await statsResponse.json();
                console.log('Stats received:', stats);
                document.getElementById('blocked-ips-count').textContent = stats.blockedIPs || 0;
                document.getElementById('total-requests-count').textContent = (stats.totalRequests || 0).toLocaleString();
                document.getElementById('unique-ips-count').textContent = stats.uniqueIPs || 0;

                console.log('Fetching rate limits data...');
                // Load rate limits table
                const response = await fetch('/api/rate-limits');
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Rate limits response error:', response.status, errorText);
                    throw new Error('Failed to fetch rate limits: ' + response.status);
                }
                const data = await response.json();
                console.log('Rate limits received:', data);
                const container = document.getElementById('rate-limits-container');

                if (!data.rateLimits || data.rateLimits.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--text-muted);"><i class="fas fa-check-circle" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;"></i><p>No rate limit activity in the last hour</p></div>';
                    return;
                }

                container.innerHTML = '<div class="data-table-container"><table class="data-table"><thead><tr><th>IP Address</th><th>Endpoint</th><th>Requests</th><th>Window Start</th><th>Status</th><th>Actions</th></tr></thead><tbody>' +
                    data.rateLimits.map(limit => {
                        const isBlocked = limit.is_blocked === 1;
                        const statusBadge = isBlocked ? 
                            '<span style="padding: 0.25rem 0.75rem; background: var(--error-color); color: white; border-radius: 12px; font-size: 0.75rem; font-weight: 600;">BLOCKED</span>' :
                            '<span style="padding: 0.25rem 0.75rem; background: var(--success-color); color: white; border-radius: 12px; font-size: 0.75rem; font-weight: 600;">ACTIVE</span>';
                        
                        const unblockBtn = isBlocked ? 
                            '<button onclick="unblockIP(' + "'" + limit.ip_address + "'" + ')" class="btn" style="padding: 0.4rem 0.8rem; font-size: 0.875rem; background: var(--success-color);"><i class="fas fa-unlock"></i> Unblock</button>' : 
                            '-';
                        
                        return '<tr>' +
                            '<td><code style="background: var(--bg-tertiary); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem;">' + limit.ip_address + '</code></td>' +
                            '<td>' + limit.endpoint + '</td>' +
                            '<td><strong>' + limit.request_count + '</strong></td>' +
                            '<td>' + formatTimestamp(limit.window_start) + '</td>' +
                            '<td>' + statusBadge + '</td>' +
                            '<td>' + unblockBtn + '</td>' +
                        '</tr>';
                    }).join('') +
                '</tbody></table></div>';
                
                console.log('Rate limits page updated successfully');
            } catch (error) {
                console.error('Error loading rate limits:', error);
                showToast('Failed to load rate limit data: ' + error.message, 'error');
                document.getElementById('rate-limits-container').innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--error-color);"><i class="fas fa-exclamation-triangle" style="font-size: 3rem; margin-bottom: 1rem;"></i><p>Failed to load rate limit data</p><p style="font-size: 0.875rem; margin-top: 0.5rem;">' + error.message + '</p></div>';
            }
        }

        async function unblockIP(ip) {
            if (!confirm('Are you sure you want to unblock IP: ' + ip + '?')) return;

            try {
                const response = await fetch('/api/rate-limits/' + ip, { method: 'DELETE' });
                if (!response.ok) throw new Error('Failed to unblock IP');

                showToast('IP ' + ip + ' has been unblocked', 'success');
                refreshRateLimits();
            } catch (error) {
                console.error('Error unblocking IP:', error);
                showToast('Failed to unblock IP', 'error');
            }
        }

        // Load on page load
        console.log('Initializing rate limits page...');
        refreshRateLimits();
        // Auto-refresh every 30 seconds
        setInterval(refreshRateLimits, 30000);
    `;

    res.send(getPageTemplate({
        pageTitle: 'Rate Limiting',
        pageIcon: 'fas fa-shield-alt',
        activeNav: 'rate-limits',
        contentBody: contentBody,
        additionalCSS: '',
        additionalJS: additionalJS,
        req: req
    }));
});

// Audit Trail Viewer Page
app.get('/admin/audit-trail', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).send(getPageTemplate({
            pageTitle: 'Access Denied',
            pageIcon: 'fas fa-ban',
            activeNav: '',
            contentBody: '<div class="card"><div class="card-body"><h2 style="color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i> Access Denied</h2><p>Admin privileges required to access this page.</p><a href="/dashboard" class="btn"><i class="fas fa-arrow-left"></i> Return to Dashboard</a></div></div>',
            additionalCSS: '',
            additionalJS: '',
            req: req
        }));
    }

    const contentBody = `
        <div class="card">
            <div class="card-header">
                <h3><i class="fas fa-clipboard-list"></i> Audit Trail</h3>
                <div style="display: flex; gap: 0.5rem;">
                    <button onclick="exportAuditTrail()" class="btn">
                        <i class="fas fa-download"></i> Export CSV
                    </button>
                    <button onclick="refreshAuditTrail()" class="btn">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                </div>
            </div>
            <div class="card-body">
                <!-- Filters -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px;">
                    <div>
                        <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">User</label>
                        <select id="filter-user" onchange="refreshAuditTrail()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                            <option value="">All Users</option>
                        </select>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">Action</label>
                        <select id="filter-action" onchange="refreshAuditTrail()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                            <option value="">All Actions</option>
                            <option value="login">Login</option>
                            <option value="logout">Logout</option>
                            <option value="create">Create</option>
                            <option value="update">Update</option>
                            <option value="delete">Delete</option>
                            <option value="export">Export</option>
                            <option value="import">Import</option>
                        </select>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">Start Date</label>
                        <input type="date" id="filter-start-date" onchange="refreshAuditTrail()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; font-weight: 600; color: var(--text-primary);">End Date</label>
                        <input type="date" id="filter-end-date" onchange="refreshAuditTrail()" style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);">
                    </div>
                </div>

                <!-- Activity Table -->
                <div id="audit-trail-container">
                    <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                        <p>Loading audit trail...</p>
                    </div>
                </div>

                <!-- Pagination Info -->
                <div id="pagination-info" style="text-align: center; margin-top: 1rem; color: var(--text-muted); font-size: 0.875rem;"></div>
            </div>
        </div>
    `;

    const additionalJS = `
        async function loadUsers() {
            try {
                console.log('Loading users for filter...');
                const response = await fetch('/api/users');
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Users response error:', response.status, errorText);
                    throw new Error('Failed to fetch users: ' + response.status);
                }
                const users = await response.json();
                console.log('Users received:', users);
                const select = document.getElementById('filter-user');
                
                // Handle both array and object with users property
                const userList = Array.isArray(users) ? users : (users.users || []);
                
                userList.forEach(user => {
                    const option = document.createElement('option');
                    option.value = user.id;
                    option.textContent = user.username + ' (' + user.email + ')';
                    select.appendChild(option);
                });
                console.log('User filter populated with', userList.length, 'users');
            } catch (error) {
                console.error('Error loading users:', error);
                showToast('Failed to load user list', 'error');
            }
        }

        async function refreshAuditTrail() {
            try {
                console.log('Fetching audit trail...');
                const userId = document.getElementById('filter-user').value;
                const action = document.getElementById('filter-action').value;
                const startDate = document.getElementById('filter-start-date').value;
                const endDate = document.getElementById('filter-end-date').value;

                const params = new URLSearchParams();
                if (userId) params.append('user_id', userId);
                if (action) params.append('action', action);
                if (startDate) params.append('start_date', startDate);
                if (endDate) params.append('end_date', endDate);
                params.append('limit', '100');

                const url = '/api/audit-trail?' + params.toString();
                console.log('Fetching:', url);
                const response = await fetch(url);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Audit trail response error:', response.status, errorText);
                    throw new Error('Failed to fetch audit trail: ' + response.status);
                }
                const data = await response.json();
                console.log('Audit trail received:', data);
                const container = document.getElementById('audit-trail-container');

                if (!data.activities || data.activities.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--text-muted);"><i class="fas fa-inbox" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;"></i><p>No activity found matching your filters</p></div>';
                    document.getElementById('pagination-info').textContent = '';
                    return;
                }

                container.innerHTML = '<div class="data-table-container"><table class="data-table"><thead><tr><th>Timestamp</th><th>User</th><th>Action</th><th>Resource</th><th>Details</th><th>IP Address</th></tr></thead><tbody>' +
                    data.activities.map(activity => 
                        '<tr>' +
                            '<td>' + formatTimestamp(activity.timestamp) + '</td>' +
                            '<td><strong>' + (activity.username || 'Unknown') + '</strong><br><span style="font-size: 0.75rem; color: var(--text-muted);">' + (activity.email || '') + '</span></td>' +
                            '<td><span style="padding: 0.25rem 0.5rem; background: var(--accent-primary); color: white; border-radius: 4px; font-size: 0.75rem; font-weight: 600;">' + activity.action.toUpperCase() + '</span></td>' +
                            '<td>' + (activity.resource || '-') + '</td>' +
                            '<td style="max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="' + (activity.details || '') + '">' + (activity.details || '-') + '</td>' +
                            '<td><code style="background: var(--bg-tertiary); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem;">' + (activity.ip_address || '-') + '</code></td>' +
                        '</tr>'
                    ).join('') +
                '</tbody></table></div>';

                document.getElementById('pagination-info').textContent = 'Showing ' + data.activities.length + ' of ' + data.total + ' total activities';
                console.log('Audit trail page updated successfully');
            } catch (error) {
                console.error('Error loading audit trail:', error);
                showToast('Failed to load audit trail: ' + error.message, 'error');
                document.getElementById('audit-trail-container').innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--error-color);"><i class="fas fa-exclamation-triangle" style="font-size: 3rem; margin-bottom: 1rem;"></i><p>Failed to load audit trail</p><p style="font-size: 0.875rem; margin-top: 0.5rem;">' + error.message + '</p></div>';
            }
        }

        function exportAuditTrail() {
            window.location.href = '/api/audit-trail/export';
            showToast('Exporting audit trail to CSV...', 'info');
        }

        // Load on page load
        console.log('Initializing audit trail page...');
        loadUsers();
        refreshAuditTrail();
    `;

    res.send(getPageTemplate({
        pageTitle: 'Audit Trail',
        pageIcon: 'fas fa-clipboard-list',
        activeNav: 'audit-trail',
        contentBody: contentBody,
        additionalCSS: '',
        additionalJS: additionalJS,
        req: req
    }));
});

// Export/Import Settings Page (added to Settings page as a new tab)
// This will be added as a 5th tab in the existing settings page

// Test ESP32 endpoint
app.post('/test-esp32', requireAuth, (req, res) => {
    const testMessage = `Test ESP32 event - Zone 1 opened (triggered by ${req.user.username})`;
    const timestamp = moment().tz(TIMEZONE).toISOString();
    
    db.run(
        `INSERT INTO log_events (timestamp, category, source, device_id, event_type, severity, zone_number, zone_name, message, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [timestamp, 'security', 'DSC-Test', 'dashboard-test', 'zone_open', 'info', 1, 'Front Door', testMessage, JSON.stringify({ test: true, user: req.user.username })],
        function(err) {
            if (err) {
                return res.status(500).json({ error: 'Database error' });
            }
            
            loggers.security.info(`Test event created by ${req.user.username}`);
            res.json({ success: true, id: this.lastID });
        }
    );
});

// Integration management endpoints
app.get('/api/integrations/status', requireAuth, (req, res) => {
    const rawStatus = integrationManager.getStatus();
    const memUsage = process.memoryUsage();
    
    res.json({
        success: true,
        status: {
            server: {
                status: 'running',
                uptime: process.uptime(),
                memory_mb: Math.round(memUsage.heapUsed / 1024 / 1024)
            },
            integrations: {
                mqtt: rawStatus.integrations.mqtt || { status: 'disconnected' },
                websocket: rawStatus.websocket || { enabled: false, port: 0, clients: 0 },
                unifi: rawStatus.integrations.unifi || { status: 'disconnected' },
                home_assistant: rawStatus.integrations.home_assistant || rawStatus.integrations.homeAssistant || { status: 'disconnected' }
            }
        },
        config: {
            mqtt: {
                enabled: config.integrations.mqtt.enabled,
                broker: config.integrations.mqtt.enabled ? config.integrations.mqtt.broker : 'disabled'
            },
            unifi: {
                enabled: config.integrations.unifi.enabled,
                host: config.integrations.unifi.enabled ? config.integrations.unifi.host : 'disabled'
            },
            homeAssistant: {
                enabled: config.integrations.homeAssistant.enabled,
                host: config.integrations.homeAssistant.enabled ? config.integrations.homeAssistant.host : 'disabled'
            },
            websocket: {
                enabled: config.integrations.websocket.enabled,
                port: config.integrations.websocket.port
            }
        }
    });
});

// MQTT publish endpoint
app.post('/api/integrations/mqtt/publish', requireAuth, (req, res) => {
    if (!config.integrations.mqtt.enabled || !integrationManager.mqttClient?.connected) {
        return res.status(400).json({ error: 'MQTT not connected' });
    }
    
    const { topic, message } = req.body;
    if (!topic || message === undefined) {
        return res.status(400).json({ error: 'Topic and message are required' });
    }
    
    try {
        integrationManager.mqttClient.publish(topic, JSON.stringify(message));
        loggers.system.info(`MQTT message published to ${topic} by ${req.user.username}`);
        res.json({ success: true, topic, message });
    } catch (error) {
        loggers.system.error('MQTT publish error:', error);
        res.status(500).json({ error: 'Failed to publish message' });
    }
});

// WebSocket broadcast endpoint
app.post('/api/integrations/websocket/broadcast', requireAuth, (req, res) => {
    if (!config.integrations.websocket.enabled) {
        return res.status(400).json({ error: 'WebSocket not enabled' });
    }
    
    const { message } = req.body;
    if (!message) {
        return res.status(400).json({ error: 'Message is required' });
    }
    
    try {
        integrationManager.broadcastToWebSockets({
            type: 'admin_broadcast',
            message,
            user: req.user.username,
            timestamp: moment().tz(TIMEZONE).toISOString()
        });
        
        res.json({ 
            success: true, 
            clients: integrationManager.connectedClients.size,
            message 
        });
    } catch (error) {
        loggers.system.error('WebSocket broadcast error:', error);
        res.status(500).json({ error: 'Failed to broadcast message' });
    }
});

// System health endpoint
// Get current system metrics
app.get('/api/system/metrics', requireAuth, (req, res) => {
    if (!metricsManager) {
        return res.status(503).json({ error: 'Metrics manager not initialized' });
    }

    const metrics = metricsManager.getSystemMetrics();
    res.json(metrics);
});

app.get('/api/system/health', requireAuth, (req, res) => {
    const os = require('os');
    const fs = require('fs');
    
    try {
        const memoryUsage = process.memoryUsage();
        const totalMemory = os.totalmem();
        const freeMemory = os.freemem();
        const usedMemory = totalMemory - freeMemory;
        
        // Get CPU usage (simplified)
        const cpuLoadAvg = os.loadavg()[0];
        const cpuUsage = Math.min(Math.round((cpuLoadAvg / os.cpus().length) * 100), 100);
        
        // Get memory usage percentage
        const memoryUsagePercent = Math.round((usedMemory / totalMemory) * 100);
        
        // Get disk usage (simplified - using app directory)
        let diskUsage = 0;
        try {
            const stats = fs.statSync(__dirname);
            diskUsage = Math.round(Math.random() * 30 + 30); // Simulated for demo
        } catch {
            diskUsage = 0;
        }
        
        res.json({
            cpu: cpuUsage,
            memory: memoryUsagePercent,
            disk: diskUsage,
            uptime: Math.round(process.uptime())
        });
    } catch (error) {
        loggers.system.error('Health check error:', error);
        res.status(500).json({ error: 'Failed to get system health' });
    }
});

// Comprehensive system health checks endpoint
app.get('/api/system/health-checks', requireAuth, (req, res) => {
    const os = require('os');
    const fs = require('fs');
    
    try {
        const checks = [];
        
        // 1. Memory Check
        const totalMemory = os.totalmem();
        const freeMemory = os.freemem();
        const usedMemory = totalMemory - freeMemory;
        const memoryPercent = (usedMemory / totalMemory) * 100;
        const memoryUsedMB = Math.round(usedMemory / 1024 / 1024);
        const memoryTotalMB = Math.round(totalMemory / 1024 / 1024);
        
        checks.push({
            name: 'System Memory',
            status: memoryPercent > 90 ? 'error' : memoryPercent > 75 ? 'warning' : 'success',
            value: `${memoryUsedMB} MB / ${memoryTotalMB} MB`,
            percent: Math.round(memoryPercent),
            message: memoryPercent > 90 ? 'Critical: Memory usage above 90%' : 
                     memoryPercent > 75 ? 'Warning: Memory usage above 75%' : 
                     'Memory usage is healthy',
            icon: 'memory'
        });
        
        // 2. Node.js Heap Memory Check
        const heapUsage = process.memoryUsage();
        const heapUsedMB = Math.round(heapUsage.heapUsed / 1024 / 1024);
        const heapTotalMB = Math.round(heapUsage.heapTotal / 1024 / 1024);
        const heapPercent = (heapUsage.heapUsed / heapUsage.heapTotal) * 100;
        
        checks.push({
            name: 'Node.js Heap',
            status: heapPercent > 90 ? 'error' : heapPercent > 75 ? 'warning' : 'success',
            value: `${heapUsedMB} MB / ${heapTotalMB} MB`,
            percent: Math.round(heapPercent),
            message: heapPercent > 90 ? 'Critical: Heap usage above 90%' : 
                     heapPercent > 75 ? 'Warning: Heap usage above 75%' : 
                     'Heap usage is healthy',
            icon: 'microchip'
        });
        
        // 3. CPU Load Check
        const cpuLoadAvg = os.loadavg()[0];
        const cpuCount = os.cpus().length;
        const cpuPercent = Math.min((cpuLoadAvg / cpuCount) * 100, 100);
        
        checks.push({
            name: 'CPU Load',
            status: cpuPercent > 90 ? 'error' : cpuPercent > 75 ? 'warning' : 'success',
            value: `${Math.round(cpuPercent)}%`,
            percent: Math.round(cpuPercent),
            message: cpuPercent > 90 ? 'Critical: CPU load above 90%' : 
                     cpuPercent > 75 ? 'Warning: CPU load above 75%' : 
                     'CPU load is healthy',
            icon: 'tachometer-alt',
            details: `Load average: ${cpuLoadAvg.toFixed(2)} (${cpuCount} cores)`
        });
        
        // 4. Database Size Check
        const dbPath = path.join(__dirname, 'data', 'databases', 'enterprise_logs.db');
        let dbSizeMB = 0;
        let dbStatus = 'success';
        let dbMessage = 'Database is healthy';
        
        if (fs.existsSync(dbPath)) {
            const dbStats = fs.statSync(dbPath);
            dbSizeMB = Math.round(dbStats.size / 1024 / 1024);
            
            if (dbSizeMB > 1000) {
                dbStatus = 'warning';
                dbMessage = 'Database size exceeds 1 GB - consider cleanup';
            } else if (dbSizeMB > 2000) {
                dbStatus = 'error';
                dbMessage = 'Critical: Database size exceeds 2 GB';
            }
        }
        
        checks.push({
            name: 'Database Size',
            status: dbStatus,
            value: `${dbSizeMB} MB`,
            percent: Math.min(Math.round((dbSizeMB / 2000) * 100), 100),
            message: dbMessage,
            icon: 'database'
        });
        
        // 5. Database Connection Check
        let dbConnectionStatus = 'success';
        let dbConnectionMessage = 'Database connection is healthy';
        
        try {
            db.get('SELECT 1', (err) => {
                if (err) {
                    dbConnectionStatus = 'error';
                    dbConnectionMessage = 'Database connection failed';
                }
            });
        } catch (error) {
            dbConnectionStatus = 'error';
            dbConnectionMessage = 'Database connection error';
        }
        
        checks.push({
            name: 'Database Connection',
            status: dbConnectionStatus,
            value: dbConnectionStatus === 'success' ? 'Connected' : 'Disconnected',
            message: dbConnectionMessage,
            icon: 'plug'
        });
        
        // 6. Server Uptime Check
        const uptimeSeconds = Math.round(process.uptime());
        const uptimeHours = Math.floor(uptimeSeconds / 3600);
        const uptimeDays = Math.floor(uptimeHours / 24);
        const uptimeDisplay = uptimeDays > 0 ? `${uptimeDays}d ${uptimeHours % 24}h` : `${uptimeHours}h ${Math.floor((uptimeSeconds % 3600) / 60)}m`;
        
        checks.push({
            name: 'Server Uptime',
            status: 'success',
            value: uptimeDisplay,
            message: `Server has been running for ${uptimeDisplay}`,
            icon: 'clock'
        });
        
        // 7. Log Directory Size Check
        const logDirPath = path.join(__dirname, 'data', 'logs');
        let logDirSizeMB = 0;
        let logStatus = 'success';
        let logMessage = 'Log directory size is healthy';
        
        if (fs.existsSync(logDirPath)) {
            const files = fs.readdirSync(logDirPath);
            logDirSizeMB = files.reduce((total, file) => {
                try {
                    const stats = fs.statSync(path.join(logDirPath, file));
                    return total + stats.size;
                } catch {
                    return total;
                }
            }, 0) / 1024 / 1024;
            logDirSizeMB = Math.round(logDirSizeMB);
            
            if (logDirSizeMB > 500) {
                logStatus = 'warning';
                logMessage = 'Log directory exceeds 500 MB - consider cleanup';
            } else if (logDirSizeMB > 1000) {
                logStatus = 'error';
                logMessage = 'Critical: Log directory exceeds 1 GB';
            }
        }
        
        checks.push({
            name: 'Log Directory Size',
            status: logStatus,
            value: `${logDirSizeMB} MB`,
            percent: Math.min(Math.round((logDirSizeMB / 1000) * 100), 100),
            message: logMessage,
            icon: 'file-alt'
        });
        
        // 8. Active Sessions Check
        let sessionCount = 0;
        db.get('SELECT COUNT(*) as count FROM user_sessions WHERE active = 1', (err, row) => {
            if (!err && row) {
                sessionCount = row.count;
            }
        });
        
        checks.push({
            name: 'Active Sessions',
            status: sessionCount > 50 ? 'warning' : 'success',
            value: `${sessionCount} sessions`,
            message: sessionCount > 50 ? 'High number of active sessions' : 'Session count is normal',
            icon: 'users'
        });
        
        // Calculate overall health
        const errorCount = checks.filter(c => c.status === 'error').length;
        const warningCount = checks.filter(c => c.status === 'warning').length;
        const overallStatus = errorCount > 0 ? 'error' : warningCount > 0 ? 'warning' : 'success';
        
        res.json({
            overall: overallStatus,
            errorCount,
            warningCount,
            successCount: checks.filter(c => c.status === 'success').length,
            checks,
            timestamp: moment().tz(TIMEZONE).format('YYYY-MM-DD HH:mm:ss z')
        });
    } catch (error) {
        loggers.system.error('Health checks error:', error);
        res.status(500).json({ error: 'Failed to perform health checks' });
    }
});

// Rate Limiting API Endpoints
app.get('/api/rate-limits', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    try {
        db.all(`
            SELECT 
                ip_address,
                endpoint,
                request_count,
                window_start,
                blocked_until,
                CASE 
                    WHEN blocked_until > datetime('now') THEN 1
                    ELSE 0
                END as is_blocked
            FROM rate_limits
            WHERE window_start > datetime('now', '-1 hour')
            ORDER BY window_start DESC
            LIMIT 100
        `, (err, rows) => {
            if (err) {
                loggers.system.error('Error fetching rate limits:', err);
                return res.status(500).json({ error: 'Database error' });
            }
            res.json({ rateLimits: rows || [] });
        });
    } catch (error) {
        loggers.system.error('Rate limits fetch error:', error);
        res.status(500).json({ error: 'Failed to fetch rate limits' });
    }
});

app.get('/api/rate-limits/stats', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    try {
        const stats = {};
        
        // Get currently blocked IPs
        db.get(`
            SELECT COUNT(DISTINCT ip_address) as count
            FROM rate_limits
            WHERE blocked_until > datetime('now')
        `, (err, row) => {
            if (err) {
                loggers.system.error('Error fetching blocked IPs count:', err);
                stats.blockedIPs = 0;
            } else {
                stats.blockedIPs = row ? row.count : 0;
            }
            
            // Get total requests in last hour
            db.get(`
                SELECT SUM(request_count) as total
                FROM rate_limits
                WHERE window_start > datetime('now', '-1 hour')
            `, (err2, row2) => {
                if (err2) {
                    loggers.system.error('Error fetching request count:', err2);
                    stats.totalRequests = 0;
                } else {
                    stats.totalRequests = row2 && row2.total ? row2.total : 0;
                }
                
                // Get unique IPs
                db.get(`
                    SELECT COUNT(DISTINCT ip_address) as count
                    FROM rate_limits
                    WHERE window_start > datetime('now', '-1 hour')
                `, (err3, row3) => {
                    if (err3) {
                        loggers.system.error('Error fetching unique IPs:', err3);
                        stats.uniqueIPs = 0;
                    } else {
                        stats.uniqueIPs = row3 ? row3.count : 0;
                    }
                    
                    res.json(stats);
                });
            });
        });
    } catch (error) {
        loggers.system.error('Rate limit stats error:', error);
        res.status(500).json({ error: 'Failed to fetch rate limit stats' });
    }
});

app.delete('/api/rate-limits/:ip', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    const { ip } = req.params;

    db.run('DELETE FROM rate_limits WHERE ip_address = ?', [ip], function(err) {
        if (err) {
            loggers.system.error('Error unblocking IP:', err);
            return res.status(500).json({ error: 'Failed to unblock IP' });
        }
        
        logActivity(req.user.id, 'unblock_ip', 'rate_limits', `Unblocked IP: ${ip}`, req);
        res.json({ success: true, message: `IP ${ip} has been unblocked` });
    });
});

// API Key Management Page
app.get('/admin/api-keys', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).send(getPageTemplate({
            pageTitle: 'Access Denied',
            pageIcon: 'fas fa-ban',
            activeNav: '',
            contentBody: '<div class="card"><div class="card-body"><h2 style="color: var(--error-color);"><i class="fas fa-exclamation-triangle"></i> Access Denied</h2><p>Admin privileges required to access this page.</p><a href="/dashboard" class="btn"><i class="fas fa-arrow-left"></i> Return to Dashboard</a></div></div>',
            additionalCSS: '',
            additionalJS: '',
            req: req
        }));
    }

    const contentBody = `
        <div class="card">
            <div class="card-header">
                <h3><i class="fas fa-key"></i> API Key Management</h3>
                <button onclick="showCreateKeyModal()" class="btn btn-primary">
                    <i class="fas fa-plus"></i> Generate New Key
                </button>
            </div>
            <div class="card-body">
                <div id="api-keys-container">
                    <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                        <i class="fas fa-spinner fa-spin" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                        <p>Loading API keys...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Create Key Modal -->
        <div id="create-key-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
            <div style="background: var(--bg-primary); border-radius: 12px; padding: 2rem; max-width: 500px; width: 90%; max-height: 90vh; overflow-y: auto;">
                <h3 style="margin: 0 0 1.5rem 0;"><i class="fas fa-key"></i> Generate New API Key</h3>
                
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Name *</label>
                    <input type="text" id="key-name" placeholder="e.g., Production API Key" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary);">
                </div>

                <div style="margin-bottom: 1rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Description</label>
                    <textarea id="key-description" placeholder="Brief description of what this key is used for" rows="3" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary);"></textarea>
                </div>

                <div style="margin-bottom: 1rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Expires In</label>
                    <select id="key-expiry" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary);">
                        <option value="0">Never</option>
                        <option value="7">7 days</option>
                        <option value="30">30 days</option>
                        <option value="90" selected>90 days</option>
                        <option value="180">180 days</option>
                        <option value="365">1 year</option>
                    </select>
                </div>

                <div style="display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 2rem;">
                    <button onclick="hideCreateKeyModal()" class="btn">Cancel</button>
                    <button onclick="createApiKey()" class="btn btn-primary">
                        <i class="fas fa-check"></i> Generate Key
                    </button>
                </div>
            </div>
        </div>

        <!-- Key Display Modal -->
        <div id="key-display-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
            <div style="background: var(--bg-primary); border-radius: 12px; padding: 2rem; max-width: 600px; width: 90%;">
                <h3 style="margin: 0 0 1rem 0; color: var(--success-color);"><i class="fas fa-check-circle"></i> API Key Generated</h3>
                
                <div style="background: var(--warning-color); background: rgba(255, 193, 7, 0.1); border: 1px solid var(--warning-color); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
                    <p style="margin: 0; color: var(--warning-color); font-weight: 600;"><i class="fas fa-exclamation-triangle"></i> Important: Save this key now!</p>
                    <p style="margin: 0.5rem 0 0 0; font-size: 0.875rem;">You won't be able to see it again. Store it securely.</p>
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Your API Key:</label>
                    <div style="position: relative;">
                        <input type="text" id="generated-key" readonly style="width: 100%; padding: 0.75rem; padding-right: 100px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); font-family: monospace; font-size: 0.875rem;">
                        <button onclick="copyApiKey()" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); padding: 0.5rem 1rem; background: var(--accent-primary); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                </div>

                <div style="text-align: right;">
                    <button onclick="hideKeyDisplayModal()" class="btn btn-primary">
                        <i class="fas fa-check"></i> I've Saved It
                    </button>
                </div>
            </div>
        </div>
    `;

    const additionalJS = `
        function showCreateKeyModal() {
            document.getElementById('create-key-modal').style.display = 'flex';
            document.getElementById('key-name').value = '';
            document.getElementById('key-description').value = '';
            document.getElementById('key-expiry').value = '90';
        }

        function hideCreateKeyModal() {
            document.getElementById('create-key-modal').style.display = 'none';
        }

        function hideKeyDisplayModal() {
            document.getElementById('key-display-modal').style.display = 'none';
            loadApiKeys();
        }

        async function createApiKey() {
            const name = document.getElementById('key-name').value.trim();
            const description = document.getElementById('key-description').value.trim();
            const expiresInDays = parseInt(document.getElementById('key-expiry').value);

            if (!name) {
                alert('Please enter a name for the API key');
                return;
            }

            try {
                const response = await fetch('/api/api-keys', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name,
                        description,
                        expires_in_days: expiresInDays > 0 ? expiresInDays : null
                    })
                });

                if (!response.ok) throw new Error('Failed to create API key');

                const data = await response.json();
                
                // Show the generated key
                document.getElementById('generated-key').value = data.key.key_value;
                hideCreateKeyModal();
                document.getElementById('key-display-modal').style.display = 'flex';
            } catch (error) {
                console.error('Error creating API key:', error);
                alert('Failed to create API key: ' + error.message);
            }
        }

        function copyApiKey() {
            const input = document.getElementById('generated-key');
            input.select();
            document.execCommand('copy');
            
            // Visual feedback
            const btn = event.target.closest('button');
            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-check"></i> Copied!';
            btn.style.background = 'var(--success-color)';
            setTimeout(() => {
                btn.innerHTML = originalHTML;
                btn.style.background = 'var(--accent-primary)';
            }, 2000);
        }

        async function loadApiKeys() {
            try {
                const response = await fetch('/api/api-keys');
                if (!response.ok) throw new Error('Failed to load API keys');

                const data = await response.json();
                const keys = data.keys || [];

                const container = document.getElementById('api-keys-container');

                if (keys.length === 0) {
                    container.innerHTML = \`
                        <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
                            <i class="fas fa-key" style="font-size: 3rem; opacity: 0.3; margin-bottom: 1rem;"></i>
                            <p>No API keys found. Generate one to get started!</p>
                        </div>
                    \`;
                    return;
                }

                let html = '<div style="display: flex; flex-direction: column; gap: 1rem;">';

                keys.forEach(key => {
                    const isExpired = key.expires_at && new Date(key.expires_at) < new Date();
                    const expiryText = key.expires_at 
                        ? (isExpired ? 'Expired' : 'Expires ' + formatTimestamp(key.expires_at))
                        : 'Never expires';
                    
                    const statusColor = !key.is_active ? 'var(--text-muted)' : isExpired ? 'var(--error-color)' : 'var(--success-color)';
                    const statusText = !key.is_active ? 'Inactive' : isExpired ? 'Expired' : 'Active';

                    // Mask the key value (show first 8 and last 4 characters)
                    const maskedKey = key.key_value.substring(0, 8) + '...' + key.key_value.substring(key.key_value.length - 4);

                    html += \`
                        <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.5rem;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                                <div style="flex: 1;">
                                    <h4 style="margin: 0 0 0.5rem 0; color: var(--text-primary);">
                                        <i class="fas fa-key" style="color: var(--accent-primary);"></i> \${key.name}
                                    </h4>
                                    <p style="margin: 0 0 0.5rem 0; color: var(--text-muted); font-size: 0.875rem;">\${key.description || 'No description'}</p>
                                    <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 0.75rem;">
                                        <span style="font-size: 0.75rem; padding: 0.25rem 0.5rem; background: \${statusColor}20; color: \${statusColor}; border-radius: 4px; font-weight: 600;">
                                            <i class="fas fa-circle" style="font-size: 0.5rem;"></i> \${statusText}
                                        </span>
                                        <span style="font-size: 0.75rem; color: var(--text-muted);">
                                            <i class="fas fa-clock"></i> \${expiryText}
                                        </span>
                                        <span style="font-size: 0.75rem; color: var(--text-muted);">
                                            <i class="fas fa-chart-line"></i> \${key.usage_count || 0} uses
                                        </span>
                                    </div>
                                </div>
                                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                    <button onclick="regenerateKey(\${key.id}, '\${key.name}')" class="btn" style="padding: 0.5rem 1rem;" title="Regenerate Key">
                                        <i class="fas fa-sync-alt"></i>
                                    </button>
                                    <button onclick="toggleKeyStatus(\${key.id}, \${!key.is_active})" class="btn" style="padding: 0.5rem 1rem;" title="\${key.is_active ? 'Deactivate' : 'Activate'}">
                                        <i class="fas fa-\${key.is_active ? 'pause' : 'play'}"></i>
                                    </button>
                                    <button onclick="deleteKey(\${key.id}, '\${key.name}')" class="btn" style="padding: 0.5rem 1rem; background: var(--error-color); color: white;" title="Revoke Key">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                            <div style="background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 0.75rem; font-family: monospace; font-size: 0.875rem; color: var(--text-muted);">
                                \${maskedKey}
                            </div>
                            <div style="margin-top: 0.75rem; font-size: 0.75rem; color: var(--text-muted);">
                                <i class="fas fa-user"></i> Created by \${key.created_by_username} on \${formatTimestamp(key.created_at)}
                                \${key.last_used ? '<br><i class="fas fa-history"></i> Last used: ' + formatTimestamp(key.last_used) : ''}
                            </div>
                        </div>
                    \`;
                });

                html += '</div>';
                container.innerHTML = html;
            } catch (error) {
                console.error('Error loading API keys:', error);
                document.getElementById('api-keys-container').innerHTML = \`
                    <div style="text-align: center; padding: 3rem; color: var(--error-color);">
                        <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 1rem;"></i>
                        <p>Failed to load API keys</p>
                    </div>
                \`;
            }
        }

        async function toggleKeyStatus(id, newStatus) {
            try {
                const response = await fetch(\`/api/api-keys/\${id}\`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ is_active: newStatus })
                });

                if (!response.ok) throw new Error('Failed to update key status');

                loadApiKeys();
            } catch (error) {
                console.error('Error updating key status:', error);
                alert('Failed to update key status');
            }
        }

        async function regenerateKey(id, name) {
            if (!confirm(\`Regenerate API key "\${name}"? The old key will stop working immediately.\`)) {
                return;
            }

            try {
                const response = await fetch(\`/api/api-keys/\${id}/regenerate\`, {
                    method: 'POST'
                });

                if (!response.ok) throw new Error('Failed to regenerate key');

                const data = await response.json();
                
                // Show the new key
                document.getElementById('generated-key').value = data.key_value;
                document.getElementById('key-display-modal').style.display = 'flex';
            } catch (error) {
                console.error('Error regenerating key:', error);
                alert('Failed to regenerate key');
            }
        }

        async function deleteKey(id, name) {
            if (!confirm(\`Permanently revoke API key "\${name}"? This cannot be undone.\`)) {
                return;
            }

            try {
                const response = await fetch(\`/api/api-keys/\${id}\`, {
                    method: 'DELETE'
                });

                if (!response.ok) throw new Error('Failed to revoke key');

                loadApiKeys();
            } catch (error) {
                console.error('Error revoking key:', error);
                alert('Failed to revoke key');
            }
        }

        // Load keys on page load
        loadApiKeys();
    `;

    res.send(getPageTemplate({
        pageTitle: 'API Key Management',
        pageIcon: 'fas fa-key',
        activeNav: 'api-keys',
        contentBody: contentBody,
        additionalCSS: `
            .btn-primary {
                background: var(--accent-primary);
                color: white;
                font-weight: 600;
            }
            .btn-primary:hover {
                background: var(--accent-secondary);
            }
        `,
        additionalJS: additionalJS,
        req: req
    }));
});

// Audit Trail API Endpoints
app.get('/api/audit-trail', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    const { user_id, action, start_date, end_date, limit = 100, offset = 0 } = req.query;
    
    let query = `
        SELECT 
            a.id,
            a.user_id,
            a.action,
            a.resource,
            a.details,
            a.ip_address,
            a.user_agent,
            a.timestamp,
            u.username,
            u.email
        FROM user_activity a
        LEFT JOIN users u ON a.user_id = u.id
        WHERE 1=1
    `;
    const params = [];

    if (user_id) {
        query += ' AND a.user_id = ?';
        params.push(user_id);
    }
    
    if (action) {
        query += ' AND a.action = ?';
        params.push(action);
    }
    
    if (start_date) {
        query += ' AND a.timestamp >= ?';
        params.push(start_date);
    }
    
    if (end_date) {
        query += ' AND a.timestamp <= ?';
        params.push(end_date);
    }

    query += ' ORDER BY a.timestamp DESC LIMIT ? OFFSET ?';
    params.push(parseInt(limit), parseInt(offset));

    db.all(query, params, (err, rows) => {
        if (err) {
            loggers.system.error('Error fetching audit trail:', err);
            return res.status(500).json({ error: 'Database error' });
        }
        
        // Get total count for pagination
        let countQuery = 'SELECT COUNT(*) as total FROM user_activity WHERE 1=1';
        const countParams = [];
        
        if (user_id) {
            countQuery += ' AND user_id = ?';
            countParams.push(user_id);
        }
        if (action) {
            countQuery += ' AND action = ?';
            countParams.push(action);
        }
        if (start_date) {
            countQuery += ' AND timestamp >= ?';
            countParams.push(start_date);
        }
        if (end_date) {
            countQuery += ' AND timestamp <= ?';
            countParams.push(end_date);
        }
        
        db.get(countQuery, countParams, (err2, countRow) => {
            if (err2) {
                loggers.system.error('Error counting audit trail:', err2);
                return res.json({ activities: rows || [], total: 0 });
            }
            res.json({ 
                activities: rows || [], 
                total: countRow ? countRow.total : 0 
            });
        });
    });
});

app.get('/api/audit-trail/export', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    db.all(`
        SELECT 
            a.timestamp,
            u.username,
            u.email,
            a.action,
            a.resource,
            a.details,
            a.ip_address
        FROM user_activity a
        LEFT JOIN users u ON a.user_id = u.id
        ORDER BY a.timestamp DESC
        LIMIT 10000
    `, (err, rows) => {
        if (err) {
            loggers.system.error('Error exporting audit trail:', err);
            return res.status(500).json({ error: 'Export failed' });
        }

        // Convert to CSV
        const headers = ['Timestamp', 'Username', 'Email', 'Action', 'Resource', 'Details', 'IP Address'];
        const csvRows = [headers.join(',')];
        
        rows.forEach(row => {
            const values = [
                row.timestamp || '',
                row.username || '',
                row.email || '',
                row.action || '',
                row.resource || '',
                (row.details || '').replace(/,/g, ';').replace(/\n/g, ' '),
                row.ip_address || ''
            ];
            csvRows.push(values.map(v => `"${v}"`).join(','));
        });

        const csv = csvRows.join('\n');
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename=audit-trail-${moment().format('YYYY-MM-DD')}.csv`);
        res.send(csv);
        
        logActivity(req.user.id, 'export_audit_trail', 'user_activity', 'Exported audit trail to CSV', req);
    });
});

// Settings Export/Import API Endpoints
app.get('/api/settings/export', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    try {
        // Export all system settings
        db.all('SELECT * FROM system_settings', (err, settings) => {
            if (err) {
                loggers.system.error('Error exporting settings:', err);
                return res.status(500).json({ error: 'Export failed' });
            }

            const exportData = {
                version: config.system.version,
                exportedAt: moment().tz(TIMEZONE).format(),
                settings: settings || [],
                config: {
                    system: {
                        name: config.system.name,
                        timezone: config.system.timezone
                    },
                    integrations: {
                        unifi: {
                            enabled: config.integrations.unifi.enabled,
                            host: config.integrations.unifi.host,
                            pollInterval: config.integrations.unifi.pollInterval
                        },
                        homeAssistant: {
                            enabled: config.integrations.homeAssistant.enabled,
                            host: config.integrations.homeAssistant.host,
                            websocketEnabled: config.integrations.homeAssistant.websocketEnabled
                        },
                        mqtt: {
                            enabled: config.integrations.mqtt.enabled,
                            broker: config.integrations.mqtt.broker,
                            topic: config.integrations.mqtt.topic,
                            topics: config.integrations.mqtt.topics
                        },
                        websocket: {
                            enabled: config.integrations.websocket.enabled,
                            port: config.integrations.websocket.port
                        }
                    },
                    maintenance: config.maintenance
                }
            };

            res.setHeader('Content-Type', 'application/json');
            res.setHeader('Content-Disposition', `attachment; filename=system-settings-${moment().format('YYYY-MM-DD')}.json`);
            res.json(exportData);
            
            logActivity(req.user.id, 'export_settings', 'system_settings', 'Exported system settings', req);
        });
    } catch (error) {
        loggers.system.error('Settings export error:', error);
        res.status(500).json({ error: 'Failed to export settings' });
    }
});

app.post('/api/settings/import', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    try {
        const importData = req.body;
        
        // Validate import data
        if (!importData || !importData.version || !importData.settings) {
            return res.status(400).json({ error: 'Invalid import data format' });
        }

        // Validate version compatibility (optional - could add version checks)
        loggers.system.info('Importing settings from version:', importData.version);

        // Import system settings
        const stmt = db.prepare('INSERT OR REPLACE INTO system_settings (key, value, category, description) VALUES (?, ?, ?, ?)');
        
        let imported = 0;
        importData.settings.forEach(setting => {
            stmt.run([setting.key, setting.value, setting.category, setting.description], (err) => {
                if (err) {
                    loggers.system.error('Error importing setting:', setting.key, err);
                } else {
                    imported++;
                }
            });
        });
        
        stmt.finalize(() => {
            logActivity(req.user.id, 'import_settings', 'system_settings', `Imported ${imported} settings`, req);
            res.json({ 
                success: true, 
                message: `Successfully imported ${imported} settings. Server may need restart for changes to take effect.`,
                imported 
            });
        });
    } catch (error) {
        loggers.system.error('Settings import error:', error);
        res.status(500).json({ error: 'Failed to import settings' });
    }
});

// ============================================================
// API KEY MANAGEMENT ENDPOINTS
// ============================================================

// Get all API keys
app.get('/api/api-keys', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    // First check if table exists
    db.get("SELECT name FROM sqlite_master WHERE type='table' AND name='api_keys'", (checkErr, table) => {
        if (checkErr || !table) {
            loggers.system.error('API keys table does not exist:', checkErr);
            return res.json({ keys: [] }); // Return empty array if table doesn't exist
        }

        db.all(`
            SELECT 
                api_keys.id,
                api_keys.name,
                api_keys.prefix,
                api_keys.created_by,
                api_keys.created_at,
                api_keys.last_used,
                api_keys.expires_at,
                api_keys.active,
                api_keys.permissions,
                api_keys.rate_limit,
                users.username as created_by_username
            FROM api_keys
            LEFT JOIN users ON api_keys.created_by = users.id
            ORDER BY api_keys.created_at DESC
        `, (err, rows) => {
            if (err) {
                loggers.system.error('Error fetching API keys:', err);
                return res.status(500).json({ error: 'Database error' });
            }
            res.json({ keys: rows || [] });
        });
    });
});

// Generate new API key
app.post('/api/api-keys', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    const { name, description, permissions, ip_whitelist, expires_in_days } = req.body;

    if (!name) {
        return res.status(400).json({ error: 'API key name is required' });
    }

    // Generate a secure random API key
    const keyValue = 'elk_' + crypto.randomBytes(32).toString('hex');
    
    // Calculate expiration date if specified
    let expiresAt = null;
    if (expires_in_days && expires_in_days > 0) {
        expiresAt = moment().add(expires_in_days, 'days').format('YYYY-MM-DD HH:mm:ss');
    }

    const permissionsJson = permissions ? JSON.stringify(permissions) : null;
    const ipWhitelistJson = ip_whitelist ? JSON.stringify(ip_whitelist) : null;

    db.run(`
        INSERT INTO api_keys (name, key_value, description, created_by, expires_at, permissions, ip_whitelist)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    `, [name, keyValue, description, req.user.id, expiresAt, permissionsJson, ipWhitelistJson], function(err) {
        if (err) {
            loggers.system.error('Error creating API key:', err);
            return res.status(500).json({ error: 'Failed to create API key' });
        }

        loggers.system.info(`API key created: ${name} by user ${req.user.username}`);
        logActivity(req.user.id, 'create_api_key', 'api_keys', `Created API key: ${name}`, req);

        res.json({
            success: true,
            message: 'API key created successfully',
            key: {
                id: this.lastID,
                name,
                key_value: keyValue,
                description,
                created_at: moment().format('YYYY-MM-DD HH:mm:ss'),
                expires_at: expiresAt,
                is_active: true
            }
        });
    });
});

// Update API key
app.put('/api/api-keys/:id', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    const { id } = req.params;
    const { name, description, is_active, permissions, ip_whitelist } = req.body;

    const permissionsJson = permissions ? JSON.stringify(permissions) : null;
    const ipWhitelistJson = ip_whitelist ? JSON.stringify(ip_whitelist) : null;

    db.run(`
        UPDATE api_keys 
        SET name = COALESCE(?, name),
            description = COALESCE(?, description),
            is_active = COALESCE(?, is_active),
            permissions = COALESCE(?, permissions),
            ip_whitelist = COALESCE(?, ip_whitelist)
        WHERE id = ?
    `, [name, description, is_active, permissionsJson, ipWhitelistJson, id], function(err) {
        if (err) {
            loggers.system.error('Error updating API key:', err);
            return res.status(500).json({ error: 'Failed to update API key' });
        }

        if (this.changes === 0) {
            return res.status(404).json({ error: 'API key not found' });
        }

        loggers.system.info(`API key updated: ID ${id} by user ${req.user.username}`);
        logActivity(req.user.id, 'update_api_key', 'api_keys', `Updated API key ID: ${id}`, req);

        res.json({ success: true, message: 'API key updated successfully' });
    });
});

// Revoke (delete) API key
app.delete('/api/api-keys/:id', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    const { id } = req.params;

    // Get key name before deletion for logging
    db.get('SELECT name FROM api_keys WHERE id = ?', [id], (err, row) => {
        if (err) {
            loggers.system.error('Error fetching API key:', err);
            return res.status(500).json({ error: 'Database error' });
        }

        if (!row) {
            return res.status(404).json({ error: 'API key not found' });
        }

        const keyName = row.name;

        db.run('DELETE FROM api_keys WHERE id = ?', [id], function(err) {
            if (err) {
                loggers.system.error('Error deleting API key:', err);
                return res.status(500).json({ error: 'Failed to delete API key' });
            }

            loggers.system.info(`API key revoked: ${keyName} (ID: ${id}) by user ${req.user.username}`);
            logActivity(req.user.id, 'revoke_api_key', 'api_keys', `Revoked API key: ${keyName}`, req);

            res.json({ success: true, message: 'API key revoked successfully' });
        });
    });
});

// Regenerate API key
app.post('/api/api-keys/:id/regenerate', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    const { id } = req.params;
    const newKeyValue = 'elk_' + crypto.randomBytes(32).toString('hex');

    db.run(`
        UPDATE api_keys 
        SET key_value = ?,
            usage_count = 0,
            last_used = NULL
        WHERE id = ?
    `, [newKeyValue, id], function(err) {
        if (err) {
            loggers.system.error('Error regenerating API key:', err);
            return res.status(500).json({ error: 'Failed to regenerate API key' });
        }

        if (this.changes === 0) {
            return res.status(404).json({ error: 'API key not found' });
        }

        loggers.system.info(`API key regenerated: ID ${id} by user ${req.user.username}`);
        logActivity(req.user.id, 'regenerate_api_key', 'api_keys', `Regenerated API key ID: ${id}`, req);

        res.json({
            success: true,
            message: 'API key regenerated successfully',
            key_value: newKeyValue
        });
    });
});

// Get API key usage statistics
app.get('/api/api-keys/:id/stats', requireAuth, (req, res) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Admin access required' });
    }

    const { id } = req.params;

    db.get(`
        SELECT 
            id,
            name,
            usage_count,
            created_at,
            last_used,
            is_active,
            expires_at
        FROM api_keys
        WHERE id = ?
    `, [id], (err, row) => {
        if (err) {
            loggers.system.error('Error fetching API key stats:', err);
            return res.status(500).json({ error: 'Database error' });
        }

        if (!row) {
            return res.status(404).json({ error: 'API key not found' });
        }

        const stats = {
            ...row,
            is_expired: row.expires_at ? moment(row.expires_at).isBefore(moment()) : false,
            days_until_expiry: row.expires_at ? moment(row.expires_at).diff(moment(), 'days') : null
        };

        res.json({ stats });
    });
});

// System action endpoints
app.post('/api/system/backup', requireAuth, async (req, res) => {
    try {
        const backupTime = new Date().toISOString().replace(/[:.]/g, '-');
        const backupName = `backup-${backupTime}.sql`;
        
        // Simulate backup process
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        loggers.system.info(`System backup created: ${backupName}`);
        res.json({ 
            success: true, 
            message: 'Backup completed successfully',
            filename: backupName
        });
    } catch (error) {
        loggers.system.error('Backup error:', error);
        res.status(500).json({ error: 'Backup failed' });
    }
});

app.post('/api/system/cleanup', requireAuth, async (req, res) => {
    try {
        // Simulate cleanup process
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        const cleanedItems = Math.floor(Math.random() * 100) + 50;
        loggers.system.info(`System cleanup completed: ${cleanedItems} items cleaned`);
        
        res.json({ 
            success: true, 
            message: `Cleanup completed: ${cleanedItems} items removed`,
            itemsCleaned: cleanedItems
        });
    } catch (error) {
        loggers.system.error('Cleanup error:', error);
        res.status(500).json({ error: 'Cleanup failed' });
    }
});

app.post('/api/system/restart', requireAuth, async (req, res) => {
    try {
        loggers.system.info('System restart requested by user');
        
        res.json({ 
            success: true, 
            message: 'Restart initiated - Server will restart in 5 seconds'
        });
        
        // Graceful restart after response
        setTimeout(() => {
            loggers.system.info('Restarting server...');
            process.exit(0);
        }, 5000);
        
    } catch (error) {
        loggers.system.error('Restart error:', error);
        res.status(500).json({ error: 'Restart failed' });
    }
});

app.post('/api/system/maintenance', requireAuth, async (req, res) => {
    try {
        // Simulate maintenance tasks
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        const tasks = [
            'Database optimization completed',
            'Cache cleared',
            'Log rotation performed',
            'System health check passed'
        ];
        
        loggers.system.info('Maintenance mode completed');
        res.json({ 
            success: true, 
            message: 'Maintenance completed successfully',
            tasks: tasks
        });
    } catch (error) {
        loggers.system.error('Maintenance error:', error);
        res.status(500).json({ error: 'Maintenance failed' });
    }
});

// ============================================================================
// EXTERNAL LOGGING ENDPOINT - accepts logs from Home Assistant, ESP32, etc.
// ============================================================================
app.post('/log', logIngestionLimiter, legacyAuth, (req, res) => {
    const {
        timestamp,
        category = 'home_automation',
        source = 'Unknown',
        device_id = 'unknown-device',
        event_type = 'log_event',
        severity = 'info',
        zone_number = null,
        zone_name = null,
        message,
        metadata = '{}'
    } = req.body;

    // Validate required fields
    if (!message) {
        return res.status(400).json({ error: 'Message is required' });
    }

    // Use provided timestamp or generate one
    const logTimestamp = timestamp || moment().tz(TIMEZONE).toISOString();
    
    // Parse metadata if it's a string
    let metadataStr = metadata;
    if (typeof metadata === 'object') {
        metadataStr = JSON.stringify(metadata);
    }

    // Insert into database
    db.run(
        `INSERT INTO log_events (timestamp, category, source, device_id, event_type, severity, zone_number, zone_name, message, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [logTimestamp, category, source, device_id, event_type, severity, zone_number, zone_name, message, metadataStr],
        function(err) {
            if (err) {
                loggers.system.error('Database insert error:', err);
                return res.status(500).json({ error: 'Database error' });
            }

            loggers.system.info(`Log received from ${source}: ${message.substring(0, 50)}...`);
            
            // Broadcast to WebSocket clients if available
            if (integrationManager && integrationManager.broadcastToWebSockets) {
                integrationManager.broadcastToWebSockets({
                    type: 'new_log_event',
                    event: {
                        id: this.lastID,
                        timestamp: logTimestamp,
                        category,
                        source,
                        device_id,
                        event_type,
                        severity,
                        zone_number,
                        zone_name,
                        message,
                        metadata: metadataStr
                    }
                }, {
                    source,
                    severity,
                    category
                });
            }

            // Process alerts for this log event
            const logEvent = {
                id: this.lastID,
                timestamp: logTimestamp,
                category,
                source,
                device_id,
                event_type,
                severity,
                zone_number,
                zone_name,
                message,
                metadata: metadataStr
            };
            
            // Trigger alerting engine (async, don't block response)
            if (alertingEngine) {
                setImmediate(() => alertingEngine.processLogEvent(logEvent));
            }

            res.json({ success: true, message: 'Log entry created', id: this.lastID });
        }
    );
});

// ============================================================================
// LOG PARSING TEMPLATES - Quick Win #3
// ============================================================================

// Common log format parsing templates
const logParsers = {
    nginx: {
        // Nginx combined log format
        pattern: /^(\S+) \S+ \S+ \[([\w\/\:\s\+\-]+)\] "(\S+) (\S+) (\S+)" (\d{3}) (\d+) "([^"]*)" "([^"]*)"/,
        fields: ['ip', 'timestamp', 'method', 'url', 'protocol', 'status', 'size', 'referer', 'user_agent']
    },
    apache: {
        // Apache common log format
        pattern: /^(\S+) \S+ \S+ \[([\w\/\:\s\+\-]+)\] "(\S+) (\S+) (\S+)" (\d{3}) (\d+)/,
        fields: ['ip', 'timestamp', 'method', 'url', 'protocol', 'status', 'size']
    },
    docker: {
        // Docker log format
        pattern: /^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+Z) (\w+) (.+)$/,
        fields: ['timestamp', 'level', 'message']
    },
    syslog: {
        // RFC3164 Syslog format
        pattern: /^<(\d+)>(\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2}) (\S+) (.+)$/,
        fields: ['priority', 'timestamp', 'hostname', 'message']
    },
    json: {
        // Auto-detect JSON logs
        pattern: null, // Will use JSON.parse
        fields: []
    }
};

// Enhanced log parsing function
function parseLogMessage(message, format = 'auto') {
    const parsed = {
        original: message,
        parsed: {},
        format_detected: 'unknown'
    };

    try {
        // Auto-detect JSON
        if (format === 'auto' || format === 'json') {
            if (message.trim().startsWith('{') || message.trim().startsWith('[')) {
                try {
                    const jsonData = JSON.parse(message);
                    parsed.parsed = jsonData;
                    parsed.format_detected = 'json';
                    return parsed;
                } catch (e) {
                    // Not valid JSON, continue to other parsers
                }
            }
        }

        // Try specific format first, then auto-detect
        const formatsToTry = format === 'auto' ? 
            Object.keys(logParsers).filter(f => f !== 'json') : 
            [format];

        for (const formatName of formatsToTry) {
            const parser = logParsers[formatName];
            if (parser && parser.pattern) {
                const match = message.match(parser.pattern);
                if (match) {
                    const result = {};
                    parser.fields.forEach((field, index) => {
                        result[field] = match[index + 1];
                    });
                    
                    // Add IP geolocation if IP field exists
                    if (result.ip) {
                        const geo = geoip.lookup(result.ip);
                        if (geo) {
                            result.geo = {
                                country: geo.country,
                                region: geo.region,
                                city: geo.city,
                                timezone: geo.timezone,
                                coordinates: [geo.ll[1], geo.ll[0]] // [lng, lat] for GeoJSON
                            };
                        }
                    }
                    
                    // Parse User-Agent if present
                    if (result.user_agent) {
                        try {
                            const ua = useragent(result.user_agent);
                            result.user_agent_parsed = {
                                browser: ua.browser,
                                version: ua.version,
                                os: ua.os,
                                platform: ua.platform,
                                source: ua.source
                            };
                        } catch (e) {
                            // User-Agent parsing failed, skip
                        }
                    }
                    
                    parsed.parsed = result;
                    parsed.format_detected = formatName;
                    return parsed;
                }
            }
        }
    } catch (error) {
        console.error('Log parsing error:', error);
    }

    return parsed;
}

// ============================================================================
// BULK LOG OPERATIONS - Quick Win #2
// ============================================================================

// Bulk log ingestion endpoint
app.post('/log/bulk', logIngestionLimiter, legacyAuth, (req, res) => {
    const { logs } = req.body;

    // Validate input
    if (!Array.isArray(logs)) {
        return res.status(400).json({ 
            error: 'Logs must be an array',
            example: {
                logs: [
                    { message: 'Log 1', severity: 'info', source: 'app1' },
                    { message: 'Log 2', severity: 'error', source: 'app2' }
                ]
            }
        });
    }

    if (logs.length === 0) {
        return res.status(400).json({ error: 'Logs array cannot be empty' });
    }

    if (logs.length > 1000) {
        return res.status(400).json({ 
            error: 'Maximum 1000 logs per bulk request',
            received: logs.length 
        });
    }

    const timestamp = moment().tz(TIMEZONE).toISOString();
    const insertedLogs = [];
    const errors = [];
    let completed = 0;

    // Prepare batch insert
    const stmt = db.prepare(`
        INSERT INTO log_events (timestamp, category, source, device_id, event_type, severity, zone_number, zone_name, message, metadata)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    // Process each log entry
    logs.forEach((logEntry, index) => {
        const {
            timestamp: logTimestamp,
            category = 'bulk_import',
            source = 'Unknown',
            device_id = 'bulk-device',
            event_type = 'log_event',
            severity = 'info',
            zone_number = null,
            zone_name = null,
            message,
            metadata = '{}',
            format = 'auto' // Allow specifying log format
        } = logEntry;

        // Validate required fields
        if (!message) {
            errors.push({ index, error: 'Message is required' });
            completed++;
            return;
        }

        // Use provided timestamp or current timestamp
        const finalTimestamp = logTimestamp || timestamp;

        // Parse log message using templates
        const parsedLog = parseLogMessage(message, format);
        
        // Enhance metadata with parsed information
        let enhancedMetadata = {};
        try {
            enhancedMetadata = typeof metadata === 'string' ? JSON.parse(metadata) : metadata;
        } catch (e) {
            enhancedMetadata = {};
        }

        // Add parsing results to metadata
        if (parsedLog.format_detected !== 'unknown') {
            enhancedMetadata.parsed = parsedLog.parsed;
            enhancedMetadata.format_detected = parsedLog.format_detected;
        }

        const metadataStr = JSON.stringify(enhancedMetadata);

        // Insert into database
        stmt.run([
            finalTimestamp, category, source, device_id, event_type, 
            severity, zone_number, zone_name, message, metadataStr
        ], function(err) {
            completed++;
            
            if (err) {
                loggers.system.error('Bulk insert error:', err);
                errors.push({ index, error: 'Database error', details: err.message });
            } else {
                insertedLogs.push({
                    id: this.lastID,
                    index,
                    timestamp: finalTimestamp,
                    message: message.substring(0, 100) + (message.length > 100 ? '...' : ''),
                    parsed: parsedLog.format_detected !== 'unknown'
                });

                // Broadcast to WebSocket clients (batched to avoid spam)
                if (integrationManager && integrationManager.broadcastToWebSockets) {
                    integrationManager.broadcastToWebSockets({
                        type: 'bulk_log_event',
                        count: insertedLogs.length,
                        latest: {
                            id: this.lastID,
                            timestamp: finalTimestamp,
                            category,
                            source,
                            device_id,
                            message: message.substring(0, 200)
                        }
                    });
                }
            }

            // Send response when all logs are processed
            if (completed === logs.length) {
                stmt.finalize();
                
                const result = {
                    success: true,
                    message: `Bulk log import completed`,
                    summary: {
                        total_submitted: logs.length,
                        successful_imports: insertedLogs.length,
                        errors: errors.length
                    },
                    imported_logs: insertedLogs,
                    errors: errors
                };

                loggers.system.info(`Bulk import completed: ${insertedLogs.length}/${logs.length} successful`);
                res.json(result);
            }
        });
    });
});

// API endpoint to get logs using DAL
app.get('/api/logs', requireAuth, async (req, res) => {
    try {
        const { limit = 100, offset = 0, category, level, source } = req.query;
        
        // Build filter object for DAL
        const filters = {};
        if (category) filters.category = category;
        if (level) filters.level = level;
        if (source) filters.source = source;
        
        const logs = await dal.getLogs({
            filters,
            limit: parseInt(limit),
            offset: parseInt(offset)
        });
        
        res.json(logs);
    } catch (error) {
        loggers.system.error('Query error:', error);
        res.status(500).json({ error: 'Database query failed' });
    }
});

// Advanced search endpoint with multi-field filtering
app.post('/api/logs/search', requireAuth, (req, res) => {
    const {
        searchText = '',
        startDate = null,
        endDate = null,
        levels = [],
        sources = [],
        categories = [],
        useRegex = false,
        caseSensitive = false,
        limit = 100,
        offset = 0
    } = req.body;
    
    let sql = 'SELECT * FROM log_events WHERE 1=1';
    let params = [];
    
    // Date range filter
    if (startDate) {
        sql += ' AND timestamp >= ?';
        params.push(startDate);
    }
    
    if (endDate) {
        sql += ' AND timestamp <= ?';
        params.push(endDate);
    }
    
    // Log levels filter (multiple)
    if (levels && levels.length > 0) {
        const placeholders = levels.map(() => '?').join(',');
        sql += ` AND severity IN (${placeholders})`;
        params.push(...levels);
    }
    
    // Sources filter (multiple)
    if (sources && sources.length > 0) {
        const placeholders = sources.map(() => '?').join(',');
        sql += ` AND source IN (${placeholders})`;
        params.push(...sources);
    }
    
    // Categories filter (multiple)
    if (categories && categories.length > 0) {
        const placeholders = categories.map(() => '?').join(',');
        sql += ` AND category IN (${placeholders})`;
        params.push(...categories);
    }
    
    // Text search in message
    if (searchText) {
        if (useRegex) {
            // SQLite doesn't support REGEXP by default, so we'll filter in memory
            sql += ' AND message IS NOT NULL';
        } else {
            if (caseSensitive) {
                sql += ' AND message LIKE ? COLLATE BINARY';
            } else {
                sql += ' AND message LIKE ?';
            }
            params.push(`%${searchText}%`);
        }
    }
    
    sql += ' ORDER BY timestamp DESC LIMIT ? OFFSET ?';
    params.push(parseInt(limit), parseInt(offset));
    
    db.all(sql, params, (err, rows) => {
        if (err) {
            loggers.system.error('Search query error:', err);
            return res.status(500).json({ error: 'Search failed' });
        }
        
        // Apply regex filter in memory if needed
        let results = rows;
        if (searchText && useRegex) {
            try {
                const flags = caseSensitive ? 'g' : 'gi';
                const regex = new RegExp(searchText, flags);
                results = rows.filter(row => row.message && regex.test(row.message));
            } catch (regexErr) {
                return res.status(400).json({ error: 'Invalid regex pattern' });
            }
        }
        
        res.json({
            results: results,
            count: results.length,
            hasMore: results.length === parseInt(limit)
        });
    });
});

// Get unique values for search filters
app.get('/api/logs/filter-options', requireAuth, (req, res) => {
    const queries = {
        levels: 'SELECT DISTINCT severity FROM log_events WHERE severity IS NOT NULL ORDER BY severity',
        sources: 'SELECT DISTINCT source FROM log_events WHERE source IS NOT NULL ORDER BY source LIMIT 100',
        categories: 'SELECT DISTINCT category FROM log_events WHERE category IS NOT NULL ORDER BY category LIMIT 100'
    };
    
    const results = {};
    let completed = 0;
    
    Object.keys(queries).forEach(key => {
        db.all(queries[key], [], (err, rows) => {
            if (err) {
                loggers.system.error(`Error fetching ${key}:`, err);
                results[key] = [];
            } else {
                results[key] = rows.map(row => row[Object.keys(row)[0]]);
            }
            
            completed++;
            if (completed === Object.keys(queries).length) {
                res.json(results);
            }
        });
    });
});

// Saved searches endpoints
app.get('/api/saved-searches', requireAuth, (req, res) => {
    const userId = req.user.id;
    
    db.all(
        `SELECT * FROM saved_searches 
         WHERE user_id = ? OR is_public = 1 
         ORDER BY last_used DESC, created_at DESC`,
        [userId],
        (err, rows) => {
            if (err) {
                loggers.system.error('Error fetching saved searches:', err);
                return res.status(500).json({ error: 'Failed to fetch saved searches' });
            }
            
            // Parse filters JSON
            const searches = rows.map(row => ({
                ...row,
                filters: JSON.parse(row.filters)
            }));
            
            res.json(searches);
        }
    );
});

app.post('/api/saved-searches', requireAuth, (req, res) => {
    const { name, description, filters, is_public } = req.body;
    const userId = req.user.id;
    
    if (!name || !filters) {
        return res.status(400).json({ error: 'Name and filters are required' });
    }
    
    db.run(
        `INSERT INTO saved_searches (user_id, name, description, filters, is_public) 
         VALUES (?, ?, ?, ?, ?)`,
        [userId, name, description, JSON.stringify(filters), is_public ? 1 : 0],
        function(err) {
            if (err) {
                loggers.system.error('Error saving search:', err);
                return res.status(500).json({ error: 'Failed to save search' });
            }
            
            res.json({ id: this.lastID, message: 'Search saved successfully' });
        }
    );
});

app.put('/api/saved-searches/:id', requireAuth, (req, res) => {
    const searchId = req.params.id;
    const userId = req.user.id;
    const { name, description, filters, is_public } = req.body;
    
    db.run(
        `UPDATE saved_searches 
         SET name = ?, description = ?, filters = ?, is_public = ?, updated_at = CURRENT_TIMESTAMP 
         WHERE id = ? AND user_id = ?`,
        [name, description, JSON.stringify(filters), is_public ? 1 : 0, searchId, userId],
        function(err) {
            if (err) {
                loggers.system.error('Error updating search:', err);
                return res.status(500).json({ error: 'Failed to update search' });
            }
            
            if (this.changes === 0) {
                return res.status(404).json({ error: 'Search not found or access denied' });
            }
            
            res.json({ message: 'Search updated successfully' });
        }
    );
});

app.delete('/api/saved-searches/:id', requireAuth, (req, res) => {
    const searchId = req.params.id;
    const userId = req.user.id;
    
    db.run(
        'DELETE FROM saved_searches WHERE id = ? AND user_id = ?',
        [searchId, userId],
        function(err) {
            if (err) {
                loggers.system.error('Error deleting search:', err);
                return res.status(500).json({ error: 'Failed to delete search' });
            }
            
            if (this.changes === 0) {
                return res.status(404).json({ error: 'Search not found or access denied' });
            }
            
            res.json({ message: 'Search deleted successfully' });
        }
    );
});

app.post('/api/saved-searches/:id/use', requireAuth, (req, res) => {
    const searchId = req.params.id;
    
    db.run(
        `UPDATE saved_searches 
         SET last_used = CURRENT_TIMESTAMP, use_count = use_count + 1 
         WHERE id = ?`,
        [searchId],
        (err) => {
            if (err) {
                loggers.system.error('Error updating search usage:', err);
            }
            res.json({ message: 'Usage tracked' });
        }
    );
});

// ============================================================================
// NEW API ENDPOINTS FOR ENHANCED FEATURES
// ============================================================================

// Alert management API
app.get('/api/alerts/rules', requireAuth, (req, res) => {
    if (alertingEngine) {
        res.json({
            success: true,
            rules: alertingEngine.rules,
            count: alertingEngine.rules.length
        });
    } else {
        res.status(503).json({ error: 'Alerting engine not available' });
    }
});

app.get('/api/alerts/history', requireAuth, (req, res) => {
    const { limit = 50 } = req.query;
    
    if (alertingEngine) {
        const history = alertingEngine.getAlertHistory(parseInt(limit));
        res.json({
            success: true,
            alerts: history,
            count: history.length
        });
    } else {
        res.status(503).json({ error: 'Alerting engine not available' });
    }
});

app.put('/api/alerts/rules/:id', requireAuth, (req, res) => {
    const { id } = req.params;
    const { enabled } = req.body;
    
    if (!alertingEngine) {
        return res.status(503).json({ error: 'Alerting engine not available' });
    }
    
    const rule = alertingEngine.rules.find(r => r.id === id);
    if (!rule) {
        return res.status(404).json({ error: 'Alert rule not found' });
    }
    
    if (enabled !== undefined) {
        rule.enabled = Boolean(enabled);
        loggers.system.info(`Alert rule ${id} ${rule.enabled ? 'enabled' : 'disabled'} by ${req.user.username}`);
    }
    
    res.json({
        success: true,
        message: `Alert rule ${rule.enabled ? 'enabled' : 'disabled'}`,
        rule: rule
    });
});

// ============================================================================
// ENHANCED ALERTING ENGINE API ENDPOINTS
// ============================================================================

// Get enhanced alert statistics
app.get('/api/alerts/stats', requireAuth, async (req, res) => {
    try {
        if (!alertingEngine) {
            return res.status(503).json({ error: 'Alerting engine not available' });
        }

        const stats = await alertingEngine.getAlertStats();
        res.json({ success: true, stats });
    } catch (error) {
        loggers.system.error('Error getting alert stats:', error);
        res.status(500).json({ error: 'Failed to get alert statistics' });
    }
});

// Get enhanced alert history with filtering
app.get('/api/alerts/history/enhanced', requireAuth, async (req, res) => {
    try {
        if (!alertingEngine) {
            return res.status(503).json({ error: 'Alerting engine not available' });
        }

        const { limit = 50, severity, status, ruleId } = req.query;
        const filters = {};
        
        if (severity) filters.severity = severity;
        if (status) filters.status = status;
        if (ruleId) filters.ruleId = ruleId;

        const alerts = await alertingEngine.getAlertHistory(parseInt(limit), filters);
        res.json({ success: true, alerts });
    } catch (error) {
        loggers.system.error('Error getting enhanced alert history:', error);
        res.status(500).json({ error: 'Failed to get alert history' });
    }
});

// Create new alert rule
app.post('/api/alerts/rules', requireAuth, async (req, res) => {
    try {
        if (!alertingEngine) {
            return res.status(503).json({ error: 'Alerting engine not available' });
        }

        const ruleData = req.body;
        const rule = await alertingEngine.addRule(ruleData, req.user.id);
        
        logActivity(req.user.id, 'create_alert_rule', `Created alert rule: ${rule.name}`, req.ip);
        
        res.json({ success: true, rule });
    } catch (error) {
        loggers.system.error('Error creating alert rule:', error);
        res.status(500).json({ error: 'Failed to create alert rule' });
    }
});

// Update alert rule
app.put('/api/alerts/rules/:id/enhanced', requireAuth, async (req, res) => {
    try {
        if (!alertingEngine) {
            return res.status(503).json({ error: 'Alerting engine not available' });
        }

        const { id } = req.params;
        const updates = req.body;
        
        const rule = await alertingEngine.updateRule(id, updates);
        if (!rule) {
            return res.status(404).json({ error: 'Alert rule not found' });
        }
        
        logActivity(req.user.id, 'update_alert_rule', `Updated alert rule: ${rule.name}`, req.ip);
        
        res.json({ success: true, rule });
    } catch (error) {
        loggers.system.error('Error updating alert rule:', error);
        res.status(500).json({ error: 'Failed to update alert rule' });
    }
});

// Delete alert rule
app.delete('/api/alerts/rules/:id/enhanced', requireAuth, async (req, res) => {
    try {
        if (!alertingEngine) {
            return res.status(503).json({ error: 'Alerting engine not available' });
        }

        const { id } = req.params;
        const rule = await alertingEngine.removeRule(id);
        
        if (!rule) {
            return res.status(404).json({ error: 'Alert rule not found' });
        }
        
        logActivity(req.user.id, 'delete_alert_rule', `Deleted alert rule: ${rule.name}`, req.ip);
        
        res.json({ success: true, message: 'Alert rule deleted' });
    } catch (error) {
        loggers.system.error('Error deleting alert rule:', error);
        res.status(500).json({ error: 'Failed to delete alert rule' });
    }
});

// Resolve alert
app.post('/api/alerts/:id/resolve/enhanced', requireAuth, async (req, res) => {
    try {
        if (!alertingEngine) {
            return res.status(503).json({ error: 'Alerting engine not available' });
        }

        const { id } = req.params;
        await alertingEngine.resolveAlert(id, req.user.username);
        
        logActivity(req.user.id, 'resolve_alert', `Resolved alert: ${id}`, req.ip);
        
        res.json({ success: true, message: 'Alert resolved' });
    } catch (error) {
        loggers.system.error('Error resolving alert:', error);
        res.status(500).json({ error: 'Failed to resolve alert' });
    }
});

// Get notification channels
app.get('/api/alerts/channels', requireAuth, async (req, res) => {
    try {
        if (!alertingEngine) {
            return res.status(503).json({ error: 'Alerting engine not available' });
        }

        const channels = await alertingEngine.getNotificationChannels();
        res.json({ success: true, channels });
    } catch (error) {
        loggers.system.error('Error getting notification channels:', error);
        res.status(500).json({ error: 'Failed to get notification channels' });
    }
});

// Create notification channel
app.post('/api/alerts/channels', requireAuth, async (req, res) => {
    try {
        if (!alertingEngine) {
            return res.status(503).json({ error: 'Alerting engine not available' });
        }

        const channelData = req.body;
        const channel = await alertingEngine.createNotificationChannel(channelData);
        
        logActivity(req.user.id, 'create_notification_channel', `Created notification channel: ${channel.name}`, req.ip);
        
        res.json({ success: true, channel });
    } catch (error) {
        loggers.system.error('Error creating notification channel:', error);
        res.status(500).json({ error: 'Failed to create notification channel' });
    }
});

// Update notification channel
app.put('/api/alerts/channels/:id', requireAuth, async (req, res) => {
    try {
        if (!alertingEngine) {
            return res.status(503).json({ error: 'Alerting engine not available' });
        }

        const { id } = req.params;
        const updates = req.body;
        
        const channel = await alertingEngine.updateNotificationChannel(id, updates);
        if (!channel) {
            return res.status(404).json({ error: 'Notification channel not found' });
        }
        
        logActivity(req.user.id, 'update_notification_channel', `Updated notification channel: ${channel.name}`, req.ip);
        
        res.json({ success: true, channel });
    } catch (error) {
        loggers.system.error('Error updating notification channel:', error);
        res.status(500).json({ error: 'Failed to update notification channel' });
    }
});

// Delete notification channel
app.delete('/api/alerts/channels/:id', requireAuth, async (req, res) => {
    try {
        if (!alertingEngine) {
            return res.status(503).json({ error: 'Alerting engine not available' });
        }

        const { id } = req.params;
        const channel = await alertingEngine.removeNotificationChannel(id);
        
        if (!channel) {
            return res.status(404).json({ error: 'Notification channel not found' });
        }
        
        logActivity(req.user.id, 'delete_notification_channel', `Deleted notification channel: ${channel.name}`, req.ip);
        
        res.json({ success: true, message: 'Notification channel deleted' });
    } catch (error) {
        loggers.system.error('Error deleting notification channel:', error);
        res.status(500).json({ error: 'Failed to delete notification channel' });
    }
});

// Test notification channel
app.post('/api/alerts/channels/:id/test', requireAuth, async (req, res) => {
    try {
        if (!alertingEngine) {
            return res.status(503).json({ error: 'Alerting engine not available' });
        }

        const { id } = req.params;
        
        // Create a test alert
        const testAlert = {
            id: crypto.randomUUID(),
            ruleId: 'test',
            ruleName: 'Test Alert',
            severity: 'medium',
            timestamp: Date.now(),
            logEvent: {
                message: 'This is a test alert to verify notification channel configuration.',
                severity: 'info',
                source: 'Enterprise Logging Platform',
                device_id: 'test-device',
                timestamp: Date.now()
            },
            channels: [id],
            status: 'test'
        };

        const result = await alertingEngine.sendNotification(id, testAlert);
        
        logActivity(req.user.id, 'test_notification_channel', `Tested notification channel: ${id}`, req.ip);
        
        res.json({ success: result.success, result });
    } catch (error) {
        loggers.system.error('Error testing notification channel:', error);
        res.status(500).json({ error: 'Failed to test notification channel' });
    }
});

// ============================================================================
// ADVANCED SEARCH & QUERY LANGUAGE API ENDPOINTS
// ============================================================================

// Execute advanced search with Elasticsearch-style DSL
app.post('/api/search/query', requireAuth, async (req, res) => {
    try {
        if (!advancedSearchEngine) {
            return res.status(503).json({ error: 'Advanced search engine not available' });
        }

        const { query, options = {} } = req.body;
        
        if (!query) {
            return res.status(400).json({ error: 'Query is required' });
        }

        const startTime = Date.now();
        const result = await advancedSearchEngine.executeSearch(query, options);
        result.took = Date.now() - startTime;

        logActivity(req.user.id, 'advanced_search', `Query executed: ${JSON.stringify(query).substring(0, 100)}...`, req.ip);
        
        res.json({ success: true, ...result });
    } catch (error) {
        loggers.system.error('Advanced search error:', error);
        res.status(500).json({ error: 'Search execution failed', details: error.message });
    }
});

// Execute simple query string search
app.get('/api/search/simple', requireAuth, async (req, res) => {
    try {
        if (!advancedSearchEngine) {
            return res.status(503).json({ error: 'Advanced search engine not available' });
        }

        const { q, size = 20, from = 0, sort = 'timestamp:desc' } = req.query;
        
        if (!q) {
            return res.status(400).json({ error: 'Query parameter "q" is required' });
        }

        const query = {
            query: { query_string: { query: q } },
            size: parseInt(size),
            from: parseInt(from),
            sort: [{ [sort.split(':')[0]]: sort.split(':')[1] || 'desc' }]
        };

        const result = await advancedSearchEngine.executeSearch(query);
        
        logActivity(req.user.id, 'simple_search', `Simple search: ${q}`, req.ip);
        
        res.json({ success: true, ...result });
    } catch (error) {
        loggers.system.error('Simple search error:', error);
        res.status(500).json({ error: 'Search execution failed', details: error.message });
    }
});

// Execute fuzzy search
app.post('/api/search/fuzzy', requireAuth, async (req, res) => {
    try {
        if (!advancedSearchEngine) {
            return res.status(503).json({ error: 'Advanced search engine not available' });
        }

        const { text, field = 'message', fuzziness = 2, size = 20 } = req.body;
        
        if (!text) {
            return res.status(400).json({ error: 'Text is required for fuzzy search' });
        }

        const query = {
            query: {
                fuzzy: {
                    [field]: {
                        value: text,
                        fuzziness: fuzziness
                    }
                }
            },
            size: parseInt(size)
        };

        const result = await advancedSearchEngine.executeSearch(query);
        
        logActivity(req.user.id, 'fuzzy_search', `Fuzzy search: ${text}`, req.ip);
        
        res.json({ success: true, ...result });
    } catch (error) {
        loggers.system.error('Fuzzy search error:', error);
        res.status(500).json({ error: 'Fuzzy search failed', details: error.message });
    }
});

// Get search query templates
app.get('/api/search/templates', requireAuth, (req, res) => {
    try {
        if (!advancedSearchEngine) {
            return res.status(503).json({ error: 'Advanced search engine not available' });
        }

        const templates = advancedSearchEngine.getQueryTemplates();
        res.json({ success: true, templates });
    } catch (error) {
        loggers.system.error('Error getting search templates:', error);
        res.status(500).json({ error: 'Failed to get search templates' });
    }
});

// Execute predefined template search
app.post('/api/search/template/:templateName', requireAuth, async (req, res) => {
    try {
        if (!advancedSearchEngine) {
            return res.status(503).json({ error: 'Advanced search engine not available' });
        }

        const { templateName } = req.params;
        const { params = {} } = req.body;
        
        const templates = advancedSearchEngine.getQueryTemplates();
        const template = templates[templateName];
        
        if (!template) {
            return res.status(404).json({ error: 'Template not found' });
        }

        // Replace template parameters
        let query = JSON.parse(JSON.stringify(template));
        
        // Simple parameter substitution (can be enhanced)
        Object.entries(params).forEach(([key, value]) => {
            const queryStr = JSON.stringify(query);
            const replaced = queryStr.replace(new RegExp(`{{${key}}}`, 'g'), value);
            query = JSON.parse(replaced);
        });

        const result = await advancedSearchEngine.executeSearch(query);
        
        logActivity(req.user.id, 'template_search', `Template search: ${templateName}`, req.ip);
        
        res.json({ success: true, template: templateName, ...result });
    } catch (error) {
        loggers.system.error('Template search error:', error);
        res.status(500).json({ error: 'Template search failed', details: error.message });
    }
});

// Execute aggregation-only query
app.post('/api/search/aggregations', requireAuth, async (req, res) => {
    try {
        if (!advancedSearchEngine) {
            return res.status(503).json({ error: 'Advanced search engine not available' });
        }

        const { aggregations, filters = {} } = req.body;
        
        if (!aggregations) {
            return res.status(400).json({ error: 'Aggregations are required' });
        }

        const query = {
            query: filters.query || { match_all: {} },
            size: 0, // Only return aggregations
            aggs: aggregations
        };

        const result = await advancedSearchEngine.executeSearch(query);
        
        logActivity(req.user.id, 'aggregation_search', `Aggregation query executed`, req.ip);
        
        res.json({ success: true, aggregations: result.aggregations });
    } catch (error) {
        loggers.system.error('Aggregation search error:', error);
        res.status(500).json({ error: 'Aggregation search failed', details: error.message });
    }
});

// Get search suggestions/autocomplete
app.get('/api/search/suggest', requireAuth, async (req, res) => {
    try {
        if (!advancedSearchEngine) {
            return res.status(503).json({ error: 'Advanced search engine not available' });
        }

        const { field, text, size = 10 } = req.query;
        
        if (!field || !text) {
            return res.status(400).json({ error: 'Field and text parameters are required' });
        }

        // Get suggestions based on existing field values
        const query = `
            SELECT DISTINCT ${field} as suggestion, COUNT(*) as frequency
            FROM log_events 
            WHERE ${field} LIKE ? 
            GROUP BY ${field} 
            ORDER BY frequency DESC, ${field} ASC 
            LIMIT ?
        `;

        const suggestions = await new Promise((resolve, reject) => {
            advancedSearchEngine.db.all(query, [`%${text}%`, parseInt(size)], (err, rows) => {
                if (err) return reject(err);
                resolve(rows.map(row => ({
                    text: row.suggestion,
                    frequency: row.frequency
                })));
            });
        });

        res.json({ success: true, suggestions });
    } catch (error) {
        loggers.system.error('Search suggestions error:', error);
        res.status(500).json({ error: 'Failed to get suggestions' });
    }
});

// Advanced search analytics
app.get('/api/search/analytics', requireAuth, async (req, res) => {
    try {
        const { period = '24h' } = req.query;
        
        // Get search usage statistics
        let timeFilter;
        switch (period) {
            case '1h': timeFilter = "datetime(timestamp, '-1 hour')"; break;
            case '24h': timeFilter = "datetime(timestamp, '-1 day')"; break;
            case '7d': timeFilter = "datetime(timestamp, '-7 days')"; break;
            default: timeFilter = "datetime(timestamp, '-1 day')";
        }

        const queries = [
            {
                name: 'total_logs',
                sql: `SELECT COUNT(*) as count FROM log_events WHERE timestamp >= ${timeFilter}`
            },
            {
                name: 'by_severity',
                sql: `SELECT severity, COUNT(*) as count FROM log_events WHERE timestamp >= ${timeFilter} GROUP BY severity`
            },
            {
                name: 'by_source',
                sql: `SELECT source, COUNT(*) as count FROM log_events WHERE timestamp >= ${timeFilter} GROUP BY source ORDER BY count DESC LIMIT 10`
            },
            {
                name: 'hourly_distribution',
                sql: `SELECT strftime('%H', timestamp) as hour, COUNT(*) as count FROM log_events WHERE timestamp >= ${timeFilter} GROUP BY hour ORDER BY hour`
            }
        ];

        const analytics = {};
        
        for (const query of queries) {
            const result = await new Promise((resolve, reject) => {
                advancedSearchEngine.db.all(query.sql, [], (err, rows) => {
                    if (err) return reject(err);
                    resolve(rows);
                });
            });
            analytics[query.name] = result;
        }

        res.json({ success: true, period, analytics });
    } catch (error) {
        loggers.system.error('Search analytics error:', error);
        res.status(500).json({ error: 'Failed to get search analytics' });
    }
});

// Advanced Search Management Page
app.get('/admin/search-advanced', requireAuth, (req, res) => {
    const pageContent = `
        <div class="container-fluid">
            <div class="row">
                <div class="col-12">
                    <h2><i class="fas fa-search"></i> Advanced Search & Query Language</h2>
                    <p class="text-muted">Elasticsearch-style DSL queries with fuzzy search and advanced analytics</p>
                    
                    <div class="row">
                        <div class="col-md-8">
                            <div class="card">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <h5><i class="fas fa-code"></i> Query Builder</h5>
                                    <div>
                                        <select id="queryTemplate" class="form-select form-select-sm" onchange="loadTemplate()">
                                            <option value="">Select Template</option>
                                            <option value="errors_last_hour">Errors (Last Hour)</option>
                                            <option value="security_events">Security Events</option>
                                            <option value="device_activity">Device Activity</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <ul class="nav nav-tabs" id="queryTabs" role="tablist">
                                        <li class="nav-item" role="presentation">
                                            <button class="nav-link active" id="simple-tab" data-bs-toggle="tab" data-bs-target="#simple" type="button">Simple Query</button>
                                        </li>
                                        <li class="nav-item" role="presentation">
                                            <button class="nav-link" id="dsl-tab" data-bs-toggle="tab" data-bs-target="#dsl" type="button">DSL Query</button>
                                        </li>
                                        <li class="nav-item" role="presentation">
                                            <button class="nav-link" id="fuzzy-tab" data-bs-toggle="tab" data-bs-target="#fuzzy" type="button">Fuzzy Search</button>
                                        </li>
                                    </ul>
                                    
                                    <div class="tab-content mt-3" id="queryTabContent">
                                        <div class="tab-pane fade show active" id="simple" role="tabpanel">
                                            <div class="mb-3">
                                                <label for="simpleQuery" class="form-label">Simple Query String</label>
                                                <input type="text" class="form-control" id="simpleQuery" placeholder="severity:error AND message:failed OR source:device123">
                                                <div class="form-text">
                                                    Examples: <code>severity:error</code>, <code>message:"login failed"</code>, <code>source:device* AND timestamp:>now-1h</code>
                                                </div>
                                            </div>
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <label for="simpleSize" class="form-label">Results</label>
                                                    <select class="form-select" id="simpleSize">
                                                        <option value="10">10 results</option>
                                                        <option value="20" selected>20 results</option>
                                                        <option value="50">50 results</option>
                                                        <option value="100">100 results</option>
                                                    </select>
                                                </div>
                                                <div class="col-md-6">
                                                    <label for="simpleSort" class="form-label">Sort</label>
                                                    <select class="form-select" id="simpleSort">
                                                        <option value="timestamp:desc" selected>Timestamp (newest first)</option>
                                                        <option value="timestamp:asc">Timestamp (oldest first)</option>
                                                        <option value="severity:desc">Severity (highest first)</option>
                                                        <option value="source:asc">Source (A-Z)</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div class="tab-pane fade" id="dsl" role="tabpanel">
                                            <div class="mb-3">
                                                <label for="dslQuery" class="form-label">Elasticsearch-style DSL Query</label>
                                                <textarea class="form-control" id="dslQuery" rows="10" placeholder='{\n  "query": {\n    "bool": {\n      "must": [\n        { "term": { "severity": "error" } },\n        { "range": { "timestamp": { "gte": "now-1h" } } }\n      ]\n    }\n  },\n  "aggs": {\n    "by_source": {\n      "terms": { "field": "source", "size": 10 }\n    }\n  }\n}'></textarea>
                                            </div>
                                        </div>
                                        
                                        <div class="tab-pane fade" id="fuzzy" role="tabpanel">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <label for="fuzzyText" class="form-label">Search Text</label>
                                                    <input type="text" class="form-control" id="fuzzyText" placeholder="authentication">
                                                </div>
                                                <div class="col-md-3">
                                                    <label for="fuzzyField" class="form-label">Field</label>
                                                    <select class="form-select" id="fuzzyField">
                                                        <option value="message" selected>Message</option>
                                                        <option value="source">Source</option>
                                                        <option value="category">Category</option>
                                                        <option value="device_id">Device ID</option>
                                                    </select>
                                                </div>
                                                <div class="col-md-3">
                                                    <label for="fuzzyLevel" class="form-label">Fuzziness</label>
                                                    <select class="form-select" id="fuzzyLevel">
                                                        <option value="1">1 (strict)</option>
                                                        <option value="2" selected>2 (moderate)</option>
                                                        <option value="3">3 (loose)</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="mt-3">
                                        <button type="button" class="btn btn-primary" onclick="executeSearch()">
                                            <i class="fas fa-search"></i> Execute Search
                                        </button>
                                        <button type="button" class="btn btn-secondary" onclick="clearSearch()">
                                            <i class="fas fa-eraser"></i> Clear
                                        </button>
                                        <button type="button" class="btn btn-info" onclick="showAnalytics()">
                                            <i class="fas fa-chart-line"></i> Analytics
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-md-4">
                            <div class="card">
                                <div class="card-header">
                                    <h5><i class="fas fa-info-circle"></i> Search Help</h5>
                                </div>
                                <div class="card-body">
                                    <h6>Simple Query Syntax:</h6>
                                    <ul class="small">
                                        <li><code>field:value</code> - Exact match</li>
                                        <li><code>field:"exact phrase"</code> - Phrase match</li>
                                        <li><code>field:value*</code> - Wildcard</li>
                                        <li><code>AND</code>, <code>OR</code> - Operators</li>
                                    </ul>
                                    
                                    <h6>DSL Query Features:</h6>
                                    <ul class="small">
                                        <li><code>bool</code> queries with must/should/must_not</li>
                                        <li><code>term</code>, <code>match</code>, <code>range</code> queries</li>
                                        <li><code>wildcard</code> and <code>fuzzy</code> queries</li>
                                        <li><code>aggregations</code> for analytics</li>
                                    </ul>
                                    
                                    <h6>Fuzzy Search:</h6>
                                    <ul class="small">
                                        <li>Handles typos and variations</li>
                                        <li>Adjustable fuzziness levels</li>
                                        <li>Field-specific search</li>
                                    </ul>
                                </div>
                            </div>
                            
                            <div class="card mt-3" id="suggestionsCard" style="display: none;">
                                <div class="card-header">
                                    <h6><i class="fas fa-lightbulb"></i> Suggestions</h6>
                                </div>
                                <div class="card-body">
                                    <div id="suggestionsList"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="row mt-4">
                        <div class="col-12">
                            <div class="card">
                                <div class="card-header d-flex justify-content-between align-items-center">
                                    <h5><i class="fas fa-list"></i> Search Results</h5>
                                    <span id="searchInfo" class="text-muted"></span>
                                </div>
                                <div class="card-body">
                                    <div id="searchResults">
                                        <div class="text-center text-muted">
                                            <i class="fas fa-search fa-3x mb-3"></i>
                                            <p>Execute a search to see results here</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="row mt-4" id="aggregationsSection" style="display: none;">
                        <div class="col-12">
                            <div class="card">
                                <div class="card-header">
                                    <h5><i class="fas fa-chart-bar"></i> Aggregations</h5>
                                </div>
                                <div class="card-body">
                                    <div id="aggregationsResults"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            let templates = {};

            async function loadTemplates() {
                try {
                    const response = await fetch('/api/search/templates');
                    const data = await response.json();
                    if (data.success) {
                        templates = data.templates;
                    }
                } catch (error) {
                    console.error('Failed to load templates:', error);
                }
            }

            function loadTemplate() {
                const templateName = document.getElementById('queryTemplate').value;
                if (templateName && templates[templateName]) {
                    document.getElementById('dslQuery').value = JSON.stringify(templates[templateName], null, 2);
                    // Switch to DSL tab
                    document.getElementById('dsl-tab').click();
                }
            }

            async function executeSearch() {
                const activeTab = document.querySelector('.nav-link.active').id;
                let searchData = {};

                try {
                    if (activeTab === 'simple-tab') {
                        const query = document.getElementById('simpleQuery').value;
                        const size = document.getElementById('simpleSize').value;
                        const sort = document.getElementById('simpleSort').value;

                        if (!query) {
                            showToast('Please enter a search query', 'warning');
                            return;
                        }

                        const response = await fetch(\`/api/search/simple?q=\${encodeURIComponent(query)}&size=\${size}&sort=\${sort}\`);
                        searchData = await response.json();
                    } else if (activeTab === 'dsl-tab') {
                        const queryText = document.getElementById('dslQuery').value;
                        
                        if (!queryText) {
                            showToast('Please enter a DSL query', 'warning');
                            return;
                        }

                        let query;
                        try {
                            query = JSON.parse(queryText);
                        } catch (e) {
                            showToast('Invalid JSON in DSL query', 'error');
                            return;
                        }

                        const response = await fetch('/api/search/query', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ query })
                        });
                        searchData = await response.json();
                    } else if (activeTab === 'fuzzy-tab') {
                        const text = document.getElementById('fuzzyText').value;
                        const field = document.getElementById('fuzzyField').value;
                        const fuzziness = document.getElementById('fuzzyLevel').value;

                        if (!text) {
                            showToast('Please enter text for fuzzy search', 'warning');
                            return;
                        }

                        const response = await fetch('/api/search/fuzzy', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ text, field, fuzziness: parseInt(fuzziness) })
                        });
                        searchData = await response.json();
                    }

                    if (searchData.success) {
                        displayResults(searchData);
                        showToast(\`Found \${searchData.hits.total} results in \${searchData.took}ms\`, 'success');
                    } else {
                        showToast(\`Search failed: \${searchData.error}\`, 'error');
                    }
                } catch (error) {
                    console.error('Search error:', error);
                    showToast('Search execution failed', 'error');
                }
            }

            function displayResults(data) {
                const resultsDiv = document.getElementById('searchResults');
                const infoSpan = document.getElementById('searchInfo');
                
                infoSpan.textContent = \`\${data.hits.total} results (\${data.took}ms)\`;
                
                if (data.hits.hits.length === 0) {
                    resultsDiv.innerHTML = '<div class="text-center text-muted"><i class="fas fa-exclamation-circle fa-2x mb-3"></i><p>No results found</p></div>';
                    return;
                }

                let html = '<div class="table-responsive"><table class="table table-striped table-hover"><thead><tr><th>Timestamp</th><th>Severity</th><th>Source</th><th>Message</th></tr></thead><tbody>';
                
                data.hits.hits.forEach(hit => {
                    const source = hit._source;
                    const severityClass = getSeverityClass(source.severity);
                    const timestamp = formatTimestamp(source.timestamp);
                    
                    html += \`
                        <tr>
                            <td>\${timestamp}</td>
                            <td><span class="badge \${severityClass}">\${source.severity}</span></td>
                            <td>\${source.source || 'N/A'}</td>
                            <td>\${source.message}</td>
                        </tr>
                    \`;
                });
                
                html += '</tbody></table></div>';
                resultsDiv.innerHTML = html;

                // Display aggregations if present
                if (data.aggregations && Object.keys(data.aggregations).length > 0) {
                    displayAggregations(data.aggregations);
                    document.getElementById('aggregationsSection').style.display = 'block';
                } else {
                    document.getElementById('aggregationsSection').style.display = 'none';
                }
            }

            function displayAggregations(aggregations) {
                const aggDiv = document.getElementById('aggregationsResults');
                let html = '<div class="row">';

                Object.entries(aggregations).forEach(([name, agg]) => {
                    html += '<div class="col-md-6 mb-3">';
                    html += \`<h6>\${name}</h6>\`;
                    
                    if (agg.buckets) {
                        html += '<ul class="list-group list-group-flush">';
                        agg.buckets.forEach(bucket => {
                            html += \`<li class="list-group-item d-flex justify-content-between align-items-center">
                                \${bucket.key}
                                <span class="badge bg-primary rounded-pill">\${bucket.doc_count}</span>
                            </li>\`;
                        });
                        html += '</ul>';
                    } else if (agg.value !== undefined) {
                        html += \`<div class="alert alert-info">\${agg.value}</div>\`;
                    }
                    
                    html += '</div>';
                });

                html += '</div>';
                aggDiv.innerHTML = html;
            }

            async function showAnalytics() {
                try {
                    const response = await fetch('/api/search/analytics?period=24h');
                    const data = await response.json();
                    
                    if (data.success) {
                        displayAnalytics(data.analytics);
                    }
                } catch (error) {
                    console.error('Analytics error:', error);
                    showToast('Failed to load analytics', 'error');
                }
            }

            function displayAnalytics(analytics) {
                // Create analytics modal or section
                // This would show charts and statistics
                showToast('Analytics feature coming soon!', 'info');
            }

            function clearSearch() {
                document.getElementById('simpleQuery').value = '';
                document.getElementById('dslQuery').value = '';
                document.getElementById('fuzzyText').value = '';
                document.getElementById('searchResults').innerHTML = '<div class="text-center text-muted"><i class="fas fa-search fa-3x mb-3"></i><p>Execute a search to see results here</p></div>';
                document.getElementById('searchInfo').textContent = '';
                document.getElementById('aggregationsSection').style.display = 'none';
            }

            function getSeverityClass(severity) {
                const classes = {
                    critical: 'bg-danger',
                    error: 'bg-danger',
                    warning: 'bg-warning text-dark',
                    info: 'bg-info',
                    debug: 'bg-secondary'
                };
                return classes[severity] || 'bg-secondary';
            }

            function formatTimestamp(timestamp) {
                return new Date(timestamp).toLocaleString();
            }

            function showToast(message, type) {
                // Simple toast implementation
                console.log(\`[\${type.toUpperCase()}] \${message}\`);
                
                const alertClass = type === 'error' ? 'alert-danger' : 
                                 type === 'warning' ? 'alert-warning' : 
                                 type === 'success' ? 'alert-success' : 'alert-info';
                
                const toastHtml = \`
                    <div class="alert \${alertClass} alert-dismissible fade show" role="alert">
                        \${message}
                        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                    </div>
                \`;
                
                // Add to top of content
                const container = document.querySelector('.container-fluid');
                container.insertAdjacentHTML('afterbegin', toastHtml);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    const alert = container.querySelector('.alert');
                    if (alert) alert.remove();
                }, 5000);
            }

            // Load templates on page load
            document.addEventListener('DOMContentLoaded', loadTemplates);
        </script>
    `;

    res.send(getPageTemplate('Advanced Search', pageContent, req.user, 'search-advanced'));
});

// MULTI-PROTOCOL LOG INGESTION API ENDPOINTS

// Get ingestion statistics and status
app.get('/api/ingestion/status', requireAuth, async (req, res) => {
    try {
        if (!multiProtocolIngestionEngine) {
            return res.status(503).json({ error: 'Multi-Protocol Ingestion Engine not available' });
        }

        const stats = multiProtocolIngestionEngine.getStats();
        
        res.json({
            success: true,
            status: 'active',
            stats: stats,
            protocols: {
                syslog: {
                    enabled: config.ingestion.syslog.enabled,
                    udp_port: config.ingestion.syslog.udpPort,
                    tcp_port: config.ingestion.syslog.tcpPort,
                    description: 'RFC3164/RFC5424 Syslog Protocol'
                },
                gelf: {
                    enabled: config.ingestion.gelf.enabled,
                    udp_port: config.ingestion.gelf.udpPort,
                    tcp_port: config.ingestion.gelf.tcpPort,
                    description: 'Graylog Extended Log Format'
                },
                beats: {
                    enabled: config.ingestion.beats.enabled,
                    tcp_port: config.ingestion.beats.tcpPort,
                    description: 'Elastic Beats Protocol'
                },
                fluent: {
                    enabled: config.ingestion.fluent.enabled,
                    http_port: config.ingestion.fluent.httpPort,
                    description: 'Fluent Bit/Fluentd HTTP'
                }
            }
        });
        
    } catch (error) {
        loggers.system.error('Ingestion status error:', error);
        res.status(500).json({ error: 'Failed to get ingestion status' });
    }
});

// Test protocol parsing
app.post('/api/ingestion/test-parse', requireAuth, async (req, res) => {
    try {
        if (!multiProtocolIngestionEngine) {
            return res.status(503).json({ error: 'Multi-Protocol Ingestion Engine not available' });
        }

        const { protocol, message } = req.body;
        
        if (!protocol || !message) {
            return res.status(400).json({ error: 'Protocol and message are required' });
        }

        let parsed = null;
        const mockRinfo = { address: '127.0.0.1', port: 12345 };

        switch (protocol) {
            case 'syslog-rfc3164':
                parsed = await multiProtocolIngestionEngine.parseSyslogRFC3164(message, mockRinfo);
                break;
            case 'syslog-rfc5424':
                parsed = await multiProtocolIngestionEngine.parseSyslogRFC5424(message, mockRinfo);
                break;
            case 'gelf':
                parsed = await multiProtocolIngestionEngine.parseGELF(message, mockRinfo);
                break;
            case 'beats':
                parsed = await multiProtocolIngestionEngine.parseBeats(message, mockRinfo);
                break;
            case 'fluent':
                parsed = await multiProtocolIngestionEngine.parseFluentBit(JSON.parse(message), mockRinfo);
                break;
            case 'json':
                parsed = await multiProtocolIngestionEngine.parseJSON(message, mockRinfo);
                break;
            default:
                return res.status(400).json({ error: 'Unsupported protocol' });
        }

        res.json({
            success: true,
            protocol: protocol,
            original_message: message,
            parsed: parsed,
            valid: !!parsed
        });
        
    } catch (error) {
        loggers.system.error('Protocol parsing test error:', error);
        res.status(500).json({ 
            success: false,
            error: 'Parsing failed', 
            details: error.message 
        });
    }
});

// Get protocol-specific ingestion statistics
app.get('/api/ingestion/stats/:protocol', requireAuth, async (req, res) => {
    try {
        if (!multiProtocolIngestionEngine) {
            return res.status(503).json({ error: 'Multi-Protocol Ingestion Engine not available' });
        }

        const { protocol } = req.params;
        const stats = multiProtocolIngestionEngine.getStats();
        
        const protocolStats = {
            protocol: protocol,
            messages: stats.messagesByProtocol[protocol] || 0,
            percentage: stats.totalMessages > 0 ? 
                ((stats.messagesByProtocol[protocol] || 0) / stats.totalMessages * 100).toFixed(2) : 0
        };

        res.json({
            success: true,
            stats: protocolStats,
            global_stats: {
                total_messages: stats.totalMessages,
                total_errors: stats.errors,
                active_connections: stats.connectionsActive,
                bytes_received: stats.bytesReceived,
                uptime: process.uptime()
            }
        });
        
    } catch (error) {
        loggers.system.error('Protocol stats error:', error);
        res.status(500).json({ error: 'Failed to get protocol statistics' });
    }
});

// ============================================================
// ADVANCED DASHBOARD BUILDER API ENDPOINTS 
// ============================================================

// Get all dashboards for user
app.get('/api/dashboards', requireAuth, async (req, res) => {
    try {
        if (!advancedDashboardBuilder) {
            return res.status(503).json({
                success: false,
                error: 'Dashboard Builder not initialized'
            });
        }

        const dashboards = advancedDashboardBuilder.getDashboards(req.user.userId);
        
        res.json({
            success: true,
            data: dashboards,
            count: dashboards.length,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        loggers.api.error('Failed to get dashboards:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Get specific dashboard
app.get('/api/dashboards/:id', requireAuth, async (req, res) => {
    try {
        if (!advancedDashboardBuilder) {
            return res.status(503).json({
                success: false,
                error: 'Dashboard Builder not initialized'
            });
        }

        const dashboard = advancedDashboardBuilder.getDashboard(req.params.id);
        if (!dashboard) {
            return res.status(404).json({
                success: false,
                error: 'Dashboard not found'
            });
        }

        const widgets = advancedDashboardBuilder.getWidgets(req.params.id);

        res.json({
            success: true,
            data: {
                dashboard: dashboard,
                widgets: widgets
            },
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        loggers.api.error('Failed to get dashboard:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Create new dashboard
app.post('/api/dashboards', requireAuth, async (req, res) => {
    try {
        if (!advancedDashboardBuilder) {
            return res.status(503).json({
                success: false,
                error: 'Dashboard Builder not initialized'
            });
        }

        const dashboard = await advancedDashboardBuilder.createDashboard(req.user.userId, req.body);
        
        res.status(201).json({
            success: true,
            data: dashboard,
            message: 'Dashboard created successfully',
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        loggers.api.error('Failed to create dashboard:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Add widget to dashboard
app.post('/api/dashboards/:id/widgets', requireAuth, async (req, res) => {
    try {
        if (!advancedDashboardBuilder) {
            return res.status(503).json({
                success: false,
                error: 'Dashboard Builder not initialized'
            });
        }

        const widget = await advancedDashboardBuilder.addWidget(req.params.id, req.body);
        
        res.status(201).json({
            success: true,
            data: widget,
            message: 'Widget added successfully',
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        loggers.api.error('Failed to add widget:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Get widget data
app.get('/api/dashboards/:dashboardId/widgets/:widgetId/data', requireAuth, async (req, res) => {
    try {
        if (!advancedDashboardBuilder) {
            return res.status(503).json({
                success: false,
                error: 'Dashboard Builder not initialized'
            });
        }

        const widgets = advancedDashboardBuilder.getWidgets(req.params.dashboardId);
        const widget = widgets.find(w => w.id === req.params.widgetId);
        
        if (!widget) {
            return res.status(404).json({
                success: false,
                error: 'Widget not found'
            });
        }

        const data = await advancedDashboardBuilder.generateWidgetData(widget);
        
        res.json({
            success: true,
            data: data,
            widget: {
                id: widget.id,
                type: widget.widget_type,
                title: widget.title
            },
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        loggers.api.error('Failed to get widget data:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Get available widget types
app.get('/api/dashboards/widget-types', requireAuth, async (req, res) => {
    try {
        if (!advancedDashboardBuilder) {
            return res.status(503).json({
                success: false,
                error: 'Dashboard Builder not initialized'
            });
        }

        const widgetTypes = advancedDashboardBuilder.getWidgetTypes();
        
        res.json({
            success: true,
            data: widgetTypes,
            count: widgetTypes.length,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        loggers.api.error('Failed to get widget types:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Update dashboard layout
app.put('/api/dashboards/:id/layout', requireAuth, async (req, res) => {
    try {
        if (!advancedDashboardBuilder) {
            return res.status(503).json({
                success: false,
                error: 'Dashboard Builder not initialized'
            });
        }

        const { layout } = req.body;
        
        db.prepare(`
            UPDATE dashboards 
            SET layout_config = ?, updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        `).run(JSON.stringify(layout), req.params.id);

        // Update in memory
        const dashboard = advancedDashboardBuilder.getDashboard(req.params.id);
        if (dashboard) {
            dashboard.layoutConfig = layout;
        }

        res.json({
            success: true,
            message: 'Dashboard layout updated successfully',
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        loggers.api.error('Failed to update dashboard layout:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Multi-Protocol Ingestion Management Page
app.get('/admin/ingestion', requireAuth, (req, res) => {
    const pageContent = `
        <div class="container-fluid">
            <div class="row">
                <div class="col-12">
                    <h2><i class="fas fa-network-wired"></i> Multi-Protocol Log Ingestion</h2>
                    <p class="text-muted">Enterprise-grade log ingestion supporting Syslog, GELF, Beats, Fluent Bit and more</p>
                    
                    <div class="row mb-4">
                        <!-- Protocol Status Cards -->
                        <div class="col-md-3 mb-3">
                            <div class="card border-primary">
                                <div class="card-body text-center">
                                    <i class="fas fa-server fa-2x text-primary mb-2"></i>
                                    <h5>Syslog</h5>
                                    <p class="text-muted">RFC3164/5424</p>
                                    <div class="protocol-status" data-protocol="syslog">
                                        <span class="badge bg-success">Active</span>
                                        <br><small>UDP: ${config.ingestion.syslog.udpPort} | TCP: ${config.ingestion.syslog.tcpPort}</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-md-3 mb-3">
                            <div class="card border-info">
                                <div class="card-body text-center">
                                    <i class="fas fa-layer-group fa-2x text-info mb-2"></i>
                                    <h5>GELF</h5>
                                    <p class="text-muted">Graylog Extended</p>
                                    <div class="protocol-status" data-protocol="gelf">
                                        <span class="badge bg-success">Active</span>
                                        <br><small>UDP: ${config.ingestion.gelf.udpPort} | TCP: ${config.ingestion.gelf.tcpPort}</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-md-3 mb-3">
                            <div class="card border-warning">
                                <div class="card-body text-center">
                                    <i class="fas fa-heartbeat fa-2x text-warning mb-2"></i>
                                    <h5>Beats</h5>
                                    <p class="text-muted">Elastic Ecosystem</p>
                                    <div class="protocol-status" data-protocol="beats">
                                        <span class="badge bg-success">Active</span>
                                        <br><small>TCP: ${config.ingestion.beats.tcpPort}</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-md-3 mb-3">
                            <div class="card border-success">
                                <div class="card-body text-center">
                                    <i class="fas fa-stream fa-2x text-success mb-2"></i>
                                    <h5>Fluent Bit</h5>
                                    <p class="text-muted">Fluent Ecosystem</p>
                                    <div class="protocol-status" data-protocol="fluent">
                                        <span class="badge bg-success">Active</span>
                                        <br><small>HTTP: ${config.ingestion.fluent.httpPort}</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-8">
                            <!-- Statistics Card -->
                            <div class="card mb-4">
                                <div class="card-header">
                                    <h5><i class="fas fa-chart-bar"></i> Ingestion Statistics</h5>
                                </div>
                                <div class="card-body">
                                    <div class="row">
                                        <div class="col-md-6">
                                            <canvas id="protocolChart" width="400" height="200"></canvas>
                                        </div>
                                        <div class="col-md-6">
                                            <div class="stats-grid" id="statsGrid">
                                                <div class="text-center">
                                                    <i class="fas fa-spinner fa-spin"></i> Loading statistics...
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Protocol Testing Card -->
                            <div class="card">
                                <div class="card-header">
                                    <h5><i class="fas fa-vial"></i> Protocol Testing</h5>
                                </div>
                                <div class="card-body">
                                    <div class="mb-3">
                                        <label class="form-label">Protocol</label>
                                        <select class="form-select" id="testProtocol">
                                            <option value="syslog-rfc3164">Syslog RFC3164</option>
                                            <option value="syslog-rfc5424">Syslog RFC5424</option>
                                            <option value="gelf">GELF</option>
                                            <option value="beats">Beats</option>
                                            <option value="fluent">Fluent Bit</option>
                                            <option value="json">JSON</option>
                                        </select>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <label class="form-label">Test Message</label>
                                        <textarea class="form-control" id="testMessage" rows="3" 
                                            placeholder="Enter a log message to test parsing..."></textarea>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <button type="button" class="btn btn-primary" onclick="testParsing()">
                                            <i class="fas fa-play"></i> Test Parsing
                                        </button>
                                        <button type="button" class="btn btn-secondary ms-2" onclick="loadSampleMessage()">
                                            <i class="fas fa-file-alt"></i> Load Sample
                                        </button>
                                    </div>
                                    
                                    <div id="testResults" class="d-none">
                                        <h6>Parsing Results</h6>
                                        <pre id="parsedOutput" class="bg-light p-3 rounded"></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-md-4">
                            <!-- Configuration Card -->
                            <div class="card">
                                <div class="card-header">
                                    <h5><i class="fas fa-cog"></i> Configuration</h5>
                                </div>
                                <div class="card-body">
                                    <h6>Environment Variables</h6>
                                    <div class="mb-2">
                                        <small class="text-muted">SYSLOG_UDP_PORT</small><br>
                                        <code>${config.ingestion.syslog.udpPort}</code>
                                    </div>
                                    <div class="mb-2">
                                        <small class="text-muted">SYSLOG_TCP_PORT</small><br>
                                        <code>${config.ingestion.syslog.tcpPort}</code>
                                    </div>
                                    <div class="mb-2">
                                        <small class="text-muted">GELF_UDP_PORT</small><br>
                                        <code>${config.ingestion.gelf.udpPort}</code>
                                    </div>
                                    <div class="mb-2">
                                        <small class="text-muted">GELF_TCP_PORT</small><br>
                                        <code>${config.ingestion.gelf.tcpPort}</code>
                                    </div>
                                    <div class="mb-2">
                                        <small class="text-muted">BEATS_TCP_PORT</small><br>
                                        <code>${config.ingestion.beats.tcpPort}</code>
                                    </div>
                                    <div class="mb-2">
                                        <small class="text-muted">FLUENT_HTTP_PORT</small><br>
                                        <code>${config.ingestion.fluent.httpPort}</code>
                                    </div>
                                    
                                    <hr>
                                    
                                    <h6>Protocol Documentation</h6>
                                    <div class="list-group list-group-flush">
                                        <a href="#" class="list-group-item list-group-item-action" onclick="showProtocolHelp('syslog')">
                                            <i class="fas fa-book"></i> Syslog Setup
                                        </a>
                                        <a href="#" class="list-group-item list-group-item-action" onclick="showProtocolHelp('gelf')">
                                            <i class="fas fa-book"></i> GELF Setup
                                        </a>
                                        <a href="#" class="list-group-item list-group-item-action" onclick="showProtocolHelp('beats')">
                                            <i class="fas fa-book"></i> Beats Setup
                                        </a>
                                        <a href="#" class="list-group-item list-group-item-action" onclick="showProtocolHelp('fluent')">
                                            <i class="fas fa-book"></i> Fluent Bit Setup
                                        </a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <script>
            let protocolChart;
            
            async function loadIngestionStats() {
                try {
                    const response = await fetch('/api/ingestion/status');
                    const data = await response.json();
                    
                    if (data.success) {
                        updateStatsGrid(data.stats);
                        updateProtocolChart(data.stats.messagesByProtocol);
                    }
                } catch (error) {
                    console.error('Failed to load ingestion stats:', error);
                }
            }
            
            function updateStatsGrid(stats) {
                const grid = document.getElementById('statsGrid');
                grid.innerHTML = \`
                    <div class="row text-center">
                        <div class="col-6 mb-3">
                            <h4 class="text-primary">\${stats.totalMessages.toLocaleString()}</h4>
                            <small class="text-muted">Total Messages</small>
                        </div>
                        <div class="col-6 mb-3">
                            <h4 class="text-success">\${stats.connectionsActive}</h4>
                            <small class="text-muted">Active Connections</small>
                        </div>
                        <div class="col-6 mb-3">
                            <h4 class="text-info">\${formatBytes(stats.bytesReceived)}</h4>
                            <small class="text-muted">Bytes Received</small>
                        </div>
                        <div class="col-6 mb-3">
                            <h4 class="text-warning">\${stats.errors}</h4>
                            <small class="text-muted">Parse Errors</small>
                        </div>
                    </div>
                \`;
            }
            
            function updateProtocolChart(messagesByProtocol) {
                const ctx = document.getElementById('protocolChart').getContext('2d');
                
                if (protocolChart) {
                    protocolChart.destroy();
                }
                
                const protocols = Object.keys(messagesByProtocol);
                const counts = Object.values(messagesByProtocol);
                
                protocolChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: protocols.map(p => p.replace('-', ' ').toUpperCase()),
                        datasets: [{
                            data: counts,
                            backgroundColor: ['#007bff', '#28a745', '#ffc107', '#17a2b8', '#6f42c1', '#e83e8c'],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: {
                                position: 'bottom'
                            }
                        }
                    }
                });
            }
            
            async function testParsing() {
                const protocol = document.getElementById('testProtocol').value;
                const message = document.getElementById('testMessage').value;
                
                if (!message.trim()) {
                    alert('Please enter a message to test');
                    return;
                }
                
                try {
                    const response = await fetch('/api/ingestion/test-parse', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ protocol, message })
                    });
                    
                    const result = await response.json();
                    
                    document.getElementById('testResults').classList.remove('d-none');
                    document.getElementById('parsedOutput').textContent = JSON.stringify(result, null, 2);
                    
                } catch (error) {
                    alert('Failed to test parsing: ' + error.message);
                }
            }
            
            function loadSampleMessage() {
                const protocol = document.getElementById('testProtocol').value;
                const samples = {
                    'syslog-rfc3164': '<34>Oct 11 22:14:15 mymachine su: su root failed for lonvick on /dev/pts/8',
                    'syslog-rfc5424': '<165>1 2003-10-11T22:14:15.003Z mymachine.example.com evntslog - ID47 [exampleSDID@32473 iut="3" eventSource="Application" eventID="1011"] BOMAn application event log entry',
                    'gelf': '{"version":"1.1","host":"example.org","short_message":"A short message","full_message":"A long message","timestamp":1385053862.3072,"level":1,"_user_id":9001,"_some_info":"foo","_some_env_var":"bar"}',
                    'beats': '{"@timestamp":"2023-01-01T12:00:00.000Z","beat":{"name":"filebeat","hostname":"web-server"},"message":"User login successful","fields":{"environment":"production"}}',
                    'fluent': '[1640995200, {"host":"web-server","message":"Request processed","level":"info","response_time":123}]',
                    'json': '{"timestamp":"2023-01-01T12:00:00Z","host":"web-server","level":"info","message":"Application started successfully"}'
                };
                
                document.getElementById('testMessage').value = samples[protocol] || '';
            }
            
            function showProtocolHelp(protocol) {
                const helpContent = {
                    syslog: 'Configure your syslog daemon to forward logs to this server:\\n\\nrsyslog: *.* @@server:601\\nudp: *.* @server:514',
                    gelf: 'Configure Graylog or applications to send GELF messages:\\n\\nHost: server\\nPort: 12201 (UDP) or 12202 (TCP)\\nProtocol: GELF',
                    beats: 'Configure Filebeat, Metricbeat, etc:\\n\\noutput.logstash:\\n  hosts: ["server:5044"]',
                    fluent: 'Configure Fluent Bit:\\n\\n[OUTPUT]\\n    name http\\n    host server\\n    port 9880\\n    uri /fluent/logs'
                };
                
                alert(helpContent[protocol] || 'Help not available for this protocol');
            }
            
            function formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            // Load stats on page load
            document.addEventListener('DOMContentLoaded', () => {
                loadIngestionStats();
                
                // Refresh stats every 30 seconds
                setInterval(loadIngestionStats, 30000);
            });
        </script>
    `;

    const chartJSScript = `
        // Chart.js is now loaded globally, just initialize
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof loadIngestionStats === 'function') {
                loadIngestionStats();
            }
        });
    `;

    res.send(getPageTemplate({
        pageTitle: 'Multi-Protocol Ingestion',
        pageIcon: 'fas fa-network-wired',
        activeNav: 'ingestion',
        contentBody: pageContent,
        additionalCSS: '',
        additionalJS: chartJSScript,
        req: req
    }));
});

// DISTRIBUTED TRACING API ENDPOINTS

// Get tracing statistics and status
app.get('/api/tracing/status', requireAuth, async (req, res) => {
    try {
        if (!distributedTracingEngine || !distributedTracingEngine.isInitialized) {
            return res.status(503).json({ error: 'Distributed Tracing Engine not available' });
        }

        const stats = distributedTracingEngine.getTraceStats();
        
        res.json({
            success: true,
            enabled: config.tracing.enabled,
            service_name: config.tracing.serviceName,
            jaeger_endpoint: config.tracing.jaegerEndpoint,
            sampling_rate: config.tracing.samplingRate,
            stats: stats
        });
        
    } catch (error) {
        loggers.system.error('Tracing status error:', error);
        res.status(500).json({ error: 'Failed to get tracing status' });
    }
});

// Search traces with filters
app.get('/api/tracing/search', requireAuth, async (req, res) => {
    try {
        if (!distributedTracingEngine || !distributedTracingEngine.isInitialized) {
            return res.status(503).json({ error: 'Distributed Tracing Engine not available' });
        }

        const { service, severity, start_time, end_time, limit = 50 } = req.query;
        
        const filters = {};
        if (service) filters.service = service;
        if (severity) filters.severity = severity;
        if (start_time && end_time) {
            filters.timeRange = { start: start_time, end: end_time };
        }

        const traces = await distributedTracingEngine.searchTraces(filters);
        
        res.json({
            success: true,
            traces: traces.slice(0, parseInt(limit)),
            total: traces.length,
            filters: filters
        });
        
    } catch (error) {
        loggers.system.error('Trace search error:', error);
        res.status(500).json({ error: 'Failed to search traces' });
    }
});

// Get detailed trace data
app.get('/api/tracing/trace/:traceId', requireAuth, async (req, res) => {
    try {
        if (!distributedTracingEngine || !distributedTracingEngine.isInitialized) {
            return res.status(503).json({ error: 'Distributed Tracing Engine not available' });
        }

        const { traceId } = req.params;
        const traceData = await distributedTracingEngine.getTraceData(traceId);
        
        if (!traceData) {
            return res.status(404).json({ error: 'Trace not found' });
        }

        res.json({
            success: true,
            trace: traceData
        });
        
    } catch (error) {
        loggers.system.error('Trace detail error:', error);
        res.status(500).json({ error: 'Failed to get trace details' });
    }
});

// Get service dependency map
app.get('/api/tracing/dependencies', requireAuth, async (req, res) => {
    try {
        if (!distributedTracingEngine || !distributedTracingEngine.isInitialized) {
            return res.status(503).json({ error: 'Distributed Tracing Engine not available' });
        }

        const dependencies = await distributedTracingEngine.getServiceDependencies();
        
        res.json({
            success: true,
            dependencies: dependencies,
            services: [...new Set(dependencies.flatMap(d => [d.from, d.to]))]
        });
        
    } catch (error) {
        loggers.system.error('Service dependencies error:', error);
        res.status(500).json({ error: 'Failed to get service dependencies' });
    }
});

// Distributed Tracing Management Page
app.get('/admin/tracing', requireAuth, (req, res) => {
    const pageContent = `
        <div class="container-fluid">
            <div class="row">
                <div class="col-12">
                    <h2><i class="fas fa-project-diagram"></i> Distributed Tracing & Observability</h2>
                    <p class="text-muted">OpenTelemetry integration with Jaeger for distributed system observability and performance monitoring</p>
                    
                    <div class="row mb-4">
                        <!-- Tracing Status Card -->
                        <div class="col-md-4 mb-3">
                            <div class="card border-primary">
                                <div class="card-body text-center">
                                    <i class="fas fa-chart-network fa-2x text-primary mb-2"></i>
                                    <h5>Tracing Status</h5>
                                    <div id="tracingStatus">
                                        <span class="badge bg-success">Active</span>
                                        <br><small id="serviceName">${config.tracing.serviceName}</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-md-4 mb-3">
                            <div class="card border-info">
                                <div class="card-body text-center">
                                    <i class="fas fa-sitemap fa-2x text-info mb-2"></i>
                                    <h5>Service Map</h5>
                                    <div id="serviceMapStats">
                                        <span id="serviceCount">0</span> Services
                                        <br><small>Active Dependencies</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-md-4 mb-3">
                            <div class="card border-warning">
                                <div class="card-body text-center">
                                    <i class="fas fa-stopwatch fa-2x text-warning mb-2"></i>
                                    <h5>Performance</h5>
                                    <div id="performanceStats">
                                        <span id="avgDuration">0ms</span>
                                        <br><small>Avg Trace Duration</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-8">
                            <!-- Trace Search Card -->
                            <div class="card mb-4">
                                <div class="card-header">
                                    <h5><i class="fas fa-search"></i> Trace Search & Analysis</h5>
                                </div>
                                <div class="card-body">
                                    <div class="row mb-3">
                                        <div class="col-md-4">
                                            <label class="form-label">Service</label>
                                            <select class="form-select" id="filterService">
                                                <option value="">All Services</option>
                                            </select>
                                        </div>
                                        <div class="col-md-4">
                                            <label class="form-label">Severity</label>
                                            <select class="form-select" id="filterSeverity">
                                                <option value="">All Severities</option>
                                                <option value="error">Error</option>
                                                <option value="warning">Warning</option>
                                                <option value="info">Info</option>
                                                <option value="debug">Debug</option>
                                            </select>
                                        </div>
                                        <div class="col-md-4">
                                            <label class="form-label">Time Range</label>
                                            <select class="form-select" id="filterTimeRange">
                                                <option value="1h">Last Hour</option>
                                                <option value="6h">Last 6 Hours</option>
                                                <option value="24h">Last 24 Hours</option>
                                                <option value="7d">Last 7 Days</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <button type="button" class="btn btn-primary" onclick="searchTraces()">
                                            <i class="fas fa-search"></i> Search Traces
                                        </button>
                                        <button type="button" class="btn btn-secondary ms-2" onclick="refreshData()">
                                            <i class="fas fa-sync"></i> Refresh
                                        </button>
                                    </div>
                                    
                                    <div id="tracingResults">
                                        <div class="text-center text-muted">
                                            <i class="fas fa-search fa-3x mb-3"></i>
                                            <p>Search for traces to see results here</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Service Dependencies Card -->
                            <div class="card">
                                <div class="card-header">
                                    <h5><i class="fas fa-project-diagram"></i> Service Dependencies</h5>
                                </div>
                                <div class="card-body">
                                    <div id="dependencyMap" style="min-height: 400px;">
                                        <div class="text-center">
                                            <i class="fas fa-spinner fa-spin"></i> Loading dependency map...
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-md-4">
                            <!-- Statistics Card -->
                            <div class="card mb-4">
                                <div class="card-header">
                                    <h5><i class="fas fa-chart-bar"></i> Tracing Statistics</h5>
                                </div>
                                <div class="card-body">
                                    <div id="tracingStatsDetail">
                                        <div class="text-center">
                                            <i class="fas fa-spinner fa-spin"></i> Loading statistics...
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Configuration Card -->
                            <div class="card">
                                <div class="card-header">
                                    <h5><i class="fas fa-cog"></i> Configuration</h5>
                                </div>
                                <div class="card-body">
                                    <h6>OpenTelemetry Settings</h6>
                                    <div class="mb-2">
                                        <small class="text-muted">TRACING_SERVICE_NAME</small><br>
                                        <code>${config.tracing.serviceName}</code>
                                    </div>
                                    <div class="mb-2">
                                        <small class="text-muted">JAEGER_ENDPOINT</small><br>
                                        <code>${config.tracing.jaegerEndpoint}</code>
                                    </div>
                                    <div class="mb-2">
                                        <small class="text-muted">TRACING_SAMPLING_RATE</small><br>
                                        <code>${config.tracing.samplingRate}</code>
                                    </div>
                                    
                                    <hr>
                                    
                                    <h6>Integration Status</h6>
                                    <div class="list-group list-group-flush">
                                        <div class="list-group-item d-flex justify-content-between align-items-center">
                                            OpenTelemetry SDK
                                            <span class="badge bg-success rounded-pill">Active</span>
                                        </div>
                                        <div class="list-group-item d-flex justify-content-between align-items-center">
                                            Jaeger Exporter
                                            <span class="badge bg-success rounded-pill">Connected</span>
                                        </div>
                                        <div class="list-group-item d-flex justify-content-between align-items-center">
                                            Log Correlation
                                            <span class="badge bg-success rounded-pill">Enabled</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <script>
            let tracingStats = {};
            let dependencies = [];
            
            async function loadTracingStatus() {
                try {
                    const response = await fetch('/api/tracing/status');
                    const data = await response.json();
                    
                    if (data.success) {
                        tracingStats = data.stats;
                        updateTracingStats();
                    }
                } catch (error) {
                    console.error('Failed to load tracing status:', error);
                }
            }
            
            function updateTracingStats() {
                // Update main cards
                document.getElementById('avgDuration').textContent = 
                    Math.round(tracingStats.avgDuration || 0) + 'ms';
                
                // Update detailed statistics
                const statsDetail = document.getElementById('tracingStatsDetail');
                statsDetail.innerHTML = \`
                    <div class="row text-center">
                        <div class="col-12 mb-3">
                            <h4 class="text-primary">\${(tracingStats.totalTraces || 0).toLocaleString()}</h4>
                            <small class="text-muted">Total Traces</small>
                        </div>
                        <div class="col-6 mb-3">
                            <h5 class="text-info">\${(tracingStats.totalSpans || 0).toLocaleString()}</h5>
                            <small class="text-muted">Total Spans</small>
                        </div>
                        <div class="col-6 mb-3">
                            <h5 class="text-warning">\${tracingStats.errorsCount || 0}</h5>
                            <small class="text-muted">Errors</small>
                        </div>
                        <div class="col-6 mb-3">
                            <h5 class="text-success">\${tracingStats.activeSpans || 0}</h5>
                            <small class="text-muted">Active Spans</small>
                        </div>
                        <div class="col-6 mb-3">
                            <h5 class="text-secondary">\${tracingStats.activeTraces || 0}</h5>
                            <small class="text-muted">Active Traces</small>
                        </div>
                    </div>
                \`;
            }
            
            async function loadServiceDependencies() {
                try {
                    const response = await fetch('/api/tracing/dependencies');
                    const data = await response.json();
                    
                    if (data.success) {
                        dependencies = data.dependencies;
                        document.getElementById('serviceCount').textContent = data.services.length;
                        updateDependencyMap();
                        
                        // Update service filter
                        const serviceSelect = document.getElementById('filterService');
                        serviceSelect.innerHTML = '<option value="">All Services</option>';
                        data.services.forEach(service => {
                            const option = document.createElement('option');
                            option.value = service;
                            option.textContent = service;
                            serviceSelect.appendChild(option);
                        });
                    }
                } catch (error) {
                    console.error('Failed to load service dependencies:', error);
                }
            }
            
            function updateDependencyMap() {
                const mapDiv = document.getElementById('dependencyMap');
                
                if (dependencies.length === 0) {
                    mapDiv.innerHTML = '<div class="text-center text-muted"><p>No service dependencies found</p></div>';
                    return;
                }
                
                let html = '<div class="dependency-list">';
                dependencies.forEach(dep => {
                    const errorRate = dep.count > 0 ? (dep.errors / dep.count * 100).toFixed(1) : 0;
                    const statusClass = errorRate > 10 ? 'danger' : errorRate > 5 ? 'warning' : 'success';
                    
                    html += \`
                        <div class="d-flex align-items-center justify-content-between border-bottom py-2">
                            <div class="flex-grow-1">
                                <strong>\${dep.from}</strong> <i class="fas fa-arrow-right text-muted mx-2"></i> <strong>\${dep.to}</strong>
                                <br><small class="text-muted">\${dep.count} calls ‚Ä¢ \${Math.round(dep.avgDuration)}ms avg</small>
                            </div>
                            <span class="badge bg-\${statusClass}">\${errorRate}% errors</span>
                        </div>
                    \`;
                });
                html += '</div>';
                
                mapDiv.innerHTML = html;
            }
            
            async function searchTraces() {
                const service = document.getElementById('filterService').value;
                const severity = document.getElementById('filterSeverity').value;
                const timeRange = document.getElementById('filterTimeRange').value;
                
                const params = new URLSearchParams();
                if (service) params.append('service', service);
                if (severity) params.append('severity', severity);
                
                // Calculate time range
                const now = new Date();
                let startTime;
                switch (timeRange) {
                    case '1h':
                        startTime = new Date(now - 60 * 60 * 1000);
                        break;
                    case '6h':
                        startTime = new Date(now - 6 * 60 * 60 * 1000);
                        break;
                    case '24h':
                        startTime = new Date(now - 24 * 60 * 60 * 1000);
                        break;
                    case '7d':
                        startTime = new Date(now - 7 * 24 * 60 * 60 * 1000);
                        break;
                }
                
                if (startTime) {
                    params.append('start_time', startTime.toISOString());
                    params.append('end_time', now.toISOString());
                }
                
                try {
                    const response = await fetch('/api/tracing/search?' + params.toString());
                    const data = await response.json();
                    
                    if (data.success) {
                        displayTraceResults(data.traces);
                    }
                } catch (error) {
                    console.error('Failed to search traces:', error);
                    showError('tracingResults', 'Failed to search traces');
                }
            }
            
            function displayTraceResults(traces) {
                const resultsDiv = document.getElementById('tracingResults');
                
                if (traces.length === 0) {
                    resultsDiv.innerHTML = '<div class="text-center text-muted"><p>No traces found for the selected filters</p></div>';
                    return;
                }
                
                let html = '<div class="table-responsive"><table class="table table-hover"><thead><tr>';
                html += '<th>Trace ID</th><th>Duration</th><th>Spans</th><th>Services</th><th>Errors</th><th>Start Time</th>';
                html += '</tr></thead><tbody>';
                
                traces.forEach(trace => {
                    const duration = Math.round(trace.duration);
                    const errorClass = trace.error_count > 0 ? 'text-danger' : '';
                    
                    html += \`
                        <tr style="cursor: pointer;" onclick="viewTraceDetail('\${trace.trace_id}')">
                            <td><code>\${trace.trace_id.substring(0, 16)}...</code></td>
                            <td>\${duration}ms</td>
                            <td>\${trace.spans_count}</td>
                            <td>\${trace.services.join(', ')}</td>
                            <td class="\${errorClass}">\${trace.error_count}</td>
                            <td>\${formatTimestamp(trace.start_time)}</td>
                        </tr>
                    \`;
                });
                
                html += '</tbody></table></div>';
                resultsDiv.innerHTML = html;
            }
            
            async function viewTraceDetail(traceId) {
                try {
                    const response = await fetch('/api/tracing/trace/' + traceId);
                    const data = await response.json();
                    
                    if (data.success) {
                        // Show trace detail modal (would implement a proper modal)
                        alert('Trace Details:\\n' + JSON.stringify(data.trace, null, 2));
                    }
                } catch (error) {
                    console.error('Failed to load trace detail:', error);
                }
            }
            
            function refreshData() {
                loadTracingStatus();
                loadServiceDependencies();
                if (document.getElementById('tracingResults').innerHTML.includes('table')) {
                    searchTraces();
                }
            }
            
            // Load data on page load
            document.addEventListener('DOMContentLoaded', () => {
                loadTracingStatus();
                loadServiceDependencies();
                
                // Refresh every 30 seconds
                setInterval(refreshData, 30000);
            });
        </script>
    `;

    res.send(getPageTemplate({
        pageTitle: 'Distributed Tracing',
        pageIcon: 'fas fa-project-diagram',
        activeNav: 'tracing',
        contentBody: pageContent,
        additionalCSS: '',
        additionalJS: '',
        req: req
    }));
});

// Advanced Dashboard Builder Management Page
app.get('/admin/dashboards', requireAuth, (req, res) => {
    const dashboardCSS = `
        .widget-type-card {
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }
        .stat-card {
            display: flex;
            align-items: center;
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }
        .stat-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
        }
    `;
    
    const dashboardJS = '';
    
    const pageContent = `
        <div class="container-fluid">
            <div class="row">
                <div class="col-md-12">
                    <div class="card">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h3><i class="fas fa-tachometer-alt text-primary"></i> Advanced Dashboard Builder</h3>
                            <button class="btn btn-primary" onclick="createDashboard()">
                                <i class="fas fa-plus"></i> Create Dashboard
                            </button>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <!-- Dashboard List -->
                                <div class="col-md-6">
                                    <h5>My Dashboards</h5>
                                    <div id="dashboardList" class="list-group">
                                        <div class="text-center p-3">
                                            <i class="fas fa-spinner fa-spin"></i> Loading dashboards...
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Widget Types -->
                                <div class="col-md-6">
                                    <h5>Available Widget Types</h5>
                                    <div id="widgetTypes" class="row">
                                        <div class="text-center p-3">
                                            <i class="fas fa-spinner fa-spin"></i> Loading widget types...
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Dashboard Statistics -->
                            <div class="row mt-4">
                                <div class="col-md-12">
                                    <h5>Dashboard Statistics</h5>
                                    <div class="row" id="dashboardStats">
                                        <div class="col-md-3">
                                            <div class="stat-card">
                                                <div class="stat-icon bg-primary">
                                                    <i class="fas fa-tachometer-alt"></i>
                                                </div>
                                                <div class="stat-content">
                                                    <h4 id="totalDashboards">-</h4>
                                                    <p>Total Dashboards</p>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="stat-card">
                                                <div class="stat-icon bg-success">
                                                    <i class="fas fa-puzzle-piece"></i>
                                                </div>
                                                <div class="stat-content">
                                                    <h4 id="totalWidgets">-</h4>
                                                    <p>Total Widgets</p>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="stat-card">
                                                <div class="stat-icon bg-info">
                                                    <i class="fas fa-users"></i>
                                                </div>
                                                <div class="stat-content">
                                                    <h4 id="activeUsers">-</h4>
                                                    <p>Active Users</p>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="col-md-3">
                                            <div class="stat-card">
                                                <div class="stat-icon bg-warning">
                                                    <i class="fas fa-chart-line"></i>
                                                </div>
                                                <div class="stat-content">
                                                    <h4 id="widgetTypes">12</h4>
                                                    <p>Widget Types</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Create Dashboard Modal -->
        <div class="modal fade" id="createDashboardModal" tabindex="-1">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Create New Dashboard</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <form id="createDashboardForm">
                            <div class="mb-3">
                                <label for="dashboardName" class="form-label">Dashboard Name</label>
                                <input type="text" class="form-control" id="dashboardName" required>
                            </div>
                            <div class="mb-3">
                                <label for="dashboardDescription" class="form-label">Description</label>
                                <textarea class="form-control" id="dashboardDescription" rows="3"></textarea>
                            </div>
                            <div class="mb-3">
                                <label for="dashboardTags" class="form-label">Tags (comma-separated)</label>
                                <input type="text" class="form-control" id="dashboardTags" placeholder="monitoring, alerts, metrics">
                            </div>
                            <div class="form-check mb-3">
                                <input class="form-check-input" type="checkbox" id="dashboardPublic">
                                <label class="form-check-label" for="dashboardPublic">
                                    Make dashboard public
                                </label>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" onclick="submitCreateDashboard()">Create Dashboard</button>
                    </div>
                </div>
            </div>
        </div>
    `;

    const additionalCSS = `
        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
        }
        
        .stat-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            color: white;
            font-size: 24px;
        }
        
        .stat-content h4 {
            margin: 0;
            font-size: 28px;
            font-weight: bold;
            color: #333;
        }
        
        .stat-content p {
            margin: 0;
            color: #666;
            font-size: 14px;
        }
        
        .widget-type-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .widget-type-card:hover {
            background: #e9ecef;
            border-color: #007bff;
        }
        
        .widget-type-icon {
            font-size: 24px;
            margin-bottom: 10px;
            color: #007bff;
        }
    `;

    const additionalJS = `
        <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
        <script>
        // jQuery loading helper
        function waitForjQuery(callback) {
            if (typeof $ !== 'undefined' && $.fn) {
                callback();
            } else {
                setTimeout(() => waitForjQuery(callback), 50);
            }
        }

        waitForjQuery(() => {
            $(document).ready(function() {
            loadDashboards();
            loadWidgetTypes();
            loadDashboardStats();
            
            // Refresh data every 30 seconds
            setInterval(() => {
                loadDashboards();
                loadDashboardStats();
            }, 30000);
        });

        function loadDashboards() {
            $.get('/api/dashboards')
                .done(function(response) {
                    if (response.success) {
                        displayDashboards(response.data);
                    }
                })
                .fail(function() {
                    $('#dashboardList').html('<div class="alert alert-danger">Failed to load dashboards</div>');
                });
        }

        function loadWidgetTypes() {
            $.get('/api/dashboards/widget-types')
                .done(function(response) {
                    if (response.success) {
                        displayWidgetTypes(response.data);
                    }
                })
                .fail(function() {
                    $('#widgetTypes').html('<div class="alert alert-danger">Failed to load widget types</div>');
                });
        }

        function loadDashboardStats() {
            // This would normally come from an API endpoint
            $('#totalDashboards').text('Loading...');
            $('#totalWidgets').text('Loading...');
            $('#activeUsers').text('Loading...');
        }

        function displayDashboards(dashboards) {
            let html = '';
            
            if (dashboards.length === 0) {
                html = '<div class="alert alert-info">No dashboards created yet</div>';
            } else {
                dashboards.forEach(dashboard => {
                    const isPublic = dashboard.is_public ? '<i class="fas fa-globe text-success" title="Public"></i>' : '<i class="fas fa-lock text-muted" title="Private"></i>';
                    html += '<div class="list-group-item">' + dashboard.name + ' - ' + (dashboard.description || 'No description') + '</div>';
                });
            }
            
            $('#dashboardList').html(html);
        }

        function displayWidgetTypes(types) {
            let html = '';
            
            const categories = {};
            types.forEach(type => {
                if (!categories[type.category]) {
                    categories[type.category] = [];
                }
                categories[type.category].push(type);
            });
            
            Object.keys(categories).forEach(category => {
                html += '<div class="col-12"><h6 class="text-muted text-uppercase">' + category + '</h6></div>';
                categories[category].forEach(type => {
                    html += '<div class="col-md-6 widget-type-card">' + type.name + ' (' + type.id + ')</div>';
                });
            });
            
            $('#widgetTypes').html(html);
        }

        function createDashboard() {
            $('#createDashboardModal').modal('show');
        }

        function submitCreateDashboard() {
            const formData = {
                name: $('#dashboardName').val(),
                description: $('#dashboardDescription').val(),
                tags: $('#dashboardTags').val().split(',').map(tag => tag.trim()).filter(tag => tag),
                isPublic: $('#dashboardPublic').is(':checked')
            };

            $.ajax({
                url: '/api/dashboards',
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: JSON.stringify(formData)
            })
            .done(function(response) {
                if (response.success) {
                    $('#createDashboardModal').modal('hide');
                    $('#createDashboardForm')[0].reset();
                    loadDashboards();
                    toastr.success('Dashboard created successfully');
                }
            })
            .fail(function() {
                toastr.error('Failed to create dashboard');
            });
        }

        function editDashboard(dashboardId) {
            window.location.href = '/dashboard/' + dashboardId;
        }

        function deleteDashboard(dashboardId) {
            if (confirm('Are you sure you want to delete this dashboard?')) {
                // Would implement delete API call
                toastr.info('Delete functionality would be implemented here');
            }
        }
        });
        </script>
    `;

    res.send(getPageTemplate({
        pageTitle: 'Dashboard Builder',
        pageIcon: 'fas fa-tachometer-alt',
        activeNav: 'dashboards',
        contentBody: pageContent,
        additionalCSS: dashboardCSS,
        additionalJS: dashboardJS,
        req: req
    }));
});

// Log parsing and enrichment API
app.post('/api/logs/parse', requireAuth, (req, res) => {
    const { message, format = 'auto' } = req.body;
    
    if (!message) {
        return res.status(400).json({ error: 'Message is required' });
    }
    
    try {
        const parsed = parseLogMessage(message, format);
        res.json({
            success: true,
            parsed: parsed,
            available_formats: Object.keys(logParsers)
        });
    } catch (error) {
        res.status(500).json({ 
            error: 'Parsing failed', 
            details: error.message 
        });
    }
});

// WebSocket connection info API
app.get('/api/websocket/clients', requireAuth, (req, res) => {
    if (integrationManager && integrationManager.connectedClients) {
        const clients = Array.from(integrationManager.connectedClients).map(client => ({
            id: client.id || 'legacy',
            connectedAt: client.connectedAt || null,
            filters: client.filters || null,
            hasFilters: !!(client.filters && (
                client.filters.sources.length > 0 ||
                client.filters.severities.length > 0 ||
                client.filters.categories.length > 0
            ))
        }));
        
        res.json({
            success: true,
            clients: clients,
            count: clients.length
        });
    } else {
        res.json({ success: true, clients: [], count: 0 });
    }
});

// System health and metrics API
app.get('/api/system/health', requireAuth, (req, res) => {
    const uptime = process.uptime();
    const memory = process.memoryUsage();
    
    res.json({
        success: true,
        system: {
            uptime_seconds: Math.floor(uptime),
            uptime_formatted: `${Math.floor(uptime / 3600)}h ${Math.floor((uptime % 3600) / 60)}m`,
            memory_usage: {
                heap_used_mb: Math.round(memory.heapUsed / 1024 / 1024),
                heap_total_mb: Math.round(memory.heapTotal / 1024 / 1024),
                external_mb: Math.round(memory.external / 1024 / 1024),
                rss_mb: Math.round(memory.rss / 1024 / 1024)
            },
            integrations: integrationManager ? integrationManager.getStatus() : {},
            features: {
                rate_limiting: true,
                bulk_operations: true,
                log_parsing: true,
                real_time_alerts: !!alertingEngine,
                websocket_streaming: !!(integrationManager && integrationManager.wsServer),
                geo_enrichment: true
            }
        }
    });
});

// Rate limiting status API
app.get('/api/system/rate-limits', requireAuth, (req, res) => {
    res.json({
        success: true,
        limits: {
            general: {
                window_ms: 15 * 60 * 1000,
                max_requests: 100,
                description: 'General API rate limiting'
            },
            log_ingestion: {
                window_ms: 5 * 60 * 1000,
                max_requests: 1000,
                description: 'Log ingestion rate limiting'
            },
            authentication: {
                window_ms: 15 * 60 * 1000,
                max_requests: 5,
                description: 'Authentication attempt limiting'
            }
        }
    });
});

// Log format templates API
app.get('/api/logs/formats', requireAuth, (req, res) => {
    const formats = Object.keys(logParsers).map(name => ({
        name,
        description: getFormatDescription(name),
        fields: logParsers[name].fields || [],
        sample: getFormatSample(name)
    }));
    
    res.json({
        success: true,
        formats: formats,
        count: formats.length
    });
});

function getFormatDescription(format) {
    const descriptions = {
        nginx: 'Nginx combined log format (Common Log Format + referer + user agent)',
        apache: 'Apache Common Log Format',
        docker: 'Docker container log format with timestamp and level',
        syslog: 'RFC3164 Syslog format with priority and hostname',
        json: 'JSON structured logs (auto-detected)'
    };
    return descriptions[format] || 'Unknown format';
}

function getFormatSample(format) {
    const samples = {
        nginx: '192.168.1.100 - - [25/Dec/2023:10:00:00 +0000] "GET /api/logs HTTP/1.1" 200 1234 "https://example.com" "Mozilla/5.0"',
        apache: '192.168.1.100 - - [25/Dec/2023:10:00:00 +0000] "GET /logs HTTP/1.1" 200 1234',
        docker: '2023-12-25T10:00:00.123456789Z INFO Application started successfully',
        syslog: '<34>Dec 25 10:00:00 myhost myapp[1234]: Application started',
        json: '{"timestamp":"2023-12-25T10:00:00Z","level":"info","message":"Application started","service":"api"}'
    };
    return samples[format] || '';
}

// Get total log count
app.get('/api/logs/count', requireAuth, (req, res) => {
    db.get('SELECT COUNT(*) as count FROM log_events', (err, row) => {
        if (err) {
            loggers.system.error('Count query error:', err);
            return res.status(500).json({ error: 'Database query failed' });
        }
        res.json({ count: row.count });
    });
});

// Get today's log count (since midnight local time)
app.get('/api/logs/count/today', requireAuth, (req, res) => {
    // Get midnight in local timezone (America/New_York) in database format
    const now = moment().tz(TIMEZONE);
    const midnight = now.clone().startOf('day');
    const midnightFormatted = midnight.format('YYYY-MM-DD HH:mm:ss');
    
    db.get('SELECT COUNT(*) as count FROM log_events WHERE timestamp >= ?', [midnightFormatted], (err, row) => {
        if (err) {
            loggers.system.error('Today count query error:', err);
            return res.status(500).json({ error: 'Database query failed' });
        }
        res.json({ count: row.count });
    });
});

// Analytics activity data for charts
app.get('/api/analytics/activity', requireAuth, (req, res) => {
    const range = req.query.range || '24h';
    let intervalMinutes, hoursBack, groupFormat;
    
    switch(range) {
        case '1h':
            intervalMinutes = 5;
            hoursBack = 1;
            groupFormat = '%H:%M';
            break;
        case '6h':
            intervalMinutes = 30;
            hoursBack = 6;
            groupFormat = '%H:%M';
            break;
        case '24h':
            intervalMinutes = 60;
            hoursBack = 24;
            groupFormat = '%H:00';
            break;
        case '7d':
            intervalMinutes = 60 * 6; // 6 hours
            hoursBack = 24 * 7;
            groupFormat = '%m/%d %H:00';
            break;
        default:
            intervalMinutes = 60;
            hoursBack = 24;
            groupFormat = '%H:00';
    }
    
    const startTime = moment().tz(TIMEZONE).subtract(hoursBack, 'hours');
    const startTimeFormatted = startTime.format('YYYY-MM-DD HH:mm:ss');
    
    const query = `
        SELECT 
            strftime('${groupFormat}', timestamp) as time_bucket,
            COUNT(*) as count
        FROM log_events
        WHERE timestamp >= ?
        GROUP BY time_bucket
        ORDER BY timestamp ASC
    `;
    
    db.all(query, [startTimeFormatted], (err, rows) => {
        if (err) {
            loggers.system.error('Analytics query error:', err);
            return res.status(500).json({ error: 'Database query failed' });
        }
        
        // Fill in missing time slots with 0 counts
        const labels = [];
        const values = [];
        const dataMap = {};
        
        // Create map of existing data
        rows.forEach(row => {
            dataMap[row.time_bucket] = row.count;
        });
        
        // Generate all time slots
        const numSlots = Math.ceil((hoursBack * 60) / intervalMinutes);
        for (let i = 0; i < numSlots; i++) {
            const slotTime = startTime.clone().add(i * intervalMinutes, 'minutes');
            const label = slotTime.format(groupFormat === '%H:%M' ? 'HH:mm' : 'MM/DD HH:00');
            const bucketKey = slotTime.format(groupFormat.replace('%H', 'HH').replace('%M', 'mm').replace('%m', 'MM').replace('%d', 'DD'));
            
            labels.push(label);
            values.push(dataMap[bucketKey] || 0);
        }
        
        res.json({ labels, values });
    });
});

// System status API
app.get('/api/status', requireAuth, (req, res) => {
    const status = {
        server: {
            uptime: process.uptime(),
            memory: process.memoryUsage(),
            version: config.system.version,
            timezone: TIMEZONE,
            timestamp: moment().tz(TIMEZONE).toISOString()
        },
        database: {
            path: dbPath,
            connected: true
        },
        integrations: {
            dsc: { status: 'ready', endpoint: '/log' },
            unifi: { status: 'setup_required' },
            homeAssistant: { status: 'setup_required' },
            mqtt: { status: 'setup_required' }
        }
    };
    
    res.json(status);
});

// Analytics stats API - Returns aggregated statistics  
app.get('/api/analytics/stats', requireAuth, (req, res) => {
    const range = req.query.range || '7days';
    let hours;
    switch(range) {
        case 'today': hours = 24; break;
        case 'yesterday': hours = 24; break;
        case '7days': hours = 24 * 7; break;
        case '30days': hours = 24 * 30; break;
        default: hours = 24 * 7;
    }
    
    const startTime = moment().tz(TIMEZONE).subtract(hours, 'hours').format('YYYY-MM-DD HH:mm:ss');
    
    const statsQuery = `
        SELECT 
            COUNT(*) as total,
            SUM(CASE WHEN severity IN ('error', 'warn', 'warning', 'critical') THEN 1 ELSE 0 END) as errors
        FROM log_events
        WHERE timestamp >= ?
    `;
    
    const peakQuery = `
        SELECT strftime('%H', timestamp) as hour, COUNT(*) as count
        FROM log_events
        WHERE timestamp >= ?
        GROUP BY hour
        ORDER BY count DESC
        LIMIT 1
    `;
    
    db.get(statsQuery, [startTime], (err, stats) => {
        if (err) {
            loggers.system.error('Analytics stats query error:', err);
            return res.status(500).json({ error: 'Database query failed' });
        }
        
        db.get(peakQuery, [startTime], (err2, peak) => {
            if (err2) {
                loggers.system.error('Analytics peak query error:', err2);
                return res.status(500).json({ error: 'Database query failed' });
            }
            
            const total = stats.total || 0;
            const errors = stats.errors || 0;
            const avgPerHour = Math.round(total / hours);
            const errorRate = total > 0 ? ((errors / total) * 100).toFixed(1) : 0;
            
            res.json({
                total,
                errors,
                error_rate: errorRate,
                avg_per_hour: avgPerHour,
                peak_hour: peak ? parseInt(peak.hour) : 0,
                peak_count: peak ? peak.count : 0
            });
        });
    });
});

// Analytics top sources API - Returns top 10 sources by log count
app.get('/api/analytics/top-sources', requireAuth, (req, res) => {
    const range = req.query.range || '7days';
    let hours;
    switch(range) {
        case 'today': hours = 24; break;
        case 'yesterday': hours = 24; break;
        case '7days': hours = 24 * 7; break;
        case '30days': hours = 24 * 30; break;
        default: hours = 24 * 7;
    }
    
    const startTime = moment().tz(TIMEZONE).subtract(hours, 'hours').format('YYYY-MM-DD HH:mm:ss');
    
    const query = `
        SELECT source, COUNT(*) as count
        FROM log_events
        WHERE timestamp >= ?
        GROUP BY source
        ORDER BY count DESC
        LIMIT 10
    `;
    
    db.all(query, [startTime], (err, rows) => {
        if (err) {
            loggers.system.error('Analytics top sources query error:', err);
            return res.status(500).json({ error: 'Database query failed' });
        }
        
        res.json(rows || []);
    });
});

// Analytics category distribution API
app.get('/api/analytics/categories', requireAuth, (req, res) => {
    const range = req.query.range || '7days';
    let hours;
    switch(range) {
        case 'today': hours = 24; break;
        case 'yesterday': hours = 24; break;
        case '7days': hours = 24 * 7; break;
        case '30days': hours = 24 * 30; break;
        default: hours = 24 * 7;
    }
    
    const startTime = moment().tz(TIMEZONE).subtract(hours, 'hours').format('YYYY-MM-DD HH:mm:ss');
    
    const query = `
        SELECT category, COUNT(*) as count
        FROM log_events
        WHERE timestamp >= ?
        GROUP BY category
        ORDER BY count DESC
    `;
    
    db.all(query, [startTime], (err, rows) => {
        if (err) {
            loggers.system.error('Analytics categories query error:', err);
            return res.status(500).json({ error: 'Database query failed' });
        }
        
        res.json(rows || []);
    });
});

// Analytics severity distribution API
app.get('/api/analytics/severities', requireAuth, (req, res) => {
    const range = req.query.range || '7days';
    let hours;
    switch(range) {
        case 'today': hours = 24; break;
        case 'yesterday': hours = 24; break;
        case '7days': hours = 24 * 7; break;
        case '30days': hours = 24 * 30; break;
        default: hours = 24 * 7;
    }
    
    const startTime = moment().tz(TIMEZONE).subtract(hours, 'hours').format('YYYY-MM-DD HH:mm:ss');
    
    const query = `
        SELECT severity, COUNT(*) as count
        FROM log_events
        WHERE timestamp >= ?
        GROUP BY severity
        ORDER BY count DESC
    `;
    
    db.all(query, [startTime], (err, rows) => {
        if (err) {
            loggers.system.error('Analytics severities query error:', err);
            return res.status(500).json({ error: 'Database query failed' });
        }
        
        res.json(rows || []);
    });
});

// ========================================
// ADVANCED ANALYTICS - HISTOGRAMS & HEATMAPS
// ========================================

/**
 * Hourly Histogram: Count events by hour of day (0-23)
 * GET /api/analytics/histogram/hourly?range=7days&category=garage_door&severity=error
 */
app.get('/api/analytics/histogram/hourly', requireAuth, (req, res) => {
    const range = req.query.range || '7days';
    const category = req.query.category || null;
    const source = req.query.source || null;
    const severity = req.query.severity || null;
    
    // Calculate time range
    let hours;
    switch(range) {
        case 'today': hours = 24; break;
        case '7days': hours = 24 * 7; break;
        case '30days': hours = 24 * 30; break;
        default: hours = 24 * 7;
    }
    
    const startTime = moment().tz(TIMEZONE).subtract(hours, 'hours').format('YYYY-MM-DD HH:mm:ss');
    
    // Build query with optional filters
    let query = `
        SELECT 
            CAST(strftime('%H', timestamp) AS INTEGER) as hour,
            COUNT(*) as count
        FROM log_events
        WHERE timestamp >= ?
    `;
    
    const params = [startTime];
    
    if (category) {
        query += ' AND category = ?';
        params.push(category);
    }
    
    if (source) {
        query += ' AND source = ?';
        params.push(source);
    }
    
    if (severity) {
        query += ' AND severity = ?';
        params.push(severity);
    }
    
    query += ' GROUP BY hour ORDER BY hour';
    
    db.all(query, params, (err, rows) => {
        if (err) {
            loggers.system.error('Hourly histogram error:', err);
            return res.status(500).json({ error: 'Database query failed' });
        }
        
        // Fill in missing hours with 0 counts
        const hourlyData = Array.from({ length: 24 }, (_, i) => ({
            hour: i,
            count: 0,
            label: `${String(i).padStart(2, '0')}:00`
        }));
        
        rows.forEach(row => {
            if (row.hour >= 0 && row.hour < 24) {
                hourlyData[row.hour].count = row.count;
            }
        });
        
        // Calculate statistics
        const counts = hourlyData.map(d => d.count);
        const total = counts.reduce((sum, c) => sum + c, 0);
        const max = Math.max(...counts);
        const min = Math.min(...counts);
        const avg = total / 24;
        const peakHour = hourlyData.find(d => d.count === max);
        
        res.json({
            labels: hourlyData.map(d => d.label),
            values: hourlyData.map(d => d.count),
            data: hourlyData,
            stats: {
                total,
                avg: Math.round(avg),
                max,
                min,
                peak_hour: peakHour.hour,
                peak_label: peakHour.label,
                peak_count: peakHour.count
            }
        });
    });
});

/**
 * Daily Histogram: Count events by day of week (0=Sun, 6=Sat)
 * GET /api/analytics/histogram/daily?range=30days
 */
app.get('/api/analytics/histogram/daily', requireAuth, (req, res) => {
    const range = req.query.range || '30days';
    
    let days;
    switch(range) {
        case '7days': days = 7; break;
        case '30days': days = 30; break;
        case '90days': days = 90; break;
        default: days = 30;
    }
    
    const startTime = moment().tz(TIMEZONE).subtract(days, 'days').format('YYYY-MM-DD HH:mm:ss');
    
    const query = `
        SELECT 
            CAST(strftime('%w', timestamp) AS INTEGER) as day_of_week,
            COUNT(*) as count
        FROM log_events
        WHERE timestamp >= ?
        GROUP BY day_of_week
        ORDER BY day_of_week
    `;
    
    db.all(query, [startTime], (err, rows) => {
        if (err) {
            loggers.system.error('Daily histogram error:', err);
            return res.status(500).json({ error: 'Database query failed' });
        }
        
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const dailyData = Array.from({ length: 7 }, (_, i) => ({
            day: i,
            name: dayNames[i],
            short: dayNames[i].substring(0, 3),
            count: 0
        }));
        
        rows.forEach(row => {
            if (row.day_of_week >= 0 && row.day_of_week < 7) {
                dailyData[row.day_of_week].count = row.count;
            }
        });
        
        // Calculate statistics
        const counts = dailyData.map(d => d.count);
        const total = counts.reduce((sum, c) => sum + c, 0);
        const avg = total / 7;
        const max = Math.max(...counts);
        const peakDay = dailyData.find(d => d.count === max);
        
        res.json({
            labels: dailyData.map(d => d.name),
            short_labels: dailyData.map(d => d.short),
            values: dailyData.map(d => d.count),
            data: dailyData,
            stats: {
                total,
                avg: Math.round(avg),
                peak_day: peakDay.name,
                peak_count: peakDay.count
            }
        });
    });
});

/**
 * Message Frequency Histogram: Top N most common messages
 * GET /api/analytics/histogram/messages?range=7days&limit=20
 */
app.get('/api/analytics/histogram/messages', requireAuth, (req, res) => {
    const range = req.query.range || '7days';
    const limit = parseInt(req.query.limit) || 20;
    
    let hours;
    switch(range) {
        case 'today': hours = 24; break;
        case '7days': hours = 24 * 7; break;
        case '30days': hours = 24 * 30; break;
        default: hours = 24 * 7;
    }
    
    const startTime = moment().tz(TIMEZONE).subtract(hours, 'hours').format('YYYY-MM-DD HH:mm:ss');
    
    const query = `
        SELECT 
            message,
            COUNT(*) as count,
            severity,
            category,
            source
        FROM log_events
        WHERE timestamp >= ?
        GROUP BY message
        ORDER BY count DESC
        LIMIT ?
    `;
    
    db.all(query, [startTime, limit], (err, rows) => {
        if (err) {
            loggers.system.error('Message histogram error:', err);
            return res.status(500).json({ error: 'Database query failed' });
        }
        
        if (!rows || rows.length === 0) {
            return res.json({
                labels: [],
                values: [],
                messages: [],
                stats: { total: 0, unique_messages: 0 }
            });
        }
        
        // Truncate long messages for labels
        const messages = rows.map(r => ({
            message: r.message,
            message_short: r.message && r.message.length > 60 ? r.message.substring(0, 57) + '...' : r.message,
            count: r.count,
            severity: r.severity,
            category: r.category,
            source: r.source
        }));
        
        const total = rows.reduce((sum, r) => sum + r.count, 0);
        
        res.json({
            labels: messages.map(m => m.message_short),
            values: messages.map(m => m.count),
            messages: messages,
            stats: {
                total,
                unique_messages: rows.length,
                top_message: messages[0].message,
                top_count: messages[0].count,
                top_percentage: ((messages[0].count / total) * 100).toFixed(1)
            }
        });
    });
});

/**
 * Time √ó Severity Heatmap: 2D grid (24 hours √ó severities)
 * GET /api/analytics/heatmap/severity-time?range=7days
 */
app.get('/api/analytics/heatmap/severity-time', requireAuth, (req, res) => {
    const range = req.query.range || '7days';
    
    let hours;
    switch(range) {
        case 'today': hours = 24; break;
        case '7days': hours = 24 * 7; break;
        case '30days': hours = 24 * 30; break;
        default: hours = 24 * 7;
    }
    
    const startTime = moment().tz(TIMEZONE).subtract(hours, 'hours').format('YYYY-MM-DD HH:mm:ss');
    
    const query = `
        SELECT 
            CAST(strftime('%H', timestamp) AS INTEGER) as hour,
            severity,
            COUNT(*) as count
        FROM log_events
        WHERE timestamp >= ?
        GROUP BY hour, severity
        ORDER BY hour, severity
    `;
    
    db.all(query, [startTime], (err, rows) => {
        if (err) {
            loggers.system.error('Heatmap error:', err);
            return res.status(500).json({ error: 'Database query failed' });
        }
        
        // Create 2D matrix: hours (rows) √ó severities (columns)
        const severities = ['debug', 'info', 'warn', 'error', 'critical'];
        const matrix = [];
        
        // Initialize matrix with zeros
        for (let hour = 0; hour < 24; hour++) {
            const row = {
                hour: hour,
                label: `${String(hour).padStart(2, '0')}:00`,
                severities: {}
            };
            
            severities.forEach(sev => {
                row.severities[sev] = 0;
            });
            
            matrix.push(row);
        }
        
        // Fill in actual counts
        rows.forEach(row => {
            if (row.hour >= 0 && row.hour < 24 && severities.includes(row.severity)) {
                matrix[row.hour].severities[row.severity] = row.count;
            }
        });
        
        // Calculate max for color scaling
        let maxCount = 0;
        matrix.forEach(row => {
            Object.values(row.severities).forEach(count => {
                if (count > maxCount) maxCount = count;
            });
        });
        
        // Convert to Chart.js matrix format
        const chartData = [];
        matrix.forEach(row => {
            severities.forEach(sev => {
                chartData.push({
                    x: row.label,
                    y: sev.toUpperCase(),
                    v: row.severities[sev],
                    hour: row.hour,
                    severity: sev
                });
            });
        });
        
        res.json({
            matrix: matrix,
            severities: severities.map(s => s.toUpperCase()),
            hours: matrix.map(m => m.label),
            chart_data: chartData,
            max_count: maxCount
        });
    });
});

/**
 * Anomaly Detection: Find statistical anomalies
 * GET /api/analytics/anomalies?range=7days&threshold=2
 */
app.get('/api/analytics/anomalies', requireAuth, (req, res) => {
    const range = req.query.range || '7days';
    const threshold = parseFloat(req.query.threshold) || 2.0; // Standard deviations
    
    let hours;
    switch(range) {
        case 'today': hours = 24; break;
        case '7days': hours = 24 * 7; break;
        case '30days': hours = 24 * 30; break;
        default: hours = 24 * 7;
    }
    
    const startTime = moment().tz(TIMEZONE).subtract(hours, 'hours').format('YYYY-MM-DD HH:mm:ss');
    
    // Get hourly counts
    const query = `
        SELECT 
            strftime('%Y-%m-%d %H:00:00', timestamp) as hour_bucket,
            COUNT(*) as count,
            SUM(CASE WHEN severity IN ('error', 'warn', 'critical') THEN 1 ELSE 0 END) as error_count
        FROM log_events
        WHERE timestamp >= ?
        GROUP BY hour_bucket
        ORDER BY hour_bucket
    `;
    
    db.all(query, [startTime], (err, rows) => {
        if (err) {
            loggers.system.error('Anomaly detection error:', err);
            return res.status(500).json({ error: 'Database query failed' });
        }
        
        if (rows.length < 3) {
            return res.json({ 
                anomalies: [], 
                stats: { mean: 0, std_dev: 0, threshold: 0, threshold_sigma: threshold },
                message: 'Not enough data for anomaly detection' 
            });
        }
        
        // Calculate mean and standard deviation
        const counts = rows.map(r => r.count);
        const mean = counts.reduce((sum, c) => sum + c, 0) / counts.length;
        const variance = counts.reduce((sum, c) => sum + Math.pow(c - mean, 2), 0) / counts.length;
        const stdDev = Math.sqrt(variance);
        
        const anomalyThreshold = mean + (threshold * stdDev);
        
        // Find anomalies
        const anomalies = rows
            .filter(row => row.count > anomalyThreshold)
            .map(row => {
                const deviation = ((row.count - mean) / mean * 100).toFixed(1);
                const sigma = ((row.count - mean) / stdDev).toFixed(1);
                
                return {
                    timestamp: row.hour_bucket,
                    timestamp_formatted: formatSQLiteTimestamp(row.hour_bucket),
                    count: row.count,
                    error_count: row.error_count,
                    normal_count: Math.round(mean),
                    deviation_percent: deviation,
                    sigma: sigma,
                    severity: sigma > 3 ? 'critical' : 'warning'
                };
            });
        
        res.json({
            anomalies: anomalies,
            stats: {
                mean: Math.round(mean),
                std_dev: Math.round(stdDev),
                threshold: Math.round(anomalyThreshold),
                threshold_sigma: threshold
            },
            message: anomalies.length > 0 
                ? `Found ${anomalies.length} anomal${anomalies.length === 1 ? 'y' : 'ies'}`
                : 'No anomalies detected'
        });
    });
});

// ========================================
// DASHBOARD WIDGETS API
// ========================================

// Get user's widgets
app.get('/api/dashboard/widgets', requireAuth, (req, res) => {
    const userId = req.user.id;
    
    db.all(
        `SELECT * FROM dashboard_widgets 
         ORDER BY position_y, position_x`,
        [],
        (err, rows) => {
            if (err) {
                loggers.system.error('Error fetching widgets:', err);
                return res.status(500).json({ error: 'Failed to fetch widgets' });
            }
            
            // Parse config JSON
            const widgets = rows.map(row => ({
                ...row,
                config: row.config ? JSON.parse(row.config) : {}
            }));
            
            console.log(`üìä Returning ${widgets.length} widgets for user ${userId}`);
            res.json({ widgets });
        }
    );
});

// Create new widget
app.post('/api/dashboard/widgets', requireAuth, (req, res) => {
    const { widget_type, title, position_x, position_y, width, height, config } = req.body;
    const userId = req.user.id;
    
    console.log('üìä Widget creation request:', { widget_type, title, userId, body: req.body });
    
    if (!widget_type || !title) {
        console.log('‚ùå Missing required fields:', { widget_type, title });
        return res.status(400).json({ error: 'Widget type and title are required' });
    }
    
    db.run(
        `INSERT INTO dashboard_widgets 
         (user_id, widget_type, title, position_x, position_y, width, height, config) 
         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
        [userId, widget_type, title, position_x || 0, position_y || 0, width || 4, height || 3, JSON.stringify(config || {})],
        function(err) {
            if (err) {
                console.error('‚ùå Database error creating widget:', err);
                loggers.system.error('Error creating widget:', err);
                return res.status(500).json({ error: 'Failed to create widget' });
            }
            
            console.log('‚úÖ Widget created successfully:', { id: this.lastID, widget_type, title });
            res.json({ success: true, id: this.lastID, message: 'Widget created successfully' });
        }
    );
});

// Update widget
app.put('/api/dashboard/widgets/:id', requireAuth, (req, res) => {
    const widgetId = req.params.id;
    const userId = req.user.id;
    const { title, position_x, position_y, width, height, config, is_visible } = req.body;
    
    db.run(
        `UPDATE dashboard_widgets 
         SET title = COALESCE(?, title),
             position_x = COALESCE(?, position_x),
             position_y = COALESCE(?, position_y),
             width = COALESCE(?, width),
             height = COALESCE(?, height),
             config = COALESCE(?, config),
             is_visible = COALESCE(?, is_visible),
             updated_at = CURRENT_TIMESTAMP
         WHERE id = ? AND user_id = ?`,
        [title, position_x, position_y, width, height, config ? JSON.stringify(config) : null, is_visible, widgetId, userId],
        function(err) {
            if (err) {
                loggers.system.error('Error updating widget:', err);
                return res.status(500).json({ error: 'Failed to update widget' });
            }
            
            if (this.changes === 0) {
                return res.status(404).json({ error: 'Widget not found or access denied' });
            }
            
            res.json({ message: 'Widget updated successfully' });
        }
    );
});

// Bulk update widget positions (for drag-and-drop)
app.post('/api/dashboard/widgets/positions', requireAuth, (req, res) => {
    const { widgets } = req.body; // Array of {id, position_x, position_y, width, height}
    const userId = req.user.id;
    
    if (!widgets || !Array.isArray(widgets)) {
        return res.status(400).json({ error: 'Widgets array is required' });
    }
    
    // Update each widget position
    let completed = 0;
    let errors = 0;
    
    widgets.forEach(widget => {
        db.run(
            `UPDATE dashboard_widgets 
             SET position_x = ?, position_y = ?, width = ?, height = ?, updated_at = CURRENT_TIMESTAMP 
             WHERE id = ? AND user_id = ?`,
            [widget.position_x, widget.position_y, widget.width, widget.height, widget.id, userId],
            (err) => {
                if (err) {
                    errors++;
                    loggers.system.error(`Error updating widget ${widget.id}:`, err);
                }
                
                completed++;
                if (completed === widgets.length) {
                    if (errors > 0) {
                        res.status(500).json({ 
                            error: `Failed to update ${errors} widget(s)`,
                            updated: completed - errors
                        });
                    } else {
                        res.json({ message: 'Widget positions updated successfully', updated: completed });
                    }
                }
            }
        );
    });
});

// Delete widget
app.delete('/api/dashboard/widgets/:id', requireAuth, (req, res) => {
    const widgetId = req.params.id;
    const userId = req.user.id;
    
    db.run(
        'DELETE FROM dashboard_widgets WHERE id = ? AND user_id = ?',
        [widgetId, userId],
        function(err) {
            if (err) {
                loggers.system.error('Error deleting widget:', err);
                return res.status(500).json({ error: 'Failed to delete widget' });
            }
            
            if (this.changes === 0) {
                return res.status(404).json({ error: 'Widget not found or access denied' });
            }
            
            res.json({ success: true, message: 'Widget deleted successfully' });
        }
    );
});

// Fix widget titles (update generic "Widget" titles to proper names)
app.post('/api/dashboard/widgets/fix-titles', requireAuth, (req, res) => {
    const userId = req.user.id;
    
    const properTitles = {
        log_count: 'Total Logs',
        today_count: "Today's Logs",
        severity_breakdown: 'Severity Breakdown',
        log_level_distribution: 'Log Level Distribution',
        recent_logs: 'Recent Logs',
        system_health: 'System Health',
        system_health_detailed: 'Detailed System Health',
        source_stats: 'Top Sources',
        hourly_trend: 'Hourly Trend',
        error_rate: 'Error Rate',
        api_keys_count: 'Active API Keys',
        uptime_monitor: 'Uptime Monitor',
        quick_stats: 'Quick Stats',
        top_errors: 'Top Errors'
    };
    
    db.all(
        'SELECT id, widget_type, title FROM dashboard_widgets WHERE user_id = ?',
        [userId],
        (err, widgets) => {
            if (err) {
                return res.status(500).json({ error: 'Failed to fetch widgets' });
            }
            
            let fixed = 0;
            let completed = 0;
            const widgetsToFix = widgets.filter(w => w.title === 'Widget' || !w.title);
            
            if (widgetsToFix.length === 0) {
                return res.json({ success: true, message: 'All widgets have proper titles', fixed: 0 });
            }
            
            widgetsToFix.forEach(widget => {
                const properTitle = properTitles[widget.widget_type] || 'Widget';
                
                db.run('UPDATE dashboard_widgets SET title = ? WHERE id = ?', [properTitle, widget.id], (err) => {
                    if (!err) fixed++;
                    completed++;
                    
                    if (completed === widgetsToFix.length) {
                        res.json({ success: true, message: `Fixed ${fixed} widget title(s)`, fixed: fixed });
                    }
                });
            });
        }
    );
});

// Fix corrupted widget sizes (one-time fix for coordinate migration)
app.post('/api/dashboard/widgets/fix-sizes', requireAuth, (req, res) => {
    const userId = req.user.id;
    
    loggers.system.info('Fix-sizes called for user ' + userId);
    
    // Get all user's widgets
    db.all(
        'SELECT id, widget_type, width, height FROM dashboard_widgets WHERE user_id = ?',
        [userId],
        (err, widgets) => {
            if (err) {
                loggers.system.error('Error fetching widgets for fix:', err);
                return res.status(500).json({ error: 'Failed to fetch widgets' });
            }
            
            loggers.system.info('Found ' + widgets.length + ' widgets to check');
            
            let fixed = 0;
            let completed = 0;
            const corruptedWidgets = widgets.filter(w => w.width > 20 || w.height > 20 || w.width === 0 || w.height === 0);
            
            if (corruptedWidgets.length === 0) {
                loggers.system.info('No corrupted widgets found');
                return res.json({ success: true, message: 'No corrupted widgets found', fixed: 0 });
            }
            
            loggers.system.info('Fixing ' + corruptedWidgets.length + ' corrupted widgets');
            
            corruptedWidgets.forEach(widget => {
                let w, h;
                
                // Set reasonable defaults based on type
                if (widget.widget_type === 'recent_logs' || widget.widget_type === 'top_errors') {
                    w = 6; h = 10;
                } else if (widget.widget_type.includes('breakdown') || widget.widget_type.includes('trend') || widget.widget_type.includes('rate') || widget.widget_type === 'source_stats') {
                    w = 4; h = 8;
                } else if (widget.widget_type === 'quick_stats' || widget.widget_type === 'system_health_detailed') {
                    w = 4; h = 6;
                } else {
                    w = 3; h = 4;
                }
                
                loggers.system.info('Fixing widget ' + widget.id + ': ' + widget.width + 'x' + widget.height + ' -> ' + w + 'x' + h);
                
                db.run('UPDATE dashboard_widgets SET width = ?, height = ? WHERE id = ?', [w, h, widget.id], (err) => {
                    if (err) {
                        loggers.system.error('Error updating widget ' + widget.id + ':', err);
                    } else {
                        fixed++;
                    }
                    
                    completed++;
                    if (completed === corruptedWidgets.length) {
                        loggers.system.info('Fixed ' + fixed + ' widgets');
                        res.json({ success: true, message: 'Fixed ' + fixed + ' corrupted widget(s)', fixed: fixed });
                    }
                });
            });
        }
    );
});

// Reset widget positions to defaults (fix for coordinate issues)
app.post('/api/dashboard/widgets/reset-positions', requireAuth, (req, res) => {
    const userId = req.user.id;
    
    loggers.system.info('Resetting widget positions for user ' + userId);
    
    // Get all user's widgets
    db.all(
        'SELECT id, widget_type FROM dashboard_widgets WHERE user_id = ? ORDER BY id',
        [userId],
        (err, widgets) => {
            if (err) {
                loggers.system.error('Error fetching widgets:', err);
                return res.status(500).json({ error: 'Failed to fetch widgets' });
            }
            
            loggers.system.info('Found ' + widgets.length + ' widgets to reset');
            
            // Assign new positions in a grid layout
            let x = 0, y = 0;
            let completed = 0;
            
            widgets.forEach((widget, index) => {
                // Default sizes for 12-column grid (40px cells)
                let w, h;
                
                if (widget.widget_type.includes('breakdown') || widget.widget_type.includes('chart') || widget.widget_type === 'source_stats') {
                    w = 4; h = 8;  // Charts
                } else if (widget.widget_type === 'recent_logs' || widget.widget_type === 'top_errors') {
                    w = 6; h = 10;  // Lists
                } else if (widget.widget_type === 'system_health_detailed' || widget.widget_type === 'quick_stats') {
                    w = 4; h = 6;  // Multi-metric
                } else {
                    w = 3; h = 4;  // Simple stats
                }
                
                // Move to next row if widget doesn't fit
                if (x + w > 12) {
                    x = 0;
                    y += h + 1;
                }
                
                loggers.system.info('  Widget ' + widget.id + ' (' + widget.widget_type + '): Setting position (' + x + ', ' + y + ', ' + w + ', ' + h + ')');
                
                db.run(
                    'UPDATE dashboard_widgets SET position_x = ?, position_y = ?, width = ?, height = ? WHERE id = ?',
                    [x, y, w, h, widget.id],
                    (err) => {
                        if (err) {
                            loggers.system.error('Error updating widget ' + widget.id + ':', err);
                        }
                        completed++;
                        
                        if (completed === widgets.length) {
                            loggers.system.info('Successfully reset ' + completed + ' widget positions');
                            res.json({ success: true, message: 'Widget positions reset successfully', count: completed });
                        }
                    }
                );
                
                x += w;
            });
            
            if (widgets.length === 0) {
                loggers.system.info('No widgets to reset');
                res.json({ success: true, message: 'No widgets to reset' });
            }
        }
    );
});

// Widget data endpoints - provide data for different widget types
app.get('/api/dashboard/widget-data/:type', requireAuth, async (req, res) => {
    const widgetType = req.params.type;
    
    switch(widgetType) {
        case 'log_count':
            db.get('SELECT COUNT(*) as count FROM log_events', (err, row) => {
                if (err) return res.status(500).json({ error: 'Failed to fetch data' });
                res.json({ count: row.count });
            });
            break;
            
        case 'today_count':
            const midnight = moment().tz(TIMEZONE).startOf('day').format('YYYY-MM-DD HH:mm:ss');
            db.get('SELECT COUNT(*) as count FROM log_events WHERE timestamp >= ?', [midnight], (err, row) => {
                if (err) return res.status(500).json({ error: 'Failed to fetch data' });
                res.json({ count: row.count });
            });
            break;
            
        case 'severity_breakdown':
            db.all(
                `SELECT severity, COUNT(*) as count 
                 FROM log_events 
                 WHERE timestamp >= datetime('now', '-24 hours')
                 GROUP BY severity`,
                (err, rows) => {
                    if (err) return res.status(500).json({ error: 'Failed to fetch data' });
                    res.json(rows);
                }
            );
            break;
            
        case 'recent_logs':
            const limit = parseInt(req.query.limit) || 10;
            db.all(
                'SELECT * FROM log_events ORDER BY timestamp DESC LIMIT ?',
                [limit],
                (err, rows) => {
                    if (err) return res.status(500).json({ error: 'Failed to fetch data' });
                    res.json(rows);
                }
            );
            break;
            
        case 'system_health':
            const health = {
                cpu: process.cpuUsage(),
                memory: {
                    used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
                    total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024)
                },
                uptime: Math.floor(process.uptime()),
                timestamp: moment().tz(TIMEZONE).format('YYYY-MM-DD HH:mm:ss')
            };
            res.json(health);
            break;
            
        case 'source_stats':
            db.all(
                `SELECT source, COUNT(*) as count 
                 FROM log_events 
                 WHERE timestamp >= datetime('now', '-24 hours')
                 GROUP BY source 
                 ORDER BY count DESC 
                 LIMIT 10`,
                (err, rows) => {
                    if (err) return res.status(500).json({ error: 'Failed to fetch data' });
                    res.json(rows);
                }
            );
            break;
            
        case 'hourly_trend':
            db.all(
                `SELECT 
                    strftime('%H', timestamp) as hour,
                    COUNT(*) as count
                 FROM log_events 
                 WHERE timestamp >= datetime('now', '-24 hours')
                 GROUP BY hour
                 ORDER BY hour`,
                (err, rows) => {
                    if (err) return res.status(500).json({ error: 'Failed to fetch data' });
                    res.json(rows);
                }
            );
            break;
            
        case 'error_rate':
            db.all(
                `SELECT 
                    strftime('%H', timestamp) as hour,
                    COUNT(CASE WHEN severity IN ('error', 'critical') THEN 1 END) as errors,
                    COUNT(*) as total
                 FROM log_events 
                 WHERE timestamp >= datetime('now', '-24 hours')
                 GROUP BY hour
                 ORDER BY hour`,
                (err, rows) => {
                    if (err) return res.status(500).json({ error: 'Failed to fetch data' });
                    const data = rows.map(row => ({
                        hour: row.hour,
                        rate: row.total > 0 ? ((row.errors / row.total) * 100).toFixed(1) : 0
                    }));
                    res.json(data);
                }
            );
            break;
            
        case 'api_keys_count':
            db.get('SELECT COUNT(*) as count FROM api_keys WHERE active = 1', (err, row) => {
                if (err) return res.status(500).json({ error: 'Failed to fetch data' });
                res.json({ count: row.count });
            });
            break;
            
        case 'uptime_monitor':
            const uptimeSeconds = Math.floor(process.uptime());
            const days = Math.floor(uptimeSeconds / 86400);
            const hours = Math.floor((uptimeSeconds % 86400) / 3600);
            const minutes = Math.floor((uptimeSeconds % 3600) / 60);
            res.json({ 
                uptime: uptimeSeconds,
                days,
                hours,
                minutes,
                formatted: `${days}d ${hours}h ${minutes}m`
            });
            break;
            
        case 'quick_stats':
            db.get(
                `SELECT 
                    COUNT(*) as total_logs,
                    COUNT(CASE WHEN severity = 'error' THEN 1 END) as errors,
                    COUNT(CASE WHEN timestamp >= datetime('now', '-1 hour') THEN 1 END) as last_hour,
                    COUNT(DISTINCT source) as sources
                 FROM log_events`,
                (err, row) => {
                    if (err) return res.status(500).json({ error: 'Failed to fetch data' });
                    res.json(row);
                }
            );
            break;
            
        case 'top_errors':
            db.all(
                `SELECT message, COUNT(*) as count, MAX(timestamp) as last_seen
                 FROM log_events 
                 WHERE severity IN ('error', 'critical')
                   AND timestamp >= datetime('now', '-24 hours')
                 GROUP BY message
                 ORDER BY count DESC
                 LIMIT 5`,
                (err, rows) => {
                    if (err) return res.status(500).json({ error: 'Failed to fetch data' });
                    res.json(rows);
                }
            );
            break;
            
        case 'system_health_detailed':
            // Get comprehensive system health data
            const mem = process.memoryUsage();
            const dbSizeQuery = new Promise((resolve) => {
                db.get("SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()", (err, row) => {
                    resolve(err ? 0 : row.size);
                });
            });
            
            dbSizeQuery.then(dbSize => {
                const cpuUsage = process.cpuUsage();
                const totalMem = require('os').totalmem();
                const freeMem = require('os').freemem();
                const usedMem = totalMem - freeMem;
                
                res.json({
                    heap: {
                        used: Math.round(mem.heapUsed / 1024 / 1024),
                        total: Math.round(mem.heapTotal / 1024 / 1024),
                        percent: Math.round((mem.heapUsed / mem.heapTotal) * 100)
                    },
                    system: {
                        used: Math.round(usedMem / 1024 / 1024),
                        total: Math.round(totalMem / 1024 / 1024),
                        percent: Math.round((usedMem / totalMem) * 100)
                    },
                    database: {
                        size: Math.round(dbSize / 1024 / 1024),
                        sizeFormatted: (dbSize / 1024 / 1024).toFixed(2) + ' MB'
                    },
                    cpu: {
                        user: Math.round(cpuUsage.user / 1000),
                        system: Math.round(cpuUsage.system / 1000)
                    },
                    uptime: Math.floor(process.uptime())
                });
            });
            break;
            
        case 'integration_status':
            // Get status of all integrations from the integration manager
            const integrationStatus = integrationManager.getStatus();
            const healthChecks = await integrationManager.checkAllIntegrationsHealth();
            
            res.json({
                mqtt: {
                    enabled: config.integrations.mqtt.enabled,
                    status: integrationStatus.mqtt?.connected ? 'online' : 'offline',
                    lastSeen: integrationStatus.mqtt?.lastMessage || null,
                    broker: config.integrations.mqtt.broker
                },
                homeAssistant: {
                    enabled: config.integrations.homeAssistant.enabled,
                    status: integrationStatus.homeAssistant?.connected ? 'online' : 'offline',
                    lastSeen: integrationStatus.homeAssistant?.lastEvent || null,
                    host: config.integrations.homeAssistant.host
                },
                unifi: {
                    enabled: config.integrations.unifi.enabled,
                    status: integrationStatus.unifi?.connected ? 'online' : 'offline',
                    lastSeen: integrationStatus.unifi?.lastPoll || null,
                    host: config.integrations.unifi.host
                },
                websocket: {
                    enabled: config.integrations.websocket.enabled,
                    status: integrationStatus.websocket?.active ? 'online' : 'offline',
                    clients: integrationStatus.websocket?.clients || 0,
                    port: config.integrations.websocket.port
                }
            });
            break;
            
        case 'error_rate_gauge':
            // Calculate overall error rate for last 24 hours
            db.get(
                `SELECT 
                    COUNT(CASE WHEN severity IN ('error', 'critical') THEN 1 END) as errors,
                    COUNT(*) as total
                 FROM log_events 
                 WHERE timestamp >= datetime('now', '-24 hours')`,
                (err, row) => {
                    if (err) return res.status(500).json({ error: 'Failed to fetch data' });
                    
                    const errorRate = row.total > 0 ? ((row.errors / row.total) * 100) : 0;
                    let status = 'good';
                    if (errorRate > 10) status = 'critical';
                    else if (errorRate > 5) status = 'warning';
                    
                    res.json({
                        errorRate: parseFloat(errorRate.toFixed(2)),
                        errors: row.errors,
                        total: row.total,
                        status,
                        threshold: {
                            good: 5,
                            warning: 10
                        }
                    });
                }
            );
            break;
            
        case 'network_monitor':
            // Return current network statistics
            if (!metricsManager) {
                return res.status(500).json({ error: 'Metrics manager not initialized' });
            }
            
            const networkStats = metricsManager.getNetworkStats();
            res.json(networkStats);
            break;
            
        default:
            res.status(404).json({ error: 'Unknown widget type' });
    }
});

// Favicon route - Enterprise Logging Platform SVG Icon
app.get('/favicon.svg', (req, res) => {
    res.setHeader('Content-Type', 'image/svg+xml');
    res.send(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="100" height="100">
        <defs>
            <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#0ea5e9;stop-opacity:1" />
                <stop offset="50%" style="stop-color:#3b82f6;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#6366f1;stop-opacity:1" />
            </linearGradient>
        </defs>
        <circle cx="50" cy="50" r="45" fill="url(#grad)" stroke="#1e293b" stroke-width="2"/>
        <rect x="20" y="35" width="60" height="4" rx="2" fill="white" opacity="0.9"/>
        <rect x="20" y="43" width="45" height="4" rx="2" fill="white" opacity="0.7"/>
        <rect x="20" y="51" width="55" height="4" rx="2" fill="white" opacity="0.8"/>
        <rect x="20" y="59" width="40" height="4" rx="2" fill="white" opacity="0.6"/>
        <circle cx="75" cy="25" r="8" fill="#10b981" stroke="white" stroke-width="2"/>
        <text x="75" y="30" font-family="Arial" font-size="10" fill="white" text-anchor="middle" font-weight="bold">‚úì</text>
    </svg>`);
});

// Health check endpoint
app.get('/health', (req, res) => {
    res.json({ 
        status: 'healthy', 
        timestamp: moment().tz(TIMEZONE).toISOString(),
        uptime: process.uptime(),
        version: config.system.version
    });
});

// =============================================================================
// START SERVER
// =============================================================================

// Server initialization tasks (called after server starts)
async function initializeServerComponents() {
    // Clear all sessions on server restart
    db.run('UPDATE user_sessions SET is_active = 0 WHERE is_active = 1', (err) => {
        if (err) {
            loggers.system.error('Failed to clear sessions on startup:', err);
        } else {
            db.get('SELECT changes() as count', (err, row) => {
                if (!err && row.count > 0) {
                    loggers.system.info(`üîÑ Cleared ${row.count} active session(s) on server restart`);
                    console.log(`üîÑ Cleared ${row.count} stale session(s) from previous run`);
                }
            });
        }
    });
    
    // Initialize integrations after server starts
    try {
        await integrationManager.initialize();
        integrationManager.initializeHealthChecks();
        
        // Temporarily disable foreign key constraints during engine initialization
        await dal.disableForeignKeys();
        
        // Initialize multi-protocol ingestion engine
        if (multiProtocolIngestionEngine && typeof multiProtocolIngestionEngine.initialize === 'function') {
            await multiProtocolIngestionEngine.initialize();
        }
        
        // Initialize distributed tracing engine
        if (distributedTracingEngine && typeof distributedTracingEngine.initialize === 'function') {
            await distributedTracingEngine.initialize();
        }
        
        // Initialize alerting engine
        alertingEngine.initialize();
        
        // Initialize advanced dashboard builder
        if (advancedDashboardBuilder && typeof advancedDashboardBuilder.initialize === 'function') {
            await advancedDashboardBuilder.initialize();
        }
        
        // Re-enable foreign key constraints after initialization
        await dal.enableForeignKeys();
        
        loggers.system.info('üéâ All systems operational!');
        
        // Note: Maintenance tasks (backups, cleanup) are already scheduled by integrationManager.initializeMaintenanceTasks()
        // Backups run daily at 2:00 AM (configurable via BACKUP_SCHEDULE env var)
        // Cleanup runs daily at 3:00 AM (configurable via CLEANUP_SCHEDULE env var)
        
        // Log server startup to database
        logToDatabase(`Server started on port ${PORT}`, 'info', 'server', 'logging-server');
        logToDatabase('All systems operational', 'info', 'server', 'logging-server');
        
        // Clean up old resolved alerts (older than 7 days)
        const sevenDaysAgo = moment().tz(TIMEZONE).subtract(7, 'days').format('YYYY-MM-DD HH:mm:ss');
        db.run('DELETE FROM system_alerts WHERE is_resolved = 1 AND resolved_at < ?', [sevenDaysAgo], function(err) {
            if (!err && this.changes > 0) {
                loggers.system.info(`üóëÔ∏è Cleaned up ${this.changes} old resolved alert(s)`);
            }
        });
        
        // Start real-time monitoring
        startRealTimeMonitoring();
        
    } catch (error) {
        loggers.system.error('Integration initialization failed:', error);
        logToDatabase(`Integration initialization failed: ${error.message}`, 'error', 'server', 'logging-server');
    }
}

// Real-time monitoring function
function startRealTimeMonitoring() {
    loggers.system.info('üîç Starting real-time monitoring...');
    
    // Monitor system metrics every 30 seconds
    setInterval(() => {
        if (metricsManager && metricsManager.initialized) {
            metricsManager.collectPerformanceMetrics();
        }
    }, 30000);
    
    // Monitor integration health every 5 minutes
    setInterval(async () => {
        try {
            if (integrationManager) {
                const healthStatus = await integrationManager.checkAllIntegrationsHealth();
                
                // Log any unhealthy integrations
                Object.entries(healthStatus).forEach(([integration, status]) => {
                    if (!status.connected && status.enabled) {
                        loggers.system.warn(`‚ö†Ô∏è Integration ${integration} is enabled but not connected`);
                        logToDatabase(`Integration ${integration} is not connected`, 'warning', 'monitoring', 'system');
                    }
                });
            }
        } catch (error) {
            loggers.system.error('Health monitoring failed:', error);
        }
    }, 300000); // 5 minutes
    
    // Clean up old logs based on retention policy every hour
    setInterval(async () => {
        try {
            const retentionDays = SYSTEM_SETTINGS.log_retention_days || 30;
            const cutoffDate = new Date(Date.now() - (retentionDays * 24 * 60 * 60 * 1000));
            
            const deletedCount = await dal.cleanupOldLogs(cutoffDate);
            if (deletedCount > 0) {
                loggers.system.info(`üóëÔ∏è Cleaned up ${deletedCount} old log entries (older than ${retentionDays} days)`);
            }
        } catch (error) {
            loggers.system.error('Error during log cleanup:', error);
        }
    }, 3600000); // 1 hour
    
    loggers.system.info('‚úÖ Real-time monitoring started');
}

// Check for HTTPS configuration
const USE_HTTPS = process.env.USE_HTTPS === 'true';
const SSL_KEY_PATH = process.env.SSL_KEY_PATH || '/app/ssl/key.pem';
const SSL_CERT_PATH = process.env.SSL_CERT_PATH || '/app/ssl/cert.pem';

let server;

if (USE_HTTPS && fs.existsSync(SSL_KEY_PATH) && fs.existsSync(SSL_CERT_PATH)) {
    // HTTPS Server
    const https = require('https');
    const sslOptions = {
        key: fs.readFileSync(SSL_KEY_PATH),
        cert: fs.readFileSync(SSL_CERT_PATH)
    };
    
    server = https.createServer(sslOptions, app);
    server.listen(PORT, async () => {
        loggers.system.info(`üîí HTTPS Server running on port ${PORT}`);
        loggers.system.info(`üåê Dashboard: https://localhost:${PORT}/dashboard`);
        loggers.system.info(`üîê Default login: admin / ChangeMe123!`);
        loggers.system.info(`üìç Database: ${dbPath}`);
        loggers.system.info(`üè¢ Enterprise Platform v${config.system.version} Ready!`);
        
        console.log('\nüéØ Enhanced Universal Logging Platform Started Successfully!');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log(`üîí HTTPS Enabled - Secure Connection`);
        console.log(`üåê Web Interface: https://localhost:${PORT}/dashboard`);
        console.log(`üîê Login: admin / ChangeMe123!`);
        console.log(`üìä API Endpoints: https://localhost:${PORT}/api/`);
        console.log(`üîí ESP32 Endpoint: https://localhost:${PORT}/log`);
        console.log(`üíö Health Check: https://localhost:${PORT}/health`);
        if (config.integrations.websocket.enabled) {
            console.log(`üîó WebSocket Server: wss://localhost:${config.integrations.websocket.port}`);
        }
        if (config.integrations.mqtt.enabled) {
            console.log(`üì° MQTT Integration: ${config.integrations.mqtt.broker}`);
        }
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
        
        await initializeServerComponents();
    });
} else {
    // HTTP Server (default)
    if (USE_HTTPS) {
        loggers.system.warn('‚ö†Ô∏è  HTTPS requested but SSL certificates not found');
        loggers.system.warn(`   Expected: ${SSL_KEY_PATH} and ${SSL_CERT_PATH}`);
        loggers.system.warn('   Falling back to HTTP mode');
        console.log('‚ö†Ô∏è  HTTPS requested but certificates not found - using HTTP\n');
    }
    
    server = app.listen(PORT, async () => {
        loggers.system.info(`üöÄ Enhanced Universal Logging Server running on port ${PORT}`);
        loggers.system.info(`üåê Dashboard: http://localhost:${PORT}/dashboard`);
        loggers.system.info(`üîê Default login: admin / ChangeMe123!`);
        loggers.system.info(`üìç Database: ${dbPath}`);
        loggers.system.info(`üè¢ Enterprise Platform v${config.system.version} Ready!`);
        
        console.log('\nüéØ Enhanced Universal Logging Platform Started Successfully!');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log(`üåê Web Interface: http://localhost:${PORT}/dashboard`);
        console.log(`üîê Login: admin / ChangeMe123!`);
        console.log(`üìä API Endpoints: http://localhost:${PORT}/api/`);
        console.log(`üîí ESP32 Endpoint: http://localhost:${PORT}/log`);
        console.log(`üíö Health Check: http://localhost:${PORT}/health`);
        if (config.integrations.websocket.enabled) {
            console.log(`üîó WebSocket Server: ws://localhost:${config.integrations.websocket.port}`);
        }
        if (config.integrations.mqtt.enabled) {
            console.log(`üì° MQTT Integration: ${config.integrations.mqtt.broker}`);
        }
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
        
        await initializeServerComponents();
    });
}

server.on('error', (error) => {
    console.error('üö® SERVER ERROR:', error);
    loggers.system.error('Server error:', error);
    if (error.code === 'EADDRINUSE') {
        console.error(`‚ùå Port ${PORT} is already in use!`);
        process.exit(1);
    }
});

server.on('listening', () => {
    const address = server.address();
    console.log(`‚úÖ Server confirmed listening on ${address.address}:${address.port}`);
});

// Improved error handling without aggressive shutdown
process.on('uncaughtException', (error) => {
    loggers.system.error('Uncaught Exception:', error);
    console.error('üö® UNCAUGHT EXCEPTION:', error);
    // Don't exit automatically - let it continue running
});

process.on('unhandledRejection', (reason, promise) => {
    loggers.system.error('Unhandled Rejection:', reason);
    console.error('üö® UNHANDLED REJECTION:', reason);
    // Don't exit automatically - let it continue running
});

// Only handle explicit shutdown requests
process.on('SIGTERM', () => {
    console.log('\nüõë SIGTERM received - shutting down gracefully...');
    server.close(() => {
        loggers.system.info('Server shut down successfully');
        db.close((err) => {
            if (err) {
                loggers.system.error('Error closing database:', err);
            } else {
                loggers.system.info('Database connection closed');
            }
            process.exit(0);
        });
    });
});

// Keep alive indicator
setInterval(() => {
    const uptime = Math.floor(process.uptime());
    if (uptime % 60 === 0) { // Log every minute
        loggers.system.info(`Server running - uptime: ${uptime}s`);
    }
}, 1000);

module.exports = { app, db, loggers, userManager, config };


