# Copilot Instructions for Logging Server

**IMPORTANT: READ THIS FILE AT THE START OF EVERY REQUEST**

## Core Philosophy
**Development workflow IS production workflow** - everything must be production-ready from the start.

## Database Architecture (CRITICAL UPDATE - Dec 11, 2025)

### PostgreSQL is REQUIRED for Production
**SQLite is NO LONGER SUPPORTED on Unraid due to SMB filesystem incompatibility.**

**Why PostgreSQL?**
- ‚ùå SQLite creates lock files (.db-wal, .db-shm) that fail on network filesystems (SMB/NFS)
- ‚ùå All journal modes (WAL/DELETE/MEMORY) fail with SQLITE_CANTOPEN on Unraid SMB shares
- ‚úÖ PostgreSQL uses connection pooling - no file-level locks
- ‚úÖ Enterprise-grade concurrency and reliability
- ‚úÖ Better performance for concurrent writes

### PostgreSQL Container Configuration
```bash
# PostgreSQL Container (required dependency)
docker run -d \
  --name logging-server-postgres \
  --restart unless-stopped \
  -e POSTGRES_DB=logging_server \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=SecureLogServerDB2024! \
  -v /mnt/user/appdata/logging-server-postgres/pgdata:/var/lib/postgresql/data \
  -p 5432:5432 \
  postgres:16-alpine
```

### Application Container (Updated)
```bash
docker run -d \
  --name logging-server \
  --restart unless-stopped \
  --link logging-server-postgres:postgres \
  -e DB_TYPE=postgres \
  -e POSTGRES_HOST=postgres \
  -e POSTGRES_PORT=5432 \
  -e POSTGRES_DB=logging_server \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=SecureLogServerDB2024! \
  -e JWT_SECRET=$(openssl rand -base64 32) \
  -e AUTH_PASSWORD=Admin123! \
  -e PORT=10180 \
  -p 10180:10180 -p 8081:8081 -p 8082:8082 \
  rejavarti/logging-server:latest
```

**CRITICAL Environment Variables:**
- `DB_TYPE=postgres` (REQUIRED - triggers PostgreSQL mode)
- `POSTGRES_HOST=postgres` (container link name)
- `POSTGRES_PORT=5432`
- `POSTGRES_DB=logging_server`
- `POSTGRES_USER=postgres`
- `POSTGRES_PASSWORD=SecureLogServerDB2024!`
- `JWT_SECRET=<random-generated>` (REQUIRED or container crashes)
- `AUTH_PASSWORD=Admin123!`

### Database Schema Management
- **PostgreSQL schema**: Pre-initialized via `migrations/postgres-schema.sql`
- **SQLite migration**: Automatically skipped when `DB_TYPE=postgres`
- **DAL table creation**: Automatically skipped for PostgreSQL (schema already complete)
- **Adapter selection**: Direct `PostgresAdapter` instantiation when `DB_TYPE=postgres` (no wrapper layer)

### Missing Tables Fix (Dec 11, 2025)
Initial PostgreSQL schema was missing several tables. If you encounter startup hangs, verify these tables exist:
- `system_settings` (required for app configuration)
- `encrypted_secrets` (for credential storage)
- `transaction_log`, `failed_operations_queue`, `system_error_log`, `database_health_log` (resilience tables)

Run this SQL if tables are missing:
```sql
-- See conversation history for complete table creation SQL
-- Or check server logs for "Failed to get all settings" errors
```

## Deployment Architecture
## Deployment Architecture

**CRITICAL**: This application runs **exclusively in Docker containers** with PostgreSQL backend.

### Container Information
- **Container Name**: `logging-server` (application) + `logging-server-postgres` (database)
- **Docker Image**: `rejavarti/logging-server:latest` (on Docker Hub)
- **Network Mode**: Bridge networking with `--link` for container-to-container communication
- **Web UI Port**: `http://192.168.222.3:10180` (host port 10180 ‚Üí container port 10180)
- **WebSocket Port**: `8081`
- **Stream Port**: `8082`
- **PostgreSQL Port**: `5432` (for admin access/debugging)
- **Data Volume**: `/mnt/user/appdata/logging-server-postgres/pgdata` (PostgreSQL data - persistent)
- **No SQLite Data Volume** (removed - PostgreSQL handles all persistence)

### Production Deployment (Unraid)
**Network Configuration**:
- **Always use bridge networking for Docker containers**
- Port mappings: `-p 10180:10180 -p 8081:8081 -p 8082:8082` (app) + `-p 5432:5432` (postgres)
- Container linking: `--link logging-server-postgres:postgres` (app connects to postgres container)
- Access via Unraid host IP: `192.168.222.3:10180`

**Deployment Commands** (Production/Unraid):
```bash
# 1. Start PostgreSQL container first
docker run -d \
  --name logging-server-postgres \
  --restart unless-stopped \
  -e POSTGRES_DB=logging_server \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=SecureLogServerDB2024! \
  -v /mnt/user/appdata/logging-server-postgres/pgdata:/var/lib/postgresql/data \
  -p 5432:5432 \
  postgres:16-alpine

# 2. Initialize schema (FIRST TIME ONLY - schema persists in volume)
docker exec -i logging-server-postgres psql -U postgres -d logging_server < migrations/postgres-schema.sql

# 3. Start application container
docker run -d \
  --name logging-server \
  --restart unless-stopped \
  --link logging-server-postgres:postgres \
  -e DB_TYPE=postgres \
  -e POSTGRES_HOST=postgres \
  -e POSTGRES_PORT=5432 \
  -e POSTGRES_DB=logging_server \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=SecureLogServerDB2024! \
  -e JWT_SECRET=$(openssl rand -base64 32) \
  -e AUTH_PASSWORD=Admin123! \
  -e PORT=10180 \
  -p 10180:10180 -p 8081:8081 -p 8082:8082 \
  rejavarti/logging-server:latest
```

For production deployment on Unraid servers:
- üìñ **Quick Start Guide**: See `UNRAID_QUICKSTART.md` for 5-minute setup
- üìñ **Full Documentation**: See `UNRAID_SETUP.md` for comprehensive guide
- üöÄ **Auto-Deploy Script**: Use `unraid-deploy.sh` for automated installation
- üì¶ **Template**: Use `unraid-template.xml` for Community Applications

### IMPORTANT: Production vs Development Mode
**This is a PRODUCTION deployment** - there are NO bind mounts to local code.
- ‚ùå Code changes on local machine do NOT affect running container
- ‚ùå `pm2 reload` will NOT pick up local changes
- ‚úÖ To deploy code changes: commit ‚Üí push to git ‚Üí rebuild Docker image ‚Üí push to Docker Hub ‚Üí redeploy container
- üîÑ Changes require full rebuild cycle (see "Full Deployment Workflow" below)

### Required Commands

#### Full Deployment Workflow (Production)
**CRITICAL**: After ANY code changes, follow this complete workflow:

```powershell
# 1. Commit changes to git
git add .
git commit -m "Description of changes"
git push

# 2. SSH to Unraid and rebuild Docker image from GitHub
ssh root@192.168.222.3 "rm -rf /tmp/logging_server && git clone https://github.com/rejavarti/logging_server.git /tmp/logging_server && cd /tmp/logging_server && docker build -t rejavarti/logging-server:latest ."

# 3. Push to Docker Hub (authenticate first if needed)
# Login: echo 'YOUR_PASSWORD' | ssh root@192.168.222.3 "docker login -u tom@macd.ca --password-stdin"
ssh root@192.168.222.3 "docker push rejavarti/logging-server:latest"

# 4. Redeploy application container on Unraid (PostgreSQL container stays running)
ssh root@192.168.222.3 "docker stop logging-server && docker rm logging-server && docker run -d --name logging-server --restart unless-stopped --link logging-server-postgres:postgres -e DB_TYPE=postgres -e POSTGRES_HOST=postgres -e POSTGRES_PORT=5432 -e POSTGRES_DB=logging_server -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD='SecureLogServerDB2024!' -e JWT_SECRET='$(openssl rand -base64 32)' -e AUTH_PASSWORD='Admin123!' -e PORT=10180 -p 10180:10180 -p 8081:8081 -p 8082:8082 rejavarti/logging-server:latest"

# 5. Verify deployment
ssh root@192.168.222.3 "docker logs logging-server --tail 50"
ssh root@192.168.222.3 "docker logs logging-server-postgres --tail 20"
```

**ALWAYS complete ALL 5 steps** - partial deployments cause version mismatches between git/Docker/container.

**NEVER restart PostgreSQL container** unless specifically needed - it persists data and doesn't need rebuilds.

#### Quick Status Checks
```powershell
# Check both containers
ssh root@192.168.222.3 "docker ps | grep logging-server"

# View application logs
ssh root@192.168.222.3 "docker logs logging-server --tail 50 -f"

# View PostgreSQL logs
ssh root@192.168.222.3 "docker logs logging-server-postgres --tail 20"

# Check database connection
ssh root@192.168.222.3 "docker exec logging-server-postgres psql -U postgres -d logging_server -c 'SELECT COUNT(*) FROM logs'"

# Check table existence
ssh root@192.168.222.3 "docker exec logging-server-postgres psql -U postgres -d logging_server -c '\dt'"
```

#### Health Checks
```powershell
# Check health endpoint (from local machine)
Invoke-WebRequest -Uri "http://192.168.222.3:10180/health" -UseBasicParsing

# Verify application container health
ssh root@192.168.222.3 "docker inspect logging-server --format='{{.State.Health.Status}}'"

# Verify PostgreSQL is accepting connections
ssh root@192.168.222.3 "docker exec logging-server-postgres pg_isready -U postgres"
```

## Development Workflow Rules

1. **Always commit changes to git immediately after making them** - never leave uncommitted code
2. **Always follow the complete 5-step deployment workflow** - commit ‚Üí rebuild ‚Üí push Docker Hub ‚Üí redeploy ‚Üí verify
3. **Always verify container is running on Unraid** before troubleshooting
4. **Always use port 10180** for web access (container listens on 10180, NOT 3000)
5. **Always SSH to Unraid for container operations** - container runs on 192.168.222.3, not localhost
6. **Never skip git commits** - Docker images are built from GitHub, not local files
7. **Never use bind mounts for production** - full rebuild required for all changes
8. **Never leave partial deployments** - always complete all 5 steps of deployment workflow

## Code Standards

### Feature Implementation Policy
- **NO placeholders, stubs, or "future consideration" code**
- Every feature added must have **full, working implementation**
- All endpoints must have real logic, not 501 responses
- **If a button exists in the UI, the backend endpoint must be functional**
- **All buttons must work with proper endpoints - no exceptions**
- Test all features before considering them complete
- Development = Production quality standards

### File Structure
- Routes: `routes/`
- APIs: `routes/api/`
- Engines: `engines/`
- Configs: `configs/`
- Templates: `configs/templates/`
- Public assets: `public/`

### Database Access
- **Always use `database-access-layer.js` (DAL)** for all database operations
- **Never write raw SQL** - use DAL methods which handle both PostgreSQL and SQLite
- **PostgreSQL adapter**: `postgres-adapter.js` - converts `?` placeholders to `$1, $2, ...`
- **Direct instantiation**: When `DB_TYPE=postgres`, DAL creates `PostgresAdapter` directly (no universal wrapper)
- All DAL methods are async/await (promisified)

### Security
- Authentication required for all admin routes
- JWT tokens for API authentication
- Environment variables for secrets (JWT_SECRET, AUTH_PASSWORD)
- **EXCEPTION**: `/log` endpoint has NO authentication (allows Home Assistant, ESP32, and other IoT devices to POST logs without credentials)
- **Home Assistant Integration**: Uses `rest_command` to POST logs via HTTP without authentication
- **ESP32 Integration**: Devices POST directly to `/log` without credentials

## Current System State

### Recent Fixes & Enhancements (Dec 11, 2025)
- **PostgreSQL Migration**: Complete migration from SQLite to PostgreSQL due to SMB incompatibility
- **Direct Adapter Instantiation**: Removed universal wrapper layer for PostgreSQL (simpler, faster)
- **Schema Pre-initialization**: PostgreSQL schema created via `postgres-schema.sql` before app starts
- **Migration Skip Logic**: Server.js and DAL skip SQLite-specific code when `DB_TYPE=postgres`
- **Missing Tables Fix**: Added `system_settings`, `encrypted_secrets`, and resilience tables to PostgreSQL
- **Container Architecture**: Two-container setup (app + postgres) with `--link` networking
- **Performance Optimizations**: Async loading pattern (dashboard 778ms vs 13s), HTTP timeout fixes (65s keepAlive)
- **Widget Sizes**: Reduced by 20% (240x200, 320x320, 480x320)
- **Logs Today Fix**: Uses timezone-aware query with `localtime` for accurate daily counts
- **Auto-save Layout**: ResizeObserver with 1s debounce automatically saves widget positions/sizes
- **Position Validation**: Relaxed to allow small negative positions (< -50px) for edge dragging
- **Server Location Settings**: Added city, latitude, longitude fields in settings for map display
- **Authentication Fix**: `/log` endpoint has NO authentication to allow Home Assistant and ESP32 devices to POST logs
- **Cache Busting**: ETag headers and version stamps to prevent browser caching issues
- **HTTP Compatibility**: Removed Cross-Origin security headers that forced HTTPS upgrade

### Dashboard Features
- **Main Dashboard**: `/dashboard` - Fully functional with widget grid (Muuri), charts (ECharts), and live data
- **Dashboard Builder**: REMOVED - Engine disabled, routes unmounted, sidebar links removed
- **Widget Marketplace**: Available in main dashboard with install functionality
- **Layout Persistence**: Server-side via `/api/dashboard/positions` (GET/POST) with localStorage fallback
- **Reset Layout**: `/api/dashboard/reset-positions` clears saved positions
- **Auto-save on Resize**: Widgets automatically save size changes after 1 second debounce

### Assets & Dependencies
- All vendor assets served locally from `/public/vendor/` (no CDN dependencies)
- Muuri 0.9.5 for drag/drop grid
- Apache ECharts 5.x for charts
- Font Awesome 6.x for icons
- CSP configured to allow worker-src blob for Muuri

### Data Seeding
```powershell
# Seed integrations
node scripts/seed-integrations.js

# Seed logs
node scripts/seed-logs.js

# Seed integration documentation
node scripts/seed-integration-docs.js

# Seed all
npm run seed:all
```

## Troubleshooting Priority

1. **"Can't connect to server"** ‚Üí Check both containers: `ssh root@192.168.222.3 "docker ps | grep logging-server"`
2. **"Changes not showing"** ‚Üí Did you complete all 5 deployment steps? Check git status and Docker image timestamp
3. **"Server hangs on startup"** ‚Üí Check for missing PostgreSQL tables: `docker exec logging-server-postgres psql -U postgres -d logging_server -c '\dt'`
4. **"SQLITE_CANTOPEN errors"** ‚Üí This means SQLite is being used instead of PostgreSQL. Verify `DB_TYPE=postgres` environment variable.
5. **"JWT_SECRET errors"** ‚Üí Container crashes without JWT_SECRET. Regenerate: `openssl rand -base64 32`
6. **"Database connection refused"** ‚Üí Check PostgreSQL container is running and linked properly
7. **"Logs not flowing from Home Assistant"** ‚Üí Check `/log` endpoint has NO authentication middleware
8. **"Container won't start"** ‚Üí Check logs: `ssh root@192.168.222.3 "docker logs logging-server"`
9. **"PostgreSQL errors"** ‚Üí Verify volume mount: `ssh root@192.168.222.3 "docker exec logging-server-postgres ls -la /var/lib/postgresql/data"`
10. **"Browser showing old code"** ‚Üí Hard refresh (Ctrl+Shift+R) or check ETag version stamp
11. **"Port not accessible"** ‚Üí Verify port mapping: `ssh root@192.168.222.3 "docker port logging-server"`
12. **"Git/Docker/Container out of sync"** ‚Üí Run full 5-step deployment workflow from scratch

## What NOT to Do

‚ùå Never run `npm start` on the host  
‚ùå Never use SQLite on Unraid (SMB filesystem incompatibility)
‚ùå Never skip `DB_TYPE=postgres` environment variable
‚ùå Never forget to start PostgreSQL container before app container
‚ùå Never restart PostgreSQL container unnecessarily (data persists)
‚ùå Never create scripts that run Node directly outside Docker  
‚ùå Never assume port 3000 is accessible (container uses 10180)  
‚ùå Never assume localhost works (container runs on Unraid 192.168.222.3)
‚ùå Never skip git commits before rebuilding Docker image
‚ùå Never do partial deployments (must complete all 5 steps)
‚ùå Never use hot-patches without following up with full deployment
‚ùå Never add authentication to `/log` endpoint (breaks Home Assistant/ESP32)
‚ùå Never modify code without reloading the container  
‚ùå Never suggest recreating features that were explicitly removed (Dashboard Builder)  
‚ùå Never use CDN links (all assets are vendored locally)  
‚ùå Never use macvlan networking (bridge only)
‚ùå Never create placeholder/stub implementations - all features must be fully functional
‚ùå Never add buttons without working backend endpoints
‚ùå Never leave uncommitted changes in the repository
‚ùå Never rebuild Docker image from stale git commits

## User Expectations
- "I want ALL buttons working with proper endpoints" - no exceptions
- Every feature must be production-ready when shipped
- No incomplete implementations
- UI controls must have working backend handlers
- **ALL changes must be committed to git immediately**
- **ALL changes must go through complete 5-step deployment workflow**
- "What we had before" means committed code in git, not hot-patches
- Never blame user configuration when the issue is in the code
- Always verify git/Docker/container are synchronized before troubleshooting

## Emergency Recovery

If the containers are broken:
```powershell
# Full rebuild from GitHub (latest commit) - PostgreSQL + Application
ssh root@192.168.222.3 @"
# Stop and remove existing containers
docker stop logging-server logging-server-postgres 2>/dev/null
docker rm logging-server logging-server-postgres 2>/dev/null

# Start PostgreSQL
docker run -d --name logging-server-postgres --restart unless-stopped \
  -e POSTGRES_DB=logging_server -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=SecureLogServerDB2024! \
  -v /mnt/user/appdata/logging-server-postgres/pgdata:/var/lib/postgresql/data \
  -p 5432:5432 postgres:16-alpine

# Wait for PostgreSQL to be ready
sleep 5

# Rebuild and start application
rm -rf /tmp/logging_server
git clone https://github.com/rejavarti/logging_server.git /tmp/logging_server
cd /tmp/logging_server
docker build -t rejavarti/logging-server:latest .
docker run -d --name logging-server --restart unless-stopped \
  --link logging-server-postgres:postgres \
  -e DB_TYPE=postgres -e POSTGRES_HOST=postgres -e POSTGRES_PORT=5432 \
  -e POSTGRES_DB=logging_server -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD='SecureLogServerDB2024!' \
  -e JWT_SECRET='$(openssl rand -base64 32)' -e AUTH_PASSWORD='Admin123!' \
  -e PORT=10180 -p 10180:10180 -p 8081:8081 -p 8082:8082 \
  rejavarti/logging-server:latest
"@

# Check recovery
ssh root@192.168.222.3 "docker logs logging-server-postgres --tail 10"
ssh root@192.168.222.3 "docker logs logging-server --tail 30"
```

## Resilience & Reliability (Phase 1 Enhancements)
The system now includes automatic resilience mechanisms to prevent data loss and improve observability.

### New Core Tables
- `transaction_log`: Forensic record of all multi-step operations (status: pending ‚Üí committed / rolled_back / failed).
- `failed_operations_queue`: Captures transient failures (e.g., inserts) with automatic retry and exponential backoff.
- `system_error_log`: Centralized error store with deduplication fields (occurrence_count, first_seen, last_seen).
- `database_health_log`: Daily snapshots of database integrity & size.

### Worker Scheduling
- Failed operation retry worker runs every 60s (replays `log_insert` operations; extensible for other types).
- Health snapshot worker runs every 24h (quick_check + size + table counts).

### DAL Helper Methods
- `dal.logTransaction(entry)` and `dal.updateTransactionStatus(id, status, error)`.
- `dal.queueFailedOperation(op)` / `dal.fetchRetryableFailedOperations(limit)` / `dal.markFailedOperation(id, fields)`.
- `dal.logSystemError(entry)` for structured error auditing.
- `dal.logDatabaseHealthSnapshot(snapshot)` for daily metrics.

### Retry Backoff Logic
Retry intervals use exponential backoff: `2^attempt * 60s` until `max_retries` reached (then status ‚Üí `abandoned`).

### When to Use Failed Operation Queue
Use only for transient, recoverable failures (DB busy, lock timeouts, write conflicts). Do NOT queue logical validation errors.

### Testing & Verification (Added to unified test)
1. Verify presence of 4 resilience tables.
2. Force a controlled insert error; ensure a row appears in `failed_operations_queue` and later succeeds.
3. Log a synthetic system error and confirm row in `system_error_log`.
4. Verify a health snapshot row in `database_health_log` (may mock immediate call in test).

### Operational Guidelines
- Never manually delete rows from `failed_operations_queue`; mark abandoned for audit.
- Investigate `system_error_log` spikes by grouping on `error_code` and `affected_component`.
- Use `transaction_log` to reconstruct multi-step flows during incident analysis.
- Automate backup verification and append results to `database_health_log` (future phase).

### Future Extension Points
- Add support for streaming retry metrics to dashboard.
- Circuit breaker table to complement `integration_health` for external services.
- Query performance logging table for slow query detection.

